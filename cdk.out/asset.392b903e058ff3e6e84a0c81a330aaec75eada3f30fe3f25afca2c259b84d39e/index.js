var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b3) => (typeof require !== "undefined" ? require : a3)[b3]
}) : x3)(function(x3) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@asteasolutions/zod-to-openapi/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/index.cjs"(exports) {
    "use strict";
    function __rest2(s3, e3) {
      var t3 = {};
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
        t3[p3] = s3[p3];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
          if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
            t3[p3[i3]] = s3[p3[i3]];
        }
      return t3;
    }
    function isZodType(schema, typeName) {
      var _a2;
      return ((_a2 = schema === null || schema === void 0 ? void 0 : schema._def) === null || _a2 === void 0 ? void 0 : _a2.typeName) === typeName;
    }
    function isAnyZodType(schema) {
      return "_def" in schema;
    }
    function preserveMetadataFromModifier(zod, modifier) {
      const zodModifier = zod.ZodType.prototype[modifier];
      zod.ZodType.prototype[modifier] = function(...args) {
        const result = zodModifier.apply(this, args);
        result._def.openapi = this._def.openapi;
        return result;
      };
    }
    function extendZodWithOpenApi2(zod) {
      if (typeof zod.ZodType.prototype.openapi !== "undefined") {
        return;
      }
      zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
        var _a2, _b, _c, _d, _e, _f;
        const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
        const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest2(_g, ["param"]);
        const _internal = Object.assign(Object.assign({}, (_a2 = this._def.openapi) === null || _a2 === void 0 ? void 0 : _a2._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
        const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
          param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
        } : void 0);
        const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
        if (isZodType(this, "ZodObject")) {
          const originalExtend = this.extend;
          result.extend = function(...args) {
            var _a3, _b2, _c2, _d2, _e2, _f2;
            const extendedResult = originalExtend.apply(this, args);
            extendedResult._def.openapi = {
              _internal: {
                extendedFrom: ((_b2 = (_a3 = this._def.openapi) === null || _a3 === void 0 ? void 0 : _a3._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2._internal.extendedFrom
              },
              metadata: (_f2 = extendedResult._def.openapi) === null || _f2 === void 0 ? void 0 : _f2.metadata
            };
            return extendedResult;
          };
        }
        return result;
      };
      preserveMetadataFromModifier(zod, "optional");
      preserveMetadataFromModifier(zod, "nullable");
      preserveMetadataFromModifier(zod, "default");
      preserveMetadataFromModifier(zod, "transform");
      preserveMetadataFromModifier(zod, "refine");
      const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
      zod.ZodObject.prototype.deepPartial = function() {
        const initialShape = this._def.shape();
        const result = zodDeepPartial.apply(this);
        const resultShape = result._def.shape();
        Object.entries(resultShape).forEach(([key, value]) => {
          var _a2, _b;
          value._def.openapi = (_b = (_a2 = initialShape[key]) === null || _a2 === void 0 ? void 0 : _a2._def) === null || _b === void 0 ? void 0 : _b.openapi;
        });
        result._def.openapi = void 0;
        return result;
      };
      const zodPick = zod.ZodObject.prototype.pick;
      zod.ZodObject.prototype.pick = function(...args) {
        const result = zodPick.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
      const zodOmit = zod.ZodObject.prototype.omit;
      zod.ZodObject.prototype.omit = function(...args) {
        const result = zodOmit.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
    }
    function isEqual(x3, y2) {
      if (x3 === null || x3 === void 0 || y2 === null || y2 === void 0) {
        return x3 === y2;
      }
      if (x3 === y2 || x3.valueOf() === y2.valueOf()) {
        return true;
      }
      if (Array.isArray(x3)) {
        if (!Array.isArray(y2)) {
          return false;
        }
        if (x3.length !== y2.length) {
          return false;
        }
      }
      if (!(x3 instanceof Object) || !(y2 instanceof Object)) {
        return false;
      }
      const keysX = Object.keys(x3);
      return Object.keys(y2).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x3[key], y2[key]));
    }
    var ObjectSet = class {
      constructor() {
        this.buckets = /* @__PURE__ */ new Map();
      }
      put(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          this.buckets.set(hashCode, [value]);
          return;
        }
        const alreadyHasItem = itemsByCode.some((_2) => isEqual(_2, value));
        if (!alreadyHasItem) {
          itemsByCode.push(value);
        }
      }
      contains(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          return false;
        }
        return itemsByCode.some((_2) => isEqual(_2, value));
      }
      values() {
        return [...this.buckets.values()].flat();
      }
      stats() {
        let totalBuckets = 0;
        let totalValues = 0;
        let collisions = 0;
        for (const bucket of this.buckets.values()) {
          totalBuckets += 1;
          totalValues += bucket.length;
          if (bucket.length > 1) {
            collisions += 1;
          }
        }
        const hashEffectiveness = totalBuckets / totalValues;
        return { totalBuckets, collisions, totalValues, hashEffectiveness };
      }
      hashCodeOf(object) {
        let hashCode = 0;
        if (Array.isArray(object)) {
          for (let i3 = 0; i3 < object.length; i3++) {
            hashCode ^= this.hashCodeOf(object[i3]) * i3;
          }
          return hashCode;
        }
        if (typeof object === "string") {
          for (let i3 = 0; i3 < object.length; i3++) {
            hashCode ^= object.charCodeAt(i3) * i3;
          }
          return hashCode;
        }
        if (typeof object === "number") {
          return object;
        }
        if (typeof object === "object") {
          for (const [key, value] of Object.entries(object)) {
            hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
          }
        }
        return hashCode;
      }
    };
    function isNil(value) {
      return value === null || value === void 0;
    }
    function mapValues(object, mapper) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        result[key] = mapper(value);
      });
      return result;
    }
    function omit(object, keys) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!keys.some((keyToOmit) => keyToOmit === key)) {
          result[key] = value;
        }
      });
      return result;
    }
    function omitBy(object, predicate) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!predicate(value, key)) {
          result[key] = value;
        }
      });
      return result;
    }
    function compact(arr) {
      return arr.filter((elem) => !isNil(elem));
    }
    var objectEquals = isEqual;
    function uniq(values) {
      const set = new ObjectSet();
      values.forEach((value) => set.put(value));
      return [...set.values()];
    }
    function isString(val2) {
      return typeof val2 === "string";
    }
    function getOpenApiMetadata(zodSchema) {
      var _a2, _b;
      return omitBy((_b = (_a2 = zodSchema._def.openapi) === null || _a2 === void 0 ? void 0 : _a2.metadata) !== null && _b !== void 0 ? _b : {}, isNil);
    }
    var OpenAPIRegistry2 = class {
      constructor(parents) {
        this.parents = parents;
        this._definitions = [];
      }
      get definitions() {
        var _a2, _b;
        const parentDefinitions = (_b = (_a2 = this.parents) === null || _a2 === void 0 ? void 0 : _a2.flatMap((par) => par.definitions)) !== null && _b !== void 0 ? _b : [];
        return [...parentDefinitions, ...this._definitions];
      }
      /**
       * Registers a new component schema under /components/schemas/${name}
       */
      register(refId, zodSchema) {
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        this._definitions.push({ type: "schema", schema: schemaWithRefId });
        return schemaWithRefId;
      }
      /**
       * Registers a new parameter schema under /components/parameters/${name}
       */
      registerParameter(refId, zodSchema) {
        var _a2, _b, _c;
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        const currentMetadata = (_a2 = schemaWithRefId._def.openapi) === null || _a2 === void 0 ? void 0 : _a2.metadata;
        const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));
        this._definitions.push({
          type: "parameter",
          schema: schemaWithMetadata
        });
        return schemaWithMetadata;
      }
      /**
       * Registers a new path that would be generated under paths:
       */
      registerPath(route) {
        this._definitions.push({
          type: "route",
          route
        });
      }
      /**
       * Registers a new webhook that would be generated under webhooks:
       */
      registerWebhook(webhook) {
        this._definitions.push({
          type: "webhook",
          webhook
        });
      }
      /**
       * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
       *
       * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
       * @param name The name of the object, it is the key under the component
       *             type in the resulting OpenAPI document
       * @param component The actual object to put there
       */
      registerComponent(type, name, component) {
        this._definitions.push({
          type: "component",
          componentType: type,
          name,
          component
        });
        return {
          name,
          ref: { $ref: `#/components/${type}/${name}` }
        };
      }
      schemaWithRefId(refId, zodSchema) {
        return zodSchema.openapi(refId);
      }
    };
    var ZodToOpenAPIError = class {
      constructor(message) {
        this.message = message;
      }
    };
    var ConflictError = class extends ZodToOpenAPIError {
      constructor(message, data) {
        super(message);
        this.data = data;
      }
    };
    var MissingParameterDataError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
        this.data = data;
      }
    };
    function enhanceMissingParametersError(action, paramsToAdd) {
      try {
        return action();
      } catch (error) {
        if (error instanceof MissingParameterDataError) {
          throw new MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
        }
        throw error;
      }
    }
    var UnknownZodTypeError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
        this.data = data;
      }
    };
    var Metadata = class {
      static getMetadata(zodSchema) {
        var _a2;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
        return {
          _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
          metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
        };
      }
      static getInternalMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
      }
      static getParamMetadata(zodSchema) {
        var _a2, _b;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
        return {
          _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
          metadata: Object.assign(Object.assign({}, metadata === null || metadata === void 0 ? void 0 : metadata.metadata), {
            // A description provided from .openapi() should be taken with higher precedence
            param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _b === void 0 ? void 0 : _b.param)
          })
        };
      }
      /**
       * A method that omits all custom keys added to the regular OpenAPI
       * metadata properties
       */
      static buildSchemaMetadata(metadata) {
        return omitBy(omit(metadata, ["param"]), isNil);
      }
      static buildParameterMetadata(metadata) {
        return omitBy(metadata, isNil);
      }
      static applySchemaMetadata(initialData, metadata) {
        return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isNil);
      }
      static getRefId(zodSchema) {
        var _a2;
        return (_a2 = this.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.refId;
      }
      static unwrapChained(schema) {
        return this.unwrapUntil(schema);
      }
      static getDefaultValue(zodSchema) {
        const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
        return unwrapped === null || unwrapped === void 0 ? void 0 : unwrapped._def.defaultValue();
      }
      static unwrapUntil(schema, typeName) {
        if (typeName && isZodType(schema, typeName)) {
          return schema;
        }
        if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
          return this.unwrapUntil(schema.unwrap(), typeName);
        }
        if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
          return this.unwrapUntil(schema._def.innerType, typeName);
        }
        if (isZodType(schema, "ZodEffects")) {
          return this.unwrapUntil(schema._def.schema, typeName);
        }
        if (isZodType(schema, "ZodPipeline")) {
          return this.unwrapUntil(schema._def.in, typeName);
        }
        return typeName ? void 0 : schema;
      }
      static isOptionalSchema(zodSchema) {
        return zodSchema.isOptional();
      }
    };
    var ArrayTransformer = class {
      transform(zodSchema, mapNullableType, mapItems) {
        var _a2, _b;
        const itemType = zodSchema._def.type;
        return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a2 = zodSchema._def.minLength) === null || _a2 === void 0 ? void 0 : _a2.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === void 0 ? void 0 : _b.value });
      }
    };
    var BigIntTransformer = class {
      transform(mapNullableType) {
        return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
      }
    };
    var DiscriminatedUnionTransformer = class {
      transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
        const options = [...zodSchema.options.values()];
        const optionSchema = options.map(mapItem);
        if (isNullable) {
          return {
            oneOf: mapNullableOfArray(optionSchema, isNullable)
          };
        }
        return {
          oneOf: optionSchema,
          discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
        };
      }
      mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
        if (zodObjects.some((obj) => Metadata.getRefId(obj) === void 0)) {
          return void 0;
        }
        const mapping = {};
        zodObjects.forEach((obj) => {
          var _a2;
          const refId = Metadata.getRefId(obj);
          const value = (_a2 = obj.shape) === null || _a2 === void 0 ? void 0 : _a2[discriminator];
          if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
            const keys = Object.values(value.enum).filter(isString);
            keys.forEach((enumValue) => {
              mapping[enumValue] = generateSchemaRef(refId);
            });
            return;
          }
          const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
          if (typeof literalValue !== "string") {
            throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
          }
          mapping[literalValue] = generateSchemaRef(refId);
        });
        return {
          propertyName: discriminator,
          mapping
        };
      }
    };
    var EnumTransformer = class {
      transform(zodSchema, mapNullableType) {
        return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
      }
    };
    var IntersectionTransformer = class {
      transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
        const subtypes = this.flattenIntersectionTypes(zodSchema);
        const allOfSchema = {
          allOf: subtypes.map(mapItem)
        };
        if (isNullable) {
          return {
            anyOf: mapNullableOfArray([allOfSchema], isNullable)
          };
        }
        return allOfSchema;
      }
      flattenIntersectionTypes(schema) {
        if (!isZodType(schema, "ZodIntersection")) {
          return [schema];
        }
        const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
        const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
        return [...leftSubTypes, ...rightSubTypes];
      }
    };
    var LiteralTransformer = class {
      transform(zodSchema, mapNullableType) {
        return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
      }
    };
    function enumInfo(enumObject) {
      const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
      const values = keysExceptReverseMappings.map((key) => enumObject[key]);
      const numericCount = values.filter((_2) => typeof _2 === "number").length;
      const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
      return { values, type };
    }
    var NativeEnumTransformer = class {
      transform(zodSchema, mapNullableType) {
        const { type, values } = enumInfo(zodSchema._def.values);
        if (type === "mixed") {
          throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
        }
        return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
      }
    };
    var NumberTransformer = class {
      transform(zodSchema, mapNullableType, getNumberChecks) {
        return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
      }
    };
    var ObjectTransformer = class {
      transform(zodSchema, defaultValue, mapNullableType, mapItem) {
        var _a2;
        const extendedFrom = (_a2 = Metadata.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.extendedFrom;
        const required = this.requiredKeysOf(zodSchema);
        const properties = mapValues(zodSchema._def.shape(), mapItem);
        if (!extendedFrom) {
          return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
        }
        const parent = extendedFrom.schema;
        mapItem(parent);
        const keysRequiredByParent = this.requiredKeysOf(parent);
        const propsOfParent = mapValues(parent === null || parent === void 0 ? void 0 : parent._def.shape(), mapItem);
        const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
          return !objectEquals(propsOfParent[key], type);
        }));
        const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
        const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
        return {
          allOf: [
            { $ref: `#/components/schemas/${extendedFrom.refId}` },
            objectData
          ]
        };
      }
      generateAdditionalProperties(zodSchema, mapItem) {
        const unknownKeysOption = zodSchema._def.unknownKeys;
        const catchallSchema = zodSchema._def.catchall;
        if (isZodType(catchallSchema, "ZodNever")) {
          if (unknownKeysOption === "strict") {
            return { additionalProperties: false };
          }
          return {};
        }
        return { additionalProperties: mapItem(catchallSchema) };
      }
      requiredKeysOf(objectSchema) {
        return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key, _type]) => key);
      }
    };
    var RecordTransformer = class {
      transform(zodSchema, mapNullableType, mapItem) {
        const propertiesType = zodSchema._def.valueType;
        const keyType = zodSchema._def.keyType;
        const propertiesSchema = mapItem(propertiesType);
        if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
          const keys = Object.values(keyType.enum).filter(isString);
          const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
          return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
        }
        return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
      }
    };
    var StringTransformer = class {
      transform(zodSchema, mapNullableType) {
        var _a2, _b, _c;
        const regexCheck = this.getZodStringCheck(zodSchema, "regex");
        const length = (_a2 = this.getZodStringCheck(zodSchema, "length")) === null || _a2 === void 0 ? void 0 : _a2.value;
        const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : void 0 : void 0;
        const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : void 0 : void 0;
        return Object.assign(Object.assign({}, mapNullableType("string")), {
          // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
          minLength: length !== null && length !== void 0 ? length : maxLength,
          maxLength: length !== null && length !== void 0 ? length : minLength,
          format: this.mapStringFormat(zodSchema),
          pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source
        });
      }
      /**
       * Attempts to map Zod strings to known formats
       * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
       */
      mapStringFormat(zodString) {
        if (zodString.isUUID)
          return "uuid";
        if (zodString.isEmail)
          return "email";
        if (zodString.isURL)
          return "uri";
        if (zodString.isDate)
          return "date";
        if (zodString.isDatetime)
          return "date-time";
        if (zodString.isCUID)
          return "cuid";
        if (zodString.isCUID2)
          return "cuid2";
        if (zodString.isULID)
          return "ulid";
        if (zodString.isIP)
          return "ip";
        if (zodString.isEmoji)
          return "emoji";
        return void 0;
      }
      getZodStringCheck(zodString, kind) {
        return zodString._def.checks.find((check) => {
          return check.kind === kind;
        });
      }
    };
    var TupleTransformer = class {
      constructor(versionSpecifics) {
        this.versionSpecifics = versionSpecifics;
      }
      transform(zodSchema, mapNullableType, mapItem) {
        const { items } = zodSchema._def;
        const schemas = items.map(mapItem);
        return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
      }
    };
    var UnionTransformer = class {
      transform(zodSchema, mapNullableOfArray, mapItem) {
        const options = this.flattenUnionTypes(zodSchema);
        const schemas = options.map((schema) => {
          const optionToGenerate = this.unwrapNullable(schema);
          return mapItem(optionToGenerate);
        });
        return {
          anyOf: mapNullableOfArray(schemas)
        };
      }
      flattenUnionTypes(schema) {
        if (!isZodType(schema, "ZodUnion")) {
          return [schema];
        }
        const options = schema._def.options;
        return options.flatMap((option) => this.flattenUnionTypes(option));
      }
      unwrapNullable(schema) {
        if (isZodType(schema, "ZodNullable")) {
          return this.unwrapNullable(schema.unwrap());
        }
        return schema;
      }
    };
    var OpenApiTransformer = class {
      constructor(versionSpecifics) {
        this.versionSpecifics = versionSpecifics;
        this.objectTransformer = new ObjectTransformer();
        this.stringTransformer = new StringTransformer();
        this.numberTransformer = new NumberTransformer();
        this.bigIntTransformer = new BigIntTransformer();
        this.literalTransformer = new LiteralTransformer();
        this.enumTransformer = new EnumTransformer();
        this.nativeEnumTransformer = new NativeEnumTransformer();
        this.arrayTransformer = new ArrayTransformer();
        this.unionTransformer = new UnionTransformer();
        this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer();
        this.intersectionTransformer = new IntersectionTransformer();
        this.recordTransformer = new RecordTransformer();
        this.tupleTransformer = new TupleTransformer(versionSpecifics);
      }
      transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
        if (isZodType(zodSchema, "ZodNull")) {
          return this.versionSpecifics.nullType;
        }
        if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
          return this.versionSpecifics.mapNullableType(void 0, isNullable);
        }
        if (isZodType(zodSchema, "ZodObject")) {
          return this.objectTransformer.transform(
            zodSchema,
            defaultValue,
            // verified on TS level from input
            // verified on TS level from input
            (_2) => this.versionSpecifics.mapNullableType(_2, isNullable),
            mapItem
          );
        }
        const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
        return Object.assign(Object.assign({}, schema), { default: defaultValue });
      }
      transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
        if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
          return this.versionSpecifics.mapNullableType(void 0, isNullable);
        }
        if (isZodType(zodSchema, "ZodString")) {
          return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
        }
        if (isZodType(zodSchema, "ZodNumber")) {
          return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_2) => this.versionSpecifics.getNumberChecks(_2));
        }
        if (isZodType(zodSchema, "ZodBigInt")) {
          return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
        }
        if (isZodType(zodSchema, "ZodBoolean")) {
          return this.versionSpecifics.mapNullableType("boolean", isNullable);
        }
        if (isZodType(zodSchema, "ZodLiteral")) {
          return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
        }
        if (isZodType(zodSchema, "ZodEnum")) {
          return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
        }
        if (isZodType(zodSchema, "ZodNativeEnum")) {
          return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
        }
        if (isZodType(zodSchema, "ZodArray")) {
          return this.arrayTransformer.transform(zodSchema, (_2) => this.versionSpecifics.mapNullableType(_2, isNullable), mapItem);
        }
        if (isZodType(zodSchema, "ZodTuple")) {
          return this.tupleTransformer.transform(zodSchema, (_2) => this.versionSpecifics.mapNullableType(_2, isNullable), mapItem);
        }
        if (isZodType(zodSchema, "ZodUnion")) {
          return this.unionTransformer.transform(zodSchema, (_2) => this.versionSpecifics.mapNullableOfArray(_2, isNullable), mapItem);
        }
        if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
          return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_2) => this.versionSpecifics.mapNullableOfArray(_2, isNullable), mapItem, generateSchemaRef);
        }
        if (isZodType(zodSchema, "ZodIntersection")) {
          return this.intersectionTransformer.transform(zodSchema, isNullable, (_2) => this.versionSpecifics.mapNullableOfArray(_2, isNullable), mapItem);
        }
        if (isZodType(zodSchema, "ZodRecord")) {
          return this.recordTransformer.transform(zodSchema, (_2) => this.versionSpecifics.mapNullableType(_2, isNullable), mapItem);
        }
        if (isZodType(zodSchema, "ZodDate")) {
          return this.versionSpecifics.mapNullableType("string", isNullable);
        }
        const refId = Metadata.getRefId(zodSchema);
        throw new UnknownZodTypeError({
          currentSchema: zodSchema._def,
          schemaName: refId
        });
      }
    };
    var OpenAPIGenerator = class {
      constructor(definitions, versionSpecifics) {
        this.definitions = definitions;
        this.versionSpecifics = versionSpecifics;
        this.schemaRefs = {};
        this.paramRefs = {};
        this.pathRefs = {};
        this.rawComponents = [];
        this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
        this.sortDefinitions();
      }
      generateDocumentData() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents(),
          paths: this.pathRefs
        };
      }
      generateComponents() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents()
        };
      }
      buildComponents() {
        var _a2, _b;
        const rawComponents = {};
        this.rawComponents.forEach(({ componentType, name, component }) => {
          var _a3;
          (_a3 = rawComponents[componentType]) !== null && _a3 !== void 0 ? _a3 : rawComponents[componentType] = {};
          rawComponents[componentType][name] = component;
        });
        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a2 = rawComponents.schemas) !== null && _a2 !== void 0 ? _a2 : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {}), this.paramRefs) });
      }
      sortDefinitions() {
        const generationOrder = [
          "schema",
          "parameter",
          "component",
          "route"
        ];
        this.definitions.sort((left, right) => {
          if (!("type" in left)) {
            if (!("type" in right)) {
              return 0;
            }
            return -1;
          }
          if (!("type" in right)) {
            return 1;
          }
          const leftIndex = generationOrder.findIndex((type) => type === left.type);
          const rightIndex = generationOrder.findIndex((type) => type === right.type);
          return leftIndex - rightIndex;
        });
      }
      generateSingle(definition) {
        if (!("type" in definition)) {
          this.generateSchemaWithRef(definition);
          return;
        }
        switch (definition.type) {
          case "parameter":
            this.generateParameterDefinition(definition.schema);
            return;
          case "schema":
            this.generateSchemaWithRef(definition.schema);
            return;
          case "route":
            this.generateSingleRoute(definition.route);
            return;
          case "component":
            this.rawComponents.push(definition);
            return;
        }
      }
      generateParameterDefinition(zodSchema) {
        const refId = Metadata.getRefId(zodSchema);
        const result = this.generateParameter(zodSchema);
        if (refId) {
          this.paramRefs[refId] = result;
        }
        return result;
      }
      getParameterRef(schemaMetadata, external) {
        var _a2, _b, _c, _d, _e;
        const parameterMetadata = (_a2 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
        const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId] : void 0;
        if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
          return void 0;
        }
        if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
          throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
            key: "in",
            values: compact([
              existingRef.in,
              external === null || external === void 0 ? void 0 : external.in,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
            ])
          });
        }
        if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
          throw new ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: compact([
              existingRef.name,
              external === null || external === void 0 ? void 0 : external.name,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
            ])
          });
        }
        return {
          $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`
        };
      }
      generateInlineParameters(zodSchema, location) {
        var _a2;
        const metadata = Metadata.getMetadata(zodSchema);
        const parameterMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
        const referencedSchema = this.getParameterRef(metadata, { in: location });
        if (referencedSchema) {
          return [referencedSchema];
        }
        if (isZodType(zodSchema, "ZodObject")) {
          const propTypes = zodSchema._def.shape();
          const parameters = Object.entries(propTypes).map(([key, schema]) => {
            var _a3, _b;
            const innerMetadata = Metadata.getMetadata(schema);
            const referencedSchema2 = this.getParameterRef(innerMetadata, {
              in: location,
              name: key
            });
            if (referencedSchema2) {
              return referencedSchema2;
            }
            const innerParameterMetadata = (_a3 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a3 === void 0 ? void 0 : _a3.param;
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
              throw new ConflictError(`Conflicting names for parameter`, {
                key: "name",
                values: [key, innerParameterMetadata.name]
              });
            }
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
              throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {
                key: "in",
                values: [location, innerParameterMetadata.in]
              });
            }
            return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
          });
          return parameters;
        }
        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
          throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
            key: "in",
            values: [location, parameterMetadata.in]
          });
        }
        return [
          this.generateParameter(zodSchema.openapi({ param: { in: location } }))
        ];
      }
      generateSimpleParameter(zodSchema) {
        var _a2;
        const metadata = Metadata.getParamMetadata(zodSchema);
        const paramMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
        const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
        const schema = this.generateSchemaWithRef(zodSchema);
        return Object.assign({
          schema,
          required
        }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
      }
      generateParameter(zodSchema) {
        var _a2;
        const metadata = Metadata.getMetadata(zodSchema);
        const paramMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
        if (!paramName) {
          throw new MissingParameterDataError({ missingField: "name" });
        }
        if (!paramLocation) {
          throw new MissingParameterDataError({
            missingField: "in",
            paramName
          });
        }
        const baseParameter = this.generateSimpleParameter(zodSchema);
        return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
      }
      generateSchemaWithMetadata(zodSchema) {
        var _a2;
        const innerSchema = Metadata.unwrapChained(zodSchema);
        const metadata = Metadata.getMetadata(zodSchema);
        const defaultValue = Metadata.getDefaultValue(zodSchema);
        const result = ((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata) ? Metadata.applySchemaMetadata(result, metadata.metadata) : omitBy(result, isNil);
      }
      /**
       * Same as above but applies nullable
       */
      constructReferencedOpenAPISchema(zodSchema) {
        var _a2;
        const metadata = Metadata.getMetadata(zodSchema);
        const innerSchema = Metadata.unwrapChained(zodSchema);
        const defaultValue = Metadata.getDefaultValue(zodSchema);
        const isNullableSchema = zodSchema.isNullable();
        if ((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) {
          return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);
        }
        return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
      }
      /**
       * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
       */
      generateSimpleSchema(zodSchema) {
        var _a2;
        const metadata = Metadata.getMetadata(zodSchema);
        const refId = Metadata.getRefId(zodSchema);
        if (!refId || !this.schemaRefs[refId]) {
          return this.generateSchemaWithMetadata(zodSchema);
        }
        const schemaRef = this.schemaRefs[refId];
        const referenceObject = {
          $ref: this.generateSchemaRef(refId)
        };
        const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a2 !== void 0 ? _a2 : {}), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
        if (newMetadata.type) {
          return {
            allOf: [referenceObject, newMetadata]
          };
        }
        const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
        const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
        if (Object.keys(appliedMetadata).length > 0) {
          return {
            allOf: [referenceObject, appliedMetadata]
          };
        }
        return referenceObject;
      }
      /**
       * Same as `generateSchema` but if the new schema is added into the
       * referenced schemas, it would return a ReferenceObject and not the
       * whole result.
       *
       * Should be used for nested objects, arrays, etc.
       */
      generateSchemaWithRef(zodSchema) {
        const refId = Metadata.getRefId(zodSchema);
        const result = this.generateSimpleSchema(zodSchema);
        if (refId && this.schemaRefs[refId] === void 0) {
          this.schemaRefs[refId] = result;
          return { $ref: this.generateSchemaRef(refId) };
        }
        return result;
      }
      generateSchemaRef(refId) {
        return `#/components/schemas/${refId}`;
      }
      getRequestBody(requestBody) {
        if (!requestBody) {
          return;
        }
        const { content } = requestBody, rest = __rest2(requestBody, ["content"]);
        const requestBodyContent = this.getBodyContent(content);
        return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
      }
      getParameters(request) {
        if (!request) {
          return [];
        }
        const { headers } = request;
        const query = this.cleanParameter(request.query);
        const params = this.cleanParameter(request.params);
        const cookies = this.cleanParameter(request.cookies);
        const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
        const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
        const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
        const headerParameters = enhanceMissingParametersError(() => {
          if (Array.isArray(headers)) {
            return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
          }
          const cleanHeaders = this.cleanParameter(headers);
          return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
        }, { location: "header" });
        return [
          ...pathParameters,
          ...queryParameters,
          ...headerParameters,
          ...cookieParameters
        ];
      }
      cleanParameter(schema) {
        if (!schema) {
          return void 0;
        }
        return isZodType(schema, "ZodEffects") ? this.cleanParameter(schema._def.schema) : schema;
      }
      generatePath(route) {
        const { method, path, request, responses } = route, pathItemConfig = __rest2(route, ["method", "path", "request", "responses"]);
        const generatedResponses = mapValues(responses, (response) => {
          return this.getResponse(response);
        });
        const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
        const routeDoc = {
          [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
            parameters: [...pathItemConfig.parameters || [], ...parameters]
          } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
        };
        return routeDoc;
      }
      generateSingleRoute(route) {
        const routeDoc = this.generatePath(route);
        this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
        return routeDoc;
      }
      getResponse(response) {
        if (this.isReferenceObject(response)) {
          return response;
        }
        const { content, headers } = response, rest = __rest2(response, ["content", "headers"]);
        const responseContent = content ? { content: this.getBodyContent(content) } : {};
        if (!headers) {
          return Object.assign(Object.assign({}, rest), responseContent);
        }
        const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
          // This is input data so it is okay to cast in the common generator
          // since this is the user's responsibility to keep it correct
          headers
        );
        return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
      }
      isReferenceObject(schema) {
        return "$ref" in schema;
      }
      getResponseHeaders(headers) {
        const schemaShape = headers._def.shape();
        const responseHeaders = mapValues(schemaShape, (_2) => this.generateSimpleParameter(_2));
        return responseHeaders;
      }
      getBodyContent(content) {
        return mapValues(content, (config) => {
          if (!config || !isAnyZodType(config.schema)) {
            return config;
          }
          const { schema: configSchema } = config, rest = __rest2(config, ["schema"]);
          const schema = this.generateSchemaWithRef(configSchema);
          return Object.assign({ schema }, rest);
        });
      }
      toOpenAPISchema(zodSchema, isNullable, defaultValue) {
        return this.openApiTransformer.transform(zodSchema, isNullable, (_2) => this.generateSchemaWithRef(_2), (_2) => this.generateSchemaRef(_2), defaultValue);
      }
    };
    var OpenApiGeneratorV30Specifics = class {
      get nullType() {
        return { nullable: true };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
      }
      mapTupleItems(schemas) {
        const uniqueSchemas = uniq(schemas);
        return {
          items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
          minItems: schemas.length,
          maxItems: schemas.length
        };
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check) => {
          switch (check.kind) {
            case "min":
              return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
            case "max":
              return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
            default:
              return {};
          }
        }));
      }
    };
    var OpenApiGeneratorV32 = class {
      constructor(definitions) {
        const specifics = new OpenApiGeneratorV30Specifics();
        this.generator = new OpenAPIGenerator(definitions, specifics);
      }
      generateDocument(config) {
        const baseData = this.generator.generateDocumentData();
        return Object.assign(Object.assign({}, config), baseData);
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
    };
    var OpenApiGeneratorV31Specifics = class {
      get nullType() {
        return { type: "null" };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        if (!type) {
          return {};
        }
        if (isNullable) {
          return {
            type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
          };
        }
        return {
          type
        };
      }
      mapTupleItems(schemas) {
        return {
          prefixItems: schemas
        };
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check) => {
          switch (check.kind) {
            case "min":
              return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
            case "max":
              return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
            default:
              return {};
          }
        }));
      }
    };
    function isWebhookDefinition(definition) {
      return "type" in definition && definition.type === "webhook";
    }
    var OpenApiGeneratorV312 = class {
      constructor(definitions) {
        this.definitions = definitions;
        this.webhookRefs = {};
        const specifics = new OpenApiGeneratorV31Specifics();
        this.generator = new OpenAPIGenerator(this.definitions, specifics);
      }
      generateDocument(config) {
        const baseDocument = this.generator.generateDocumentData();
        this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
        return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
      generateSingleWebhook(route) {
        const routeDoc = this.generator.generatePath(route);
        this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
        return routeDoc;
      }
    };
    exports.OpenAPIRegistry = OpenAPIRegistry2;
    exports.OpenApiGeneratorV3 = OpenApiGeneratorV32;
    exports.OpenApiGeneratorV31 = OpenApiGeneratorV312;
    exports.extendZodWithOpenApi = extendZodWithOpenApi2;
    exports.getOpenApiMetadata = getOpenApiMetadata;
  }
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/pino-std-serializers/lib/err-helpers.js"(exports, module) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/pino-std-serializers/lib/err-proto.js"(exports, module) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val2) {
          this[rawSymbol] = val2;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/pino-std-serializers/lib/err.js"(exports, module) {
    "use strict";
    module.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val2 = err[key];
          if (isErrorLike(val2)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val2, seen)) {
              _err[key] = errSerializer(val2);
            }
          } else {
            _err[key] = val2;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/pino-std-serializers/lib/err-with-cause.js"(exports, module) {
    "use strict";
    module.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val2 = err[key];
          if (isErrorLike(val2)) {
            if (!Object.prototype.hasOwnProperty.call(val2, seen)) {
              _err[key] = errWithCauseSerializer(val2);
            }
          } else {
            _err[key] = val2;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/pino-std-serializers/lib/req.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val2) {
          this[rawSymbol] = val2;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/pino-std-serializers/lib/res.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val2) {
          this[rawSymbol] = val2;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/pino-std-serializers/index.js"(exports, module) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/pino/lib/caller.js"(exports, module) {
    "use strict";
    function noOpPrepareStackTrace(_2, stack) {
      return stack;
    }
    module.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "node_modules/fast-redact/lib/validator.js"(exports, module) {
    "use strict";
    module.exports = validator2;
    function validator2(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s3) => `fast-redact \u2013 Invalid path (${s3})`
      } = opts;
      return function validate3({ paths }) {
        paths.forEach((s3) => {
          if (typeof s3 !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (//.test(s3)) throw Error();
            const expr = (s3[0] === "[" ? "" : ".") + s3.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e3) {
            throw Error(ERR_INVALID_PATH(s3));
          }
        });
      };
    }
  }
});

// node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "node_modules/fast-redact/lib/rx.js"(exports, module) {
    "use strict";
    module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS({
  "node_modules/fast-redact/lib/parse.js"(exports, module) {
    "use strict";
    var rx = require_rx();
    module.exports = parse4;
    function parse4({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o3, strPath, ix) {
        var path = strPath.match(rx).map((p3) => p3.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p3) => {
          if (p3[0] === "[") return p3.substr(1, p3.length - 2);
          else return p3;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o3[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o3;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "node_modules/fast-redact/lib/redactor.js"(exports, module) {
    "use strict";
    var rx = require_rx();
    module.exports = redactor;
    function redactor({ secret, serialize: serialize2, wcLen, strict, isCensorFct, censorFctTakesPath }, state2) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize2)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize2)}
  `).bind(state2);
      redact.state = state2;
      if (serialize2 === false) {
        redact.restore = (o3) => state2.restore(o3);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p3) => `o${delim}${p3}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path} != null`;
        else existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p3) => `
          case o${delim}${p3} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p3)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize2) {
      return serialize2 === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize2) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize2 === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/fast-redact/lib/modifiers.js"(exports, module) {
    "use strict";
    module.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length = keys.length;
      for (var i3 = 0; i3 < length; i3++) {
        const k3 = keys[i3];
        target[k3] = values[i3];
      }
    }
    function groupRedact(o3, path, censor, isCensorFct, censorFctTakesPath) {
      const target = get2(o3, path);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [...path] : void 0;
      const values = new Array(keysLength);
      for (var i3 = 0; i3 < keysLength; i3++) {
        const key = keys[i3];
        values[i3] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i3 = 0; i3 < instructions.length; i3++) {
        const { target, path, value } = instructions[i3];
        let current = target;
        for (let i4 = path.length - 1; i4 > 0; i4--) {
          current = current[path[i4]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o3, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get2(o3, path);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i3 = 0; i3 < keysLength; i3++) {
        const key = keys[i3];
        specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o3, k3, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k3;
      var i3 = -1;
      var n3;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n3 = o3[k3];
      if (typeof n3 !== "object") return;
      while (n3 != null && ++i3 < afterPathLen) {
        depth += 1;
        k3 = afterPath[i3];
        oov = ov;
        if (k3 !== "*" && !wc && !(typeof n3 === "object" && k3 in n3)) {
          break;
        }
        if (k3 === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k3;
          if (i3 !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n3);
          for (var j3 = 0; j3 < wcKeys.length; j3++) {
            const wck = wcKeys[j3];
            wcov = n3[wck];
            kIsWc = k3 === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i3;
              ov = iterateNthLevel(wcov, level - 1, k3, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i3, lastPathIndex, redactPathCurrent, store, o3[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k3 in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k3];
                }
                nv = i3 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o3[originalKey]);
                  store.push(rv);
                  n3[wck] = nv;
                } else {
                  if (wcov[k3] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k3) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k3, depth + 1), ov, o3[originalKey]);
                    store.push(rv);
                    wcov[k3] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n3[k3];
          redactPathCurrent = node(redactPathCurrent, k3, depth);
          nv = i3 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n3, k3) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o3[originalKey]);
            store.push(rv);
            n3[k3] = nv;
          }
          n3 = n3[k3];
        }
        if (typeof n3 !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get2(o3, p3) {
      var i3 = -1;
      var l3 = p3.length;
      var n3 = o3;
      while (n3 != null && ++i3 < l3) {
        n3 = n3[p3[i3]];
      }
      return n3;
    }
    function iterateNthLevel(wcov, level, k3, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i3, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k3 in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k3];
          }
          nv = i3 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n3[wck] = nv;
          } else {
            if (wcov[k3] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k3) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k3, depth + 1), ov, parent);
              store.push(rv);
              wcov[k3] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k3, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i3, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path, value, target };
    }
  }
});

// node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "node_modules/fast-redact/lib/restorer.js"(exports, module) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state2 = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state2);
        this.restore.state = state2;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "node_modules/fast-redact/lib/state.js"(exports, module) {
    "use strict";
    module.exports = state2;
    function state2(o3) {
      const {
        secret,
        censor,
        compileRestore,
        serialize: serialize2,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o3;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize2 !== false) builder.push({ serialize: serialize2 });
      if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "node_modules/fast-redact/index.js"(exports, module) {
    "use strict";
    var validator2 = require_validator();
    var parse4 = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state2 = require_state();
    var rx = require_rx();
    var validate3 = validator2();
    var noop = (o3) => o3;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator2;
    module.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize2 = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize2 !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize2 || noop;
      validate3({ paths, serialize: serialize2, censor });
      const { wildcards, wcLen, secret } = parse4({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize: serialize2, strict, isCensorFct, censorFctTakesPath }, state2({
        secret,
        censor,
        compileRestore,
        serialize: serialize2,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// node_modules/pino/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/pino/lib/symbols.js"(exports, module) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/pino/lib/redaction.js"(exports, module) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols();
    var { rx, validator: validator2 } = fastRedact;
    var validate3 = validator2({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s3) => `pino \u2013 redact paths array contains an invalid path (${s3})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize2) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o3, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o3[ns] = null;
          return o3;
        }
        if (o3[ns] === null) {
          return o3;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o3[ns] = o3[ns] || [];
        if (ns !== wildcardFirstSym && o3[ns].length === 0) {
          o3[ns].push(...o3[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o3).forEach(function(k3) {
            if (o3[k3]) {
              o3[k3].push(nextPath);
            }
          });
        }
        o3[ns].push(nextPath);
        return o3;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize: serialize2, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize2(censor(...args)) : serialize2(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o3, k3) => {
        if (shape[k3] === null) {
          o3[k3] = (value) => topCensor(value, [k3]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k3, ...path]);
          } : censor;
          o3[k3] = fastRedact({
            paths: shape[k3],
            censor: wrappedCensor,
            serialize: serialize2,
            strict
          });
        }
        return o3;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate3(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate3({ paths, censor });
      return { paths, censor };
    }
    module.exports = redaction;
  }
});

// node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/pino/lib/time.js"(exports, module) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o3) {
      try {
        return JSON.stringify(o3);
      } catch (e3) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f3, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1) return f3;
        var objects = new Array(len);
        objects[0] = ss(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0) return f3;
      var str = "";
      var a3 = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i3 = 0; i3 < flen; ) {
        if (f3.charCodeAt(i3) === 37 && i3 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i3 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += Number(args[a3]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += Math.floor(Number(args[a3]));
              lastPos = i3 + 2;
              i3++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0) break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              var type = typeof args[a3];
              if (type === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i3 + 2;
                i3++;
                break;
              }
              if (type === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i3 + 2;
                i3++;
                break;
              }
              str += ss(args[a3]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += String(args[a3]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 37:
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += "%";
              lastPos = i3 + 2;
              i3++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i3;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/atomic-sleep/index.js"(exports, module) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module.exports = sleep;
    }
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/sonic-boom/index.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var EventEmitter = __require("events");
    var inherits = __require("util").inherits;
    var path = __require("path");
    var sleep = require_atomic_sleep();
    var assert = __require("assert");
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
    var kCopyBuffer = major >= 22 && minor >= 7;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs.mkdirSync(path.dirname(file), { recursive: true });
          const fd = fs.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs.open(file, flags, mode, fileOpened);
        });
      } else {
        fs.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this._periodicFlush = periodicFlush || 0;
      this._periodicFlushTimer = void 0;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n3) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n3);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n3);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n4 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n4);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
      if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
      }
    }
    function releaseWritingBuf(writingBuf, len, n3) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n3) {
        n3 = Buffer.from(writingBuf).subarray(0, n3).toString().length;
      }
      len = Math.max(len - n3, 0);
      writingBuf = writingBuf.slice(n3);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          try {
            fs.fsync(this.fd, (err) => {
              this._flushPending = false;
              cb(err);
            });
          } catch (err) {
            cb(err);
          }
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n3 = fs.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n3);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n3 = fs.writeSync(this.fd, buf);
          buf = buf.subarray(n3);
          this._len = Math.max(this._len - n3, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        if (kCopyBuffer) {
          this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      if (sonic._periodicFlushTimer !== void 0) {
        clearInterval(sonic._periodicFlushTimer);
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
      try {
        fs.fsync(sonic.fd, closeWrapped);
      } catch {
      }
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module.exports = SonicBoom;
  }
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/on-exit-leak-free/index.js"(exports, module) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/thread-stream/package.json
var require_package = __commonJS({
  "node_modules/thread-stream/package.json"(exports, module) {
    module.exports = {
      name: "thread-stream",
      version: "3.1.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^4.0.1",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        build: "tsc --noEmit",
        test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*",
          "test/syntax-error.mjs"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "node_modules/thread-stream/lib/wait.js"(exports, module) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state2, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state2, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state2, index);
            if (current === prior) {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check(1);
    }
    function waitDiff(state2, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state2, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state2, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check(1);
    }
    module.exports = { wait, waitDiff };
  }
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/thread-stream/lib/indexes.js"(exports, module) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/thread-stream/index.js"(exports, module) {
    "use strict";
    var { version: version3 } = require_package();
    var { EventEmitter } = __require("events");
    var { Worker } = __require("worker_threads");
    var { join } = __require("path");
    var { pathToFileURL } = __require("url");
    var { wait } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = __require("buffer");
    var assert = __require("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream2, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream2[kImpl].dataBuf,
          stateBuf: stream2[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version3
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream2);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream2, worker);
      return worker;
    }
    function drain(stream2) {
      assert(!stream2[kImpl].sync);
      if (stream2[kImpl].needDrain) {
        stream2[kImpl].needDrain = false;
        stream2.emit("drain");
      }
    }
    function nextFlush(stream2) {
      const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      let leftover = stream2[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream2[kImpl].buf.length === 0) {
          stream2[kImpl].flushing = false;
          if (stream2[kImpl].ending) {
            end(stream2);
          } else if (stream2[kImpl].needDrain) {
            process.nextTick(drain, stream2);
          }
          return;
        }
        let toWrite = stream2[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, nextFlush.bind(null, stream2));
        } else {
          stream2.flush(() => {
            if (stream2.destroyed) {
              return;
            }
            Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream2[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream2[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
            write(stream2, toWrite, nextFlush.bind(null, stream2));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream2[kImpl].buf.length === 0) {
          return;
        }
        stream2.flush(() => {
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream2);
        });
      } else {
        destroy(stream2, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream2 = this.stream.deref();
      if (stream2 === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream2);
          stream2.flush(() => {
            stream2[kImpl].ready = true;
            stream2.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream2, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream2.emit(msg.name, ...msg.args);
          } else {
            stream2.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream2, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream2 = this.stream.deref();
      if (stream2 === void 0) {
        return;
      }
      registry.unregister(stream2);
      stream2.worker.exited = true;
      stream2.worker.off("exit", onWorkerExit);
      destroy(stream2, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream2, err) {
      setImmediate(() => {
        stream2.emit("error", err);
      });
    }
    function destroy(stream2, err) {
      if (stream2[kImpl].destroyed) {
        return;
      }
      stream2[kImpl].destroyed = true;
      if (err) {
        stream2[kImpl].errored = err;
        error(stream2, err);
      }
      if (!stream2.worker.exited) {
        stream2.worker.terminate().catch(() => {
        }).then(() => {
          stream2[kImpl].closed = true;
          stream2.emit("close");
        });
      } else {
        setImmediate(() => {
          stream2[kImpl].closed = true;
          stream2.emit("close");
        });
      }
    }
    function write(stream2, data, cb) {
      const current = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data);
      stream2[kImpl].data.write(data, current);
      Atomics.store(stream2[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream2) {
      if (stream2[kImpl].ended || !stream2[kImpl].ending || stream2[kImpl].flushing) {
        return;
      }
      stream2[kImpl].ended = true;
      try {
        stream2.flushSync();
        let readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream2, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream2, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream2[kImpl].finished = true;
          stream2.emit("finish");
        });
      } catch (err) {
        destroy(stream2, err);
      }
    }
    function writeSync(stream2) {
      const cb = () => {
        if (stream2[kImpl].ending) {
          end(stream2);
        } else if (stream2[kImpl].needDrain) {
          process.nextTick(drain, stream2);
        }
      };
      stream2[kImpl].flushing = false;
      while (stream2[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
        let leftover = stream2[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream2);
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream2[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, cb);
        } else {
          flushSync(stream2);
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream2[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream2[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, cb);
        }
      }
    }
    function flushSync(stream2) {
      if (stream2[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module.exports = ThreadStream;
  }
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/pino/lib/transport.js"(exports, module) {
    "use strict";
    var { createRequire } = __require("module");
    var getCallers = require_caller();
    var { join, isAbsolute, sep } = __require("node:path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream2) {
      onExit.register(stream2, autoEnd);
      onExit.registerBeforeExit(stream2, flush);
      stream2.on("close", function() {
        onExit.unregister(stream2);
      });
    }
    function buildStream(filename, workerData, workerOpts, sync) {
      const stream2 = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
      });
      stream2.on("ready", onReady);
      stream2.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream2.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream2);
        }
      }
      function onExit2() {
        if (stream2.closed) {
          return;
        }
        stream2.flushSync();
        sleep(100);
        stream2.end();
      }
      return stream2;
    }
    function autoEnd(stream2) {
      stream2.ref();
      stream2.flushSync();
      stream2.end();
      stream2.once("close", function() {
        stream2.unref();
      });
    }
    function flush(stream2) {
      stream2.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
      const options = {
        ...fullOptions.options
      };
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.targets = targets.filter((dest) => dest.target).map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
        options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
          return dest.pipeline.map((t3) => {
            return {
              ...t3,
              level: dest.level,
              // duplicate the pipeline `level` property defined in the upper level
              target: fixTarget(t3.target)
            };
          });
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.pipelines = [pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        })];
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker, sync);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module.exports = transport;
  }
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/pino/lib/tools.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols();
    var { isMainThread } = __require("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o3, ...n3) {
        if (typeof o3 === "object") {
          let msg = o3;
          if (o3 !== null) {
            if (o3.method && o3.headers && o3.socket) {
              o3 = mapHttpRequest(o3);
            } else if (typeof o3.setHeader === "function") {
              o3 = mapHttpResponse(o3);
            }
          }
          let formatParams;
          if (msg === null && n3.length === 0) {
            formatParams = [null];
          } else {
            msg = n3.shift();
            formatParams = n3;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o3, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o3 === void 0 ? n3.shift() : o3;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n3, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l3 = str.length;
      if (l3 > 100) {
        return JSON.stringify(str);
      }
      for (var i3 = 0; i3 < l3 && point >= 32; i3++) {
        point = str.charCodeAt(i3);
        if (point === 34 || point === 92) {
          result += str.slice(last, i3) + "\\";
          last = i3;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify4 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify4)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify4)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify4 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify4)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream2) {
      return stream2.write !== stream2.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream2 = new SonicBoom(opts);
      stream2.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream2, autoEnd);
        stream2.on("close", function() {
          onExit.unregister(stream2);
        });
      }
      return stream2;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream2.write = noop;
          stream2.end = noop;
          stream2.flushSync = noop;
          stream2.destroy = noop;
          return;
        }
        stream2.removeListener("error", filterBrokenPipe);
        stream2.emit("error", err);
      }
    }
    function autoEnd(stream2, eventName) {
      if (stream2.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream2.flush();
        stream2.on("drain", function() {
          stream2.end();
        });
      } else {
        stream2.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, caller, opts = {}, stream2) {
        if (typeof opts === "string") {
          stream2 = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream2 === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream2 = buildSafeSonicBoom({ dest: stream2 });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream2 = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream2 = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream2) {
          if (!hasBeenTampered(process.stdout)) {
            stream2 = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream2 = process.stdout;
          }
        }
        return { opts, stream: stream2 };
      };
    }
    function stringify3(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_2) {
        try {
          const stringify4 = stringifySafeFn || this[stringifySafeSym];
          return stringify4(obj);
        } catch (_3) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify: stringify3,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pino/lib/constants.js"(exports, module) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/pino/lib/levels.js"(exports, module) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream2 = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream2.flushSync === "function") {
            try {
              stream2.flushSync();
            } catch (e3) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o3, k3) => {
      o3[DEFAULT_LEVELS[k3]] = k3;
      return o3;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o3, k3) => {
      o3[k3] = '{"level":' + Number(k3);
      return o3;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache3 = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache3[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache3;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o3, k3) => {
        o3[customLevels[k3]] = k3;
        return o3;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k3 in customLevels) {
        if (k3 in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k3] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/pino/lib/meta.js"(exports, module) {
    "use strict";
    module.exports = { version: "9.6.0" };
  }
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/pino/lib/proto.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require("node:events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym,
      hooksSym
    } = require_symbols();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify: stringify3
    } = require_tools();
    var {
      version: version3
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version3,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n3) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k3 in serializers) {
          instance[serializersSym][k3] = serializers[k3];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i3 = 0; i3 < parentSymbols.length; i3++) {
          const ks = parentSymbols[i3];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify3);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify3;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t3 = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      const streamWriteHook = this[hooksSym].streamWrite;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s3 = this[asJsonSym](obj, msg, num, t3);
      const stream2 = this[streamSym];
      if (stream2[needsMetadataGsym] === true) {
        stream2.lastLevel = num;
        stream2.lastObj = obj;
        stream2.lastMsg = msg;
        stream2.lastTime = t3.slice(this[timeSliceIndexSym]);
        stream2.lastLogger = this;
      }
      stream2.write(streamWriteHook ? streamWriteHook(s3) : s3);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream2 = this[streamSym];
      if (typeof stream2.flush === "function") {
        stream2.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports, module) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify3 = configure();
    stringify3.configure = configure;
    stringify3.stringify = stringify3;
    stringify3.default = stringify3;
    exports.stringify = stringify3;
    exports.configure = configure;
    module.exports = stringify3;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i3 = 1; i3 < array.length; i3++) {
        const currentValue = array[i3];
        let position = i3;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i3 = 1; i3 < maximumBreadth; i3++) {
        res += `${separator}"${i3}":${whitespace}${array[i3]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i3 = 0;
              for (; i3 < maximumValuesToStringify - 1; i3++) {
                const tmp2 = stringifyFnReplacer(String(i3), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i3), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i3 = 0; i3 < maximumPropertiesToStringify; i3++) {
              const key2 = keys[i3];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i3 = 0;
              for (; i3 < maximumValuesToStringify - 1; i3++) {
                const tmp2 = stringifyArrayReplacer(String(i3), value[i3], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i3), value[i3], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i3 = 0;
              for (; i3 < maximumValuesToStringify - 1; i3++) {
                const tmp2 = stringifyIndent(String(i3), value[i3], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i3), value[i3], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i3 = 0; i3 < maximumPropertiesToStringify; i3++) {
              const key2 = keys[i3];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i3 = 0;
              for (; i3 < maximumValuesToStringify - 1; i3++) {
                const tmp2 = stringifySimple(String(i3), value[i3], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i3), value[i3], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i3 = 0; i3 < maximumPropertiesToStringify; i3++) {
              const key2 = keys[i3];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify4(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify4;
    }
  }
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/pino/lib/multistream.js"(exports, module) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i3) => {
          streamLevels[i3] = opts.levels[i3];
        });
      }
      const res = {
        write,
        add,
        emit,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream2;
        for (let i3 = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i3, streams.length, opts.dedupe); i3 = adjustLoopVar(i3, opts.dedupe)) {
          dest = streams[i3];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream2 = dest.stream;
            if (stream2[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream2.lastLevel = level;
              stream2.lastTime = lastTime;
              stream2.lastMsg = lastMsg;
              stream2.lastObj = lastObj;
              stream2.lastLogger = lastLogger;
            }
            stream2.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit(...args) {
        for (const { stream: stream2 } of this.streams) {
          if (typeof stream2.emit === "function") {
            stream2.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream: stream2 } of this.streams) {
          if (typeof stream2.flushSync === "function") {
            stream2.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream: stream2 } of this.streams) {
          if (typeof stream2.flushSync === "function") {
            stream2.flushSync();
          }
          stream2.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i3 = 0; i3 < streams.length; i3++) {
          streams[i3] = {
            level,
            stream: this.streams[i3].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone,
          emit,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a3, b3) {
      return a3.level - b3.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i3, dedupe) {
      return dedupe ? i3 - 1 : i3 + 1;
    }
    function checkLoopVar(i3, length, dedupe) {
      return dedupe ? i3 >= 0 : i3 < length;
    }
    module.exports = multistream;
  }
});

// node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/pino/pino.js"(exports, module) {
    "use strict";
    var os = __require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify: stringify3,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version: version3 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0,
        streamWrite: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino2(...args) {
      const instance = {};
      const { opts, stream: stream2 } = normalize(instance, caller(), ...args);
      if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify3.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify3,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream2.emit === "function") {
        stream2.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream2,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify3,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module.exports = pino2;
    module.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module.exports.transport = require_transport();
    module.exports.multistream = require_multistream();
    module.exports.levels = mappings();
    module.exports.stdSerializers = serializers;
    module.exports.stdTimeFunctions = Object.assign({}, time);
    module.exports.symbols = symbols;
    module.exports.version = version3;
    module.exports.default = pino2;
    module.exports.pino = pino2;
  }
});

// node_modules/colorette/index.cjs
var require_colorette = __commonJS({
  "node_modules/colorette/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tty = __require("tty");
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule) return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      if (e3) {
        Object.keys(e3).forEach(function(k3) {
          if (k3 !== "default") {
            var d3 = Object.getOwnPropertyDescriptor(e3, k3);
            Object.defineProperty(n3, k3, d3.get ? d3 : {
              enumerable: true,
              get: function() {
                return e3[k3];
              }
            });
          }
        });
      }
      n3["default"] = e3;
      return Object.freeze(n3);
    }
    var tty__namespace = /* @__PURE__ */ _interopNamespace(tty);
    var {
      env = {},
      argv = [],
      platform = ""
    } = typeof process === "undefined" ? {} : process;
    var isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
    var isForced = "FORCE_COLOR" in env || argv.includes("--color");
    var isWindows = platform === "win32";
    var isDumbTerminal = env.TERM === "dumb";
    var isCompatibleTerminal = tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;
    var isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
    var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
    var replaceClose = (index, string, close, replace, head = string.substring(0, index) + replace, tail = string.substring(index + close.length), next = tail.indexOf(close)) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
    var clearBleed = (index, string, open, close, replace) => index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
    var filterEmpty = (open, close, replace = open, at = open.length + 1) => (string) => string || !(string === "" || string === void 0) ? clearBleed(
      ("" + string).indexOf(close, at),
      string,
      open,
      close,
      replace
    ) : "";
    var init = (open, close, replace) => filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
    var colors = {
      reset: init(0, 0),
      bold: init(1, 22, "\x1B[22m\x1B[1m"),
      dim: init(2, 22, "\x1B[22m\x1B[2m"),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49),
      blackBright: init(90, 39),
      redBright: init(91, 39),
      greenBright: init(92, 39),
      yellowBright: init(93, 39),
      blueBright: init(94, 39),
      magentaBright: init(95, 39),
      cyanBright: init(96, 39),
      whiteBright: init(97, 39),
      bgBlackBright: init(100, 49),
      bgRedBright: init(101, 49),
      bgGreenBright: init(102, 49),
      bgYellowBright: init(103, 49),
      bgBlueBright: init(104, 49),
      bgMagentaBright: init(105, 49),
      bgCyanBright: init(106, 49),
      bgWhiteBright: init(107, 49)
    };
    var createColors = ({ useColor = isColorSupported } = {}) => useColor ? colors : Object.keys(colors).reduce(
      (colors2, key) => ({ ...colors2, [key]: String }),
      {}
    );
    var {
      reset,
      bold,
      dim,
      italic,
      underline,
      inverse,
      hidden,
      strikethrough,
      black,
      red,
      green,
      yellow,
      blue,
      magenta,
      cyan,
      white,
      gray,
      bgBlack,
      bgRed,
      bgGreen,
      bgYellow,
      bgBlue,
      bgMagenta,
      bgCyan,
      bgWhite,
      blackBright,
      redBright,
      greenBright,
      yellowBright,
      blueBright,
      magentaBright,
      cyanBright,
      whiteBright,
      bgBlackBright,
      bgRedBright,
      bgGreenBright,
      bgYellowBright,
      bgBlueBright,
      bgMagentaBright,
      bgCyanBright,
      bgWhiteBright
    } = createColors();
    exports.bgBlack = bgBlack;
    exports.bgBlackBright = bgBlackBright;
    exports.bgBlue = bgBlue;
    exports.bgBlueBright = bgBlueBright;
    exports.bgCyan = bgCyan;
    exports.bgCyanBright = bgCyanBright;
    exports.bgGreen = bgGreen;
    exports.bgGreenBright = bgGreenBright;
    exports.bgMagenta = bgMagenta;
    exports.bgMagentaBright = bgMagentaBright;
    exports.bgRed = bgRed;
    exports.bgRedBright = bgRedBright;
    exports.bgWhite = bgWhite;
    exports.bgWhiteBright = bgWhiteBright;
    exports.bgYellow = bgYellow;
    exports.bgYellowBright = bgYellowBright;
    exports.black = black;
    exports.blackBright = blackBright;
    exports.blue = blue;
    exports.blueBright = blueBright;
    exports.bold = bold;
    exports.createColors = createColors;
    exports.cyan = cyan;
    exports.cyanBright = cyanBright;
    exports.dim = dim;
    exports.gray = gray;
    exports.green = green;
    exports.greenBright = greenBright;
    exports.hidden = hidden;
    exports.inverse = inverse;
    exports.isColorSupported = isColorSupported;
    exports.italic = italic;
    exports.magenta = magenta;
    exports.magentaBright = magentaBright;
    exports.red = red;
    exports.redBright = redBright;
    exports.reset = reset;
    exports.strikethrough = strikethrough;
    exports.underline = underline;
    exports.white = white;
    exports.whiteBright = whiteBright;
    exports.yellow = yellow;
    exports.yellowBright = yellowBright;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k3) {
        wrapper[k3] = fn[k3];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i3 = 0; i3 < args.length; i3++) {
          args[i3] = arguments[i3];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k3) {
            ret[k3] = cb2[k3];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f3 = function() {
        if (f3.called) return f3.value;
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      f3.called = false;
      return f3;
    }
    function onceStrict(fn) {
      var f3 = function() {
        if (f3.called)
          throw new Error(f3.onceError);
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f3.onceError = name + " shouldn't be called more than once";
      f3.called = false;
      return f3;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    };
    var isChildProcess = function(stream2) {
      return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
    };
    var eos = function(stream2, opts, callback) {
      if (typeof opts === "function") return eos(stream2, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var ws = stream2._writableState;
      var rs = stream2._readableState;
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream2.writable) onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream2);
      };
      var onend = function() {
        readable = false;
        if (!writable) callback.call(stream2);
      };
      var onexit = function(exitCode) {
        callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream2, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream2, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream2, new Error("premature close"));
      };
      var onrequest = function() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req) onrequest();
        else stream2.on("request", onrequest);
      } else if (writable && !ws) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream2)) stream2.on("exit", onexit);
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false) stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        cancelled = true;
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req) stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("exit", onexit);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs;
    try {
      fs = __require("fs");
    } catch (e3) {
    }
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream2) {
      if (!ancient) return false;
      if (!fs) return false;
      return (stream2 instanceof (fs.ReadStream || noop) || stream2 instanceof (fs.WriteStream || noop)) && isFn(stream2.close);
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && isFn(stream2.abort);
    };
    var destroyer = function(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      eos(stream2, { readable: reading, writable: writing }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream2)) return stream2.close(noop);
        if (isRequest(stream2)) return stream2.abort();
        if (isFn(stream2.destroy)) return stream2.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream2, i3) {
        var reading = i3 < streams.length - 1;
        var writing = i3 > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump;
  }
});

// node_modules/split2/index.js
var require_split2 = __commonJS({
  "node_modules/split2/index.js"(exports, module) {
    "use strict";
    var { Transform } = __require("stream");
    var { StringDecoder } = __require("string_decoder");
    var kLast = Symbol("last");
    var kDecoder = Symbol("decoder");
    function transform(chunk, enc, cb) {
      let list;
      if (this.overflow) {
        const buf = this[kDecoder].write(chunk);
        list = buf.split(this.matcher);
        if (list.length === 1) return cb();
        list.shift();
        this.overflow = false;
      } else {
        this[kLast] += this[kDecoder].write(chunk);
        list = this[kLast].split(this.matcher);
      }
      this[kLast] = list.pop();
      for (let i3 = 0; i3 < list.length; i3++) {
        try {
          push(this, this.mapper(list[i3]));
        } catch (error) {
          return cb(error);
        }
      }
      this.overflow = this[kLast].length > this.maxLength;
      if (this.overflow && !this.skipOverflow) {
        cb(new Error("maximum buffer reached"));
        return;
      }
      cb();
    }
    function flush(cb) {
      this[kLast] += this[kDecoder].end();
      if (this[kLast]) {
        try {
          push(this, this.mapper(this[kLast]));
        } catch (error) {
          return cb(error);
        }
      }
      cb();
    }
    function push(self2, val2) {
      if (val2 !== void 0) {
        self2.push(val2);
      }
    }
    function noop(incoming) {
      return incoming;
    }
    function split(matcher, mapper, options) {
      matcher = matcher || /\r?\n/;
      mapper = mapper || noop;
      options = options || {};
      switch (arguments.length) {
        case 1:
          if (typeof matcher === "function") {
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
            options = matcher;
            matcher = /\r?\n/;
          }
          break;
        case 2:
          if (typeof matcher === "function") {
            options = mapper;
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof mapper === "object") {
            options = mapper;
            mapper = noop;
          }
      }
      options = Object.assign({}, options);
      options.autoDestroy = true;
      options.transform = transform;
      options.flush = flush;
      options.readableObjectMode = true;
      const stream2 = new Transform(options);
      stream2[kLast] = "";
      stream2[kDecoder] = new StringDecoder("utf8");
      stream2.matcher = matcher;
      stream2.mapper = mapper;
      stream2.maxLength = options.maxLength;
      stream2.skipOverflow = options.skipOverflow || false;
      stream2.overflow = false;
      stream2._destroy = function(err, cb) {
        this._writableState.errorEmitted = false;
        cb(err);
      };
      return stream2;
    }
    module.exports = split;
  }
});

// node_modules/pino-abstract-transport/index.js
var require_pino_abstract_transport = __commonJS({
  "node_modules/pino-abstract-transport/index.js"(exports, module) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var split = require_split2();
    var { Duplex } = __require("stream");
    var { parentPort, workerData } = __require("worker_threads");
    function createDeferred() {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve;
      promise.reject = reject;
      return promise;
    }
    module.exports = function build(fn, opts = {}) {
      const waitForConfig = opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig === true;
      const parseLines = opts.parse === "lines";
      const parseLine = typeof opts.parseLine === "function" ? opts.parseLine : JSON.parse;
      const close = opts.close || defaultClose;
      const stream2 = split(function(line) {
        let value;
        try {
          value = parseLine(line);
        } catch (error) {
          this.emit("unknown", line, error);
          return;
        }
        if (value === null) {
          this.emit("unknown", line, "Null value ignored");
          return;
        }
        if (typeof value !== "object") {
          value = {
            data: value,
            time: Date.now()
          };
        }
        if (stream2[metadata]) {
          stream2.lastTime = value.time;
          stream2.lastLevel = value.level;
          stream2.lastObj = value;
        }
        if (parseLines) {
          return line;
        }
        return value;
      }, { autoDestroy: true });
      stream2._destroy = function(err, cb) {
        const promise = close(err, cb);
        if (promise && typeof promise.then === "function") {
          promise.then(cb, cb);
        }
      };
      if (opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig !== true) {
        setImmediate(() => {
          stream2.emit("error", new Error("This transport is not compatible with the current version of pino. Please upgrade pino to the latest version."));
        });
      }
      if (opts.metadata !== false) {
        stream2[metadata] = true;
        stream2.lastTime = 0;
        stream2.lastLevel = 0;
        stream2.lastObj = null;
      }
      if (waitForConfig) {
        let pinoConfig = {};
        const configReceived = createDeferred();
        parentPort.on("message", function handleMessage(message) {
          if (message.code === "PINO_CONFIG") {
            pinoConfig = message.config;
            configReceived.resolve();
            parentPort.off("message", handleMessage);
          }
        });
        Object.defineProperties(stream2, {
          levels: {
            get() {
              return pinoConfig.levels;
            }
          },
          messageKey: {
            get() {
              return pinoConfig.messageKey;
            }
          },
          errorKey: {
            get() {
              return pinoConfig.errorKey;
            }
          }
        });
        return configReceived.then(finish);
      }
      return finish();
      function finish() {
        let res = fn(stream2);
        if (res && typeof res.catch === "function") {
          res.catch((err) => {
            stream2.destroy(err);
          });
          res = null;
        } else if (opts.enablePipelining && res) {
          return Duplex.from({ writable: stream2, readable: res });
        }
        return stream2;
      }
    };
    function defaultClose(err, cb) {
      process.nextTick(cb, err);
    }
  }
});

// node_modules/pino-pretty/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pino-pretty/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      DATE_FORMAT: "yyyy-mm-dd HH:MM:ss.l o",
      DATE_FORMAT_SIMPLE: "HH:MM:ss.l",
      /**
       * @type {K_ERROR_LIKE_KEYS}
       */
      ERROR_LIKE_KEYS: ["err", "error"],
      MESSAGE_KEY: "msg",
      LEVEL_KEY: "level",
      LEVEL_LABEL: "levelLabel",
      TIMESTAMP_KEY: "time",
      LEVELS: {
        default: "USERLVL",
        60: "FATAL",
        50: "ERROR",
        40: "WARN",
        30: "INFO",
        20: "DEBUG",
        10: "TRACE"
      },
      LEVEL_NAMES: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      // Object keys that probably came from a logger like Pino or Bunyan.
      LOGGER_KEYS: [
        "pid",
        "hostname",
        "name",
        "level",
        "time",
        "timestamp",
        "caller"
      ]
    };
  }
});

// node_modules/pino-pretty/lib/utils/get-level-label-data.js
var require_get_level_label_data = __commonJS({
  "node_modules/pino-pretty/lib/utils/get-level-label-data.js"(exports, module) {
    "use strict";
    module.exports = getLevelLabelData;
    var { LEVELS, LEVEL_NAMES } = require_constants2();
    function getLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames) {
      const levels = useOnlyCustomProps ? customLevels || LEVELS : Object.assign({}, LEVELS, customLevels);
      const levelNames = useOnlyCustomProps ? customLevelNames || LEVEL_NAMES : Object.assign({}, LEVEL_NAMES, customLevelNames);
      return function(level) {
        let levelNum = "default";
        if (Number.isInteger(+level)) {
          levelNum = Object.prototype.hasOwnProperty.call(levels, level) ? level : levelNum;
        } else {
          levelNum = Object.prototype.hasOwnProperty.call(levelNames, level.toLowerCase()) ? levelNames[level.toLowerCase()] : levelNum;
        }
        return [levels[levelNum], levelNum];
      };
    }
  }
});

// node_modules/pino-pretty/lib/colors.js
var require_colors = __commonJS({
  "node_modules/pino-pretty/lib/colors.js"(exports, module) {
    "use strict";
    var nocolor = (input) => input;
    var plain = {
      default: nocolor,
      60: nocolor,
      50: nocolor,
      40: nocolor,
      30: nocolor,
      20: nocolor,
      10: nocolor,
      message: nocolor,
      greyMessage: nocolor
    };
    var { createColors } = require_colorette();
    var getLevelLabelData = require_get_level_label_data();
    var availableColors = createColors({ useColor: true });
    var { white, bgRed, red, yellow, green, blue, gray, cyan } = availableColors;
    var colored = {
      default: white,
      60: bgRed,
      50: red,
      40: yellow,
      30: green,
      20: blue,
      10: gray,
      message: cyan,
      greyMessage: gray
    };
    function resolveCustomColoredColorizer(customColors) {
      return customColors.reduce(
        function(agg, [level, color]) {
          agg[level] = typeof availableColors[color] === "function" ? availableColors[color] : white;
          return agg;
        },
        { default: white, message: cyan, greyMessage: gray }
      );
    }
    function colorizeLevel(useOnlyCustomProps) {
      return function(level, colorizer, { customLevels, customLevelNames } = {}) {
        const [levelStr, levelNum] = getLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames)(level);
        return Object.prototype.hasOwnProperty.call(colorizer, levelNum) ? colorizer[levelNum](levelStr) : colorizer.default(levelStr);
      };
    }
    function plainColorizer(useOnlyCustomProps) {
      const newPlainColorizer = colorizeLevel(useOnlyCustomProps);
      const customColoredColorizer = function(level, opts) {
        return newPlainColorizer(level, plain, opts);
      };
      customColoredColorizer.message = plain.message;
      customColoredColorizer.greyMessage = plain.greyMessage;
      customColoredColorizer.colors = createColors({ useColor: false });
      return customColoredColorizer;
    }
    function coloredColorizer(useOnlyCustomProps) {
      const newColoredColorizer = colorizeLevel(useOnlyCustomProps);
      const customColoredColorizer = function(level, opts) {
        return newColoredColorizer(level, colored, opts);
      };
      customColoredColorizer.message = colored.message;
      customColoredColorizer.greyMessage = colored.greyMessage;
      customColoredColorizer.colors = availableColors;
      return customColoredColorizer;
    }
    function customColoredColorizerFactory(customColors, useOnlyCustomProps) {
      const onlyCustomColored = resolveCustomColoredColorizer(customColors);
      const customColored = useOnlyCustomProps ? onlyCustomColored : Object.assign({}, colored, onlyCustomColored);
      const colorizeLevelCustom = colorizeLevel(useOnlyCustomProps);
      const customColoredColorizer = function(level, opts) {
        return colorizeLevelCustom(level, customColored, opts);
      };
      customColoredColorizer.colors = availableColors;
      customColoredColorizer.message = customColoredColorizer.message || customColored.message;
      customColoredColorizer.greyMessage = customColoredColorizer.greyMessage || customColored.greyMessage;
      return customColoredColorizer;
    }
    module.exports = function getColorizer(useColors = false, customColors, useOnlyCustomProps) {
      if (useColors && customColors !== void 0) {
        return customColoredColorizerFactory(customColors, useOnlyCustomProps);
      } else if (useColors) {
        return coloredColorizer(useOnlyCustomProps);
      }
      return plainColorizer(useOnlyCustomProps);
    };
  }
});

// node_modules/pino-pretty/lib/utils/noop.js
var require_noop = __commonJS({
  "node_modules/pino-pretty/lib/utils/noop.js"(exports, module) {
    "use strict";
    module.exports = function noop() {
    };
  }
});

// node_modules/pino-pretty/lib/utils/build-safe-sonic-boom.js
var require_build_safe_sonic_boom = __commonJS({
  "node_modules/pino-pretty/lib/utils/build-safe-sonic-boom.js"(exports, module) {
    "use strict";
    module.exports = buildSafeSonicBoom;
    var { isMainThread } = __require("worker_threads");
    var SonicBoom = require_sonic_boom();
    var noop = require_noop();
    function buildSafeSonicBoom(opts) {
      const stream2 = new SonicBoom(opts);
      stream2.on("error", filterBrokenPipe);
      if (!process.env.NODE_V8_COVERAGE && !opts.sync && isMainThread) {
        setupOnExit(stream2);
      }
      return stream2;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream2.write = noop;
          stream2.end = noop;
          stream2.flushSync = noop;
          stream2.destroy = noop;
          return;
        }
        stream2.removeListener("error", filterBrokenPipe);
      }
    }
    function setupOnExit(stream2) {
      if (global.WeakRef && global.WeakMap && global.FinalizationRegistry) {
        const onExit = require_on_exit_leak_free();
        onExit.register(stream2, autoEnd);
        stream2.on("close", function() {
          onExit.unregister(stream2);
        });
      }
    }
    function autoEnd(stream2, eventName) {
      if (stream2.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream2.flush();
        stream2.on("drain", function() {
          stream2.end();
        });
      } else {
        stream2.flushSync();
      }
    }
  }
});

// node_modules/pino-pretty/lib/utils/is-valid-date.js
var require_is_valid_date = __commonJS({
  "node_modules/pino-pretty/lib/utils/is-valid-date.js"(exports, module) {
    "use strict";
    module.exports = isValidDate;
    function isValidDate(date) {
      return date instanceof Date && !Number.isNaN(date.getTime());
    }
  }
});

// node_modules/pino-pretty/lib/utils/create-date.js
var require_create_date = __commonJS({
  "node_modules/pino-pretty/lib/utils/create-date.js"(exports, module) {
    "use strict";
    module.exports = createDate;
    var isValidDate = require_is_valid_date();
    function createDate(epoch) {
      let date = new Date(epoch);
      if (isValidDate(date)) {
        return date;
      }
      date = /* @__PURE__ */ new Date(+epoch);
      return date;
    }
  }
});

// node_modules/pino-pretty/lib/utils/split-property-key.js
var require_split_property_key = __commonJS({
  "node_modules/pino-pretty/lib/utils/split-property-key.js"(exports, module) {
    "use strict";
    module.exports = splitPropertyKey;
    function splitPropertyKey(key) {
      const result = [];
      let backslash = false;
      let segment = "";
      for (let i3 = 0; i3 < key.length; i3++) {
        const c3 = key.charAt(i3);
        if (c3 === "\\") {
          backslash = true;
          continue;
        }
        if (backslash) {
          backslash = false;
          segment += c3;
          continue;
        }
        if (c3 === ".") {
          result.push(segment);
          segment = "";
          continue;
        }
        segment += c3;
      }
      if (segment.length) {
        result.push(segment);
      }
      return result;
    }
  }
});

// node_modules/pino-pretty/lib/utils/get-property-value.js
var require_get_property_value = __commonJS({
  "node_modules/pino-pretty/lib/utils/get-property-value.js"(exports, module) {
    "use strict";
    module.exports = getPropertyValue;
    var splitPropertyKey = require_split_property_key();
    function getPropertyValue(obj, property) {
      const props = Array.isArray(property) ? property : splitPropertyKey(property);
      for (const prop of props) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          return;
        }
        obj = obj[prop];
      }
      return obj;
    }
  }
});

// node_modules/pino-pretty/lib/utils/delete-log-property.js
var require_delete_log_property = __commonJS({
  "node_modules/pino-pretty/lib/utils/delete-log-property.js"(exports, module) {
    "use strict";
    module.exports = deleteLogProperty;
    var getPropertyValue = require_get_property_value();
    var splitPropertyKey = require_split_property_key();
    function deleteLogProperty(log, property) {
      const props = splitPropertyKey(property);
      const propToDelete = props.pop();
      log = getPropertyValue(log, props);
      if (log !== null && typeof log === "object" && Object.prototype.hasOwnProperty.call(log, propToDelete)) {
        delete log[propToDelete];
      }
    }
  }
});

// node_modules/fast-copy/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/fast-copy/dist/cjs/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var toStringFunction = Function.prototype.toString;
    var create = Object.create;
    var toStringObject = Object.prototype.toString;
    var LegacyCache = (
      /** @class */
      function() {
        function LegacyCache2() {
          this._keys = [];
          this._values = [];
        }
        LegacyCache2.prototype.has = function(key) {
          return !!~this._keys.indexOf(key);
        };
        LegacyCache2.prototype.get = function(key) {
          return this._values[this._keys.indexOf(key)];
        };
        LegacyCache2.prototype.set = function(key, value) {
          this._keys.push(key);
          this._values.push(value);
        };
        return LegacyCache2;
      }()
    );
    function createCacheLegacy() {
      return new LegacyCache();
    }
    function createCacheModern() {
      return /* @__PURE__ */ new WeakMap();
    }
    var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
    function getCleanClone(prototype) {
      if (!prototype) {
        return create(null);
      }
      var Constructor = prototype.constructor;
      if (Constructor === Object) {
        return prototype === Object.prototype ? {} : create(prototype);
      }
      if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
        try {
          return new Constructor();
        } catch (_a3) {
        }
      }
      return create(prototype);
    }
    function getRegExpFlagsLegacy(regExp) {
      var flags = "";
      if (regExp.global) {
        flags += "g";
      }
      if (regExp.ignoreCase) {
        flags += "i";
      }
      if (regExp.multiline) {
        flags += "m";
      }
      if (regExp.unicode) {
        flags += "u";
      }
      if (regExp.sticky) {
        flags += "y";
      }
      return flags;
    }
    function getRegExpFlagsModern(regExp) {
      return regExp.flags;
    }
    var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
    function getTagLegacy(value) {
      var type = toStringObject.call(value);
      return type.substring(8, type.length - 1);
    }
    function getTagModern(value) {
      return value[Symbol.toStringTag] || getTagLegacy(value);
    }
    var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var _a2 = Object.prototype;
    var hasOwnProperty = _a2.hasOwnProperty;
    var propertyIsEnumerable = _a2.propertyIsEnumerable;
    var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
    function getStrictPropertiesModern(object) {
      return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
    }
    var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
    function copyOwnPropertiesStrict(value, clone, state2) {
      var properties = getStrictProperties(value);
      for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
        property = properties[index2];
        if (property === "callee" || property === "caller") {
          continue;
        }
        descriptor = getOwnPropertyDescriptor(value, property);
        if (!descriptor) {
          clone[property] = state2.copier(value[property], state2);
          continue;
        }
        if (!descriptor.get && !descriptor.set) {
          descriptor.value = state2.copier(descriptor.value, state2);
        }
        try {
          defineProperty(clone, property, descriptor);
        } catch (error) {
          clone[property] = descriptor.value;
        }
      }
      return clone;
    }
    function copyArrayLoose(array, state2) {
      var clone = new state2.Constructor();
      state2.cache.set(array, clone);
      for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
        clone[index2] = state2.copier(array[index2], state2);
      }
      return clone;
    }
    function copyArrayStrict(array, state2) {
      var clone = new state2.Constructor();
      state2.cache.set(array, clone);
      return copyOwnPropertiesStrict(array, clone, state2);
    }
    function copyArrayBuffer(arrayBuffer, _state) {
      return arrayBuffer.slice(0);
    }
    function copyBlob(blob, _state) {
      return blob.slice(0, blob.size, blob.type);
    }
    function copyDataView(dataView, state2) {
      return new state2.Constructor(copyArrayBuffer(dataView.buffer));
    }
    function copyDate(date, state2) {
      return new state2.Constructor(date.getTime());
    }
    function copyMapLoose(map2, state2) {
      var clone = new state2.Constructor();
      state2.cache.set(map2, clone);
      map2.forEach(function(value, key) {
        clone.set(key, state2.copier(value, state2));
      });
      return clone;
    }
    function copyMapStrict(map2, state2) {
      return copyOwnPropertiesStrict(map2, copyMapLoose(map2, state2), state2);
    }
    function copyObjectLooseLegacy(object, state2) {
      var clone = getCleanClone(state2.prototype);
      state2.cache.set(object, clone);
      for (var key in object) {
        if (hasOwnProperty.call(object, key)) {
          clone[key] = state2.copier(object[key], state2);
        }
      }
      return clone;
    }
    function copyObjectLooseModern(object, state2) {
      var clone = getCleanClone(state2.prototype);
      state2.cache.set(object, clone);
      for (var key in object) {
        if (hasOwnProperty.call(object, key)) {
          clone[key] = state2.copier(object[key], state2);
        }
      }
      var symbols = getOwnPropertySymbols(object);
      for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
        symbol = symbols[index2];
        if (propertyIsEnumerable.call(object, symbol)) {
          clone[symbol] = state2.copier(object[symbol], state2);
        }
      }
      return clone;
    }
    var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
    function copyObjectStrict(object, state2) {
      var clone = getCleanClone(state2.prototype);
      state2.cache.set(object, clone);
      return copyOwnPropertiesStrict(object, clone, state2);
    }
    function copyPrimitiveWrapper(primitiveObject, state2) {
      return new state2.Constructor(primitiveObject.valueOf());
    }
    function copyRegExp(regExp, state2) {
      var clone = new state2.Constructor(regExp.source, getRegExpFlags(regExp));
      clone.lastIndex = regExp.lastIndex;
      return clone;
    }
    function copySelf(value, _state) {
      return value;
    }
    function copySetLoose(set, state2) {
      var clone = new state2.Constructor();
      state2.cache.set(set, clone);
      set.forEach(function(value) {
        clone.add(state2.copier(value, state2));
      });
      return clone;
    }
    function copySetStrict(set, state2) {
      return copyOwnPropertiesStrict(set, copySetLoose(set, state2), state2);
    }
    var isArray = Array.isArray;
    var assign = Object.assign;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    var DEFAULT_LOOSE_OPTIONS = {
      array: copyArrayLoose,
      arrayBuffer: copyArrayBuffer,
      blob: copyBlob,
      dataView: copyDataView,
      date: copyDate,
      error: copySelf,
      map: copyMapLoose,
      object: copyObjectLoose,
      regExp: copyRegExp,
      set: copySetLoose
    };
    var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
      array: copyArrayStrict,
      map: copyMapStrict,
      object: copyObjectStrict,
      set: copySetStrict
    });
    function getTagSpecificCopiers(options) {
      return {
        Arguments: options.object,
        Array: options.array,
        ArrayBuffer: options.arrayBuffer,
        Blob: options.blob,
        Boolean: copyPrimitiveWrapper,
        DataView: options.dataView,
        Date: options.date,
        Error: options.error,
        Float32Array: options.arrayBuffer,
        Float64Array: options.arrayBuffer,
        Int8Array: options.arrayBuffer,
        Int16Array: options.arrayBuffer,
        Int32Array: options.arrayBuffer,
        Map: options.map,
        Number: copyPrimitiveWrapper,
        Object: options.object,
        Promise: copySelf,
        RegExp: options.regExp,
        Set: options.set,
        String: copyPrimitiveWrapper,
        WeakMap: copySelf,
        WeakSet: copySelf,
        Uint8Array: options.arrayBuffer,
        Uint8ClampedArray: options.arrayBuffer,
        Uint16Array: options.arrayBuffer,
        Uint32Array: options.arrayBuffer,
        Uint64Array: options.arrayBuffer
      };
    }
    function createCopier(options) {
      var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
      var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
      var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
      function copier(value, state2) {
        state2.prototype = state2.Constructor = void 0;
        if (!value || typeof value !== "object") {
          return value;
        }
        if (state2.cache.has(value)) {
          return state2.cache.get(value);
        }
        state2.prototype = getPrototypeOf(value);
        state2.Constructor = state2.prototype && state2.prototype.constructor;
        if (!state2.Constructor || state2.Constructor === Object) {
          return object(value, state2);
        }
        if (isArray(value)) {
          return array(value, state2);
        }
        var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
        if (tagSpecificCopier) {
          return tagSpecificCopier(value, state2);
        }
        return typeof value.then === "function" ? value : object(value, state2);
      }
      return function copy(value) {
        return copier(value, {
          Constructor: void 0,
          cache: createCache(),
          copier,
          prototype: void 0
        });
      };
    }
    function createStrictCopier(options) {
      return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
    }
    var copyStrict = createStrictCopier({});
    var index = createCopier({});
    exports.copyStrict = copyStrict;
    exports.createCopier = createCopier;
    exports.createStrictCopier = createStrictCopier;
    exports.default = index;
  }
});

// node_modules/pino-pretty/lib/utils/filter-log.js
var require_filter_log = __commonJS({
  "node_modules/pino-pretty/lib/utils/filter-log.js"(exports, module) {
    "use strict";
    module.exports = filterLog;
    var { createCopier } = require_cjs();
    var fastCopy = createCopier({});
    var deleteLogProperty = require_delete_log_property();
    function filterLog({ log, context }) {
      const { ignoreKeys, includeKeys } = context;
      const logCopy = fastCopy(log);
      if (includeKeys) {
        const logIncluded = {};
        includeKeys.forEach((key) => {
          logIncluded[key] = logCopy[key];
        });
        return logIncluded;
      }
      ignoreKeys.forEach((ignoreKey) => {
        deleteLogProperty(logCopy, ignoreKey);
      });
      return logCopy;
    }
  }
});

// node_modules/dateformat/lib/dateformat.js
var require_dateformat = __commonJS({
  "node_modules/dateformat/lib/dateformat.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    (function(global2) {
      var _arguments = arguments;
      var dateFormat = /* @__PURE__ */ function() {
        var token = /d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;
        var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
        var timezoneClip = /[^-+\dA-Z]/g;
        return function(date, mask, utc, gmt) {
          if (_arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
            mask = date;
            date = void 0;
          }
          date = date || date === 0 ? date : /* @__PURE__ */ new Date();
          if (!(date instanceof Date)) {
            date = new Date(date);
          }
          if (isNaN(date)) {
            throw TypeError("Invalid date");
          }
          mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
          var maskSlice = mask.slice(0, 4);
          if (maskSlice === "UTC:" || maskSlice === "GMT:") {
            mask = mask.slice(4);
            utc = true;
            if (maskSlice === "GMT:") {
              gmt = true;
            }
          }
          var _2 = function _3() {
            return utc ? "getUTC" : "get";
          };
          var _d = function d3() {
            return date[_2() + "Date"]();
          };
          var D2 = function D3() {
            return date[_2() + "Day"]();
          };
          var _m2 = function m3() {
            return date[_2() + "Month"]();
          };
          var y2 = function y3() {
            return date[_2() + "FullYear"]();
          };
          var _H = function H2() {
            return date[_2() + "Hours"]();
          };
          var _M = function M() {
            return date[_2() + "Minutes"]();
          };
          var _s = function s3() {
            return date[_2() + "Seconds"]();
          };
          var _L = function L() {
            return date[_2() + "Milliseconds"]();
          };
          var _o = function o3() {
            return utc ? 0 : date.getTimezoneOffset();
          };
          var _W = function W() {
            return getWeek(date);
          };
          var _N = function N() {
            return getDayOfWeek(date);
          };
          var flags = { d: function d3() {
            return _d();
          }, dd: function dd() {
            return pad(_d());
          }, ddd: function ddd() {
            return dateFormat.i18n.dayNames[D2()];
          }, DDD: function DDD() {
            return getDayName({ y: y2(), m: _m2(), d: _d(), _: _2(), dayName: dateFormat.i18n.dayNames[D2()], short: true });
          }, dddd: function dddd() {
            return dateFormat.i18n.dayNames[D2() + 7];
          }, DDDD: function DDDD() {
            return getDayName({ y: y2(), m: _m2(), d: _d(), _: _2(), dayName: dateFormat.i18n.dayNames[D2() + 7] });
          }, m: function m3() {
            return _m2() + 1;
          }, mm: function mm() {
            return pad(_m2() + 1);
          }, mmm: function mmm() {
            return dateFormat.i18n.monthNames[_m2()];
          }, mmmm: function mmmm() {
            return dateFormat.i18n.monthNames[_m2() + 12];
          }, yy: function yy() {
            return String(y2()).slice(2);
          }, yyyy: function yyyy() {
            return pad(y2(), 4);
          }, h: function h3() {
            return _H() % 12 || 12;
          }, hh: function hh() {
            return pad(_H() % 12 || 12);
          }, H: function H2() {
            return _H();
          }, HH: function HH() {
            return pad(_H());
          }, M: function M() {
            return _M();
          }, MM: function MM() {
            return pad(_M());
          }, s: function s3() {
            return _s();
          }, ss: function ss() {
            return pad(_s());
          }, l: function l3() {
            return pad(_L(), 3);
          }, L: function L() {
            return pad(Math.floor(_L() / 10));
          }, t: function t3() {
            return _H() < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1];
          }, tt: function tt() {
            return _H() < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3];
          }, T: function T() {
            return _H() < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5];
          }, TT: function TT() {
            return _H() < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7];
          }, Z: function Z() {
            return gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, "").replace(/GMT\+0000/g, "UTC");
          }, o: function o3() {
            return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60) * 100 + Math.abs(_o()) % 60, 4);
          }, p: function p3() {
            return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60), 2) + ":" + pad(Math.floor(Math.abs(_o()) % 60), 2);
          }, S: function S() {
            return ["th", "st", "nd", "rd"][_d() % 10 > 3 ? 0 : (_d() % 100 - _d() % 10 != 10) * _d() % 10];
          }, W: function W() {
            return _W();
          }, WW: function WW() {
            return pad(_W());
          }, N: function N() {
            return _N();
          } };
          return mask.replace(token, function(match) {
            if (match in flags) {
              return flags[match]();
            }
            return match.slice(1, match.length - 1);
          });
        };
      }();
      dateFormat.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", paddedShortDate: "mm/dd/yyyy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" };
      dateFormat.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"] };
      var pad = function pad2(val2, len) {
        val2 = String(val2);
        len = len || 2;
        while (val2.length < len) {
          val2 = "0" + val2;
        }
        return val2;
      };
      var getDayName = function getDayName2(_ref) {
        var y2 = _ref.y, m3 = _ref.m, d3 = _ref.d, _2 = _ref._, dayName = _ref.dayName, _ref$short = _ref["short"], _short = _ref$short === void 0 ? false : _ref$short;
        var today = /* @__PURE__ */ new Date();
        var yesterday = /* @__PURE__ */ new Date();
        yesterday.setDate(yesterday[_2 + "Date"]() - 1);
        var tomorrow = /* @__PURE__ */ new Date();
        tomorrow.setDate(tomorrow[_2 + "Date"]() + 1);
        var today_d = function today_d2() {
          return today[_2 + "Date"]();
        };
        var today_m = function today_m2() {
          return today[_2 + "Month"]();
        };
        var today_y = function today_y2() {
          return today[_2 + "FullYear"]();
        };
        var yesterday_d = function yesterday_d2() {
          return yesterday[_2 + "Date"]();
        };
        var yesterday_m = function yesterday_m2() {
          return yesterday[_2 + "Month"]();
        };
        var yesterday_y = function yesterday_y2() {
          return yesterday[_2 + "FullYear"]();
        };
        var tomorrow_d = function tomorrow_d2() {
          return tomorrow[_2 + "Date"]();
        };
        var tomorrow_m = function tomorrow_m2() {
          return tomorrow[_2 + "Month"]();
        };
        var tomorrow_y = function tomorrow_y2() {
          return tomorrow[_2 + "FullYear"]();
        };
        if (today_y() === y2 && today_m() === m3 && today_d() === d3) {
          return _short ? "Tdy" : "Today";
        } else if (yesterday_y() === y2 && yesterday_m() === m3 && yesterday_d() === d3) {
          return _short ? "Ysd" : "Yesterday";
        } else if (tomorrow_y() === y2 && tomorrow_m() === m3 && tomorrow_d() === d3) {
          return _short ? "Tmw" : "Tomorrow";
        }
        return dayName;
      };
      var getWeek = function getWeek2(date) {
        var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
        var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
        firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
        var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
        targetThursday.setHours(targetThursday.getHours() - ds);
        var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
        return 1 + Math.floor(weekDiff);
      };
      var getDayOfWeek = function getDayOfWeek2(date) {
        var dow = date.getDay();
        if (dow === 0) {
          dow = 7;
        }
        return dow;
      };
      var kindOf = function kindOf2(val2) {
        if (val2 === null) {
          return "null";
        }
        if (val2 === void 0) {
          return "undefined";
        }
        if (_typeof(val2) !== "object") {
          return _typeof(val2);
        }
        if (Array.isArray(val2)) {
          return "array";
        }
        return {}.toString.call(val2).slice(8, -1).toLowerCase();
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return dateFormat;
        });
      } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {
        module.exports = dateFormat;
      } else {
        global2.dateFormat = dateFormat;
      }
    })(void 0);
  }
});

// node_modules/pino-pretty/lib/utils/format-time.js
var require_format_time = __commonJS({
  "node_modules/pino-pretty/lib/utils/format-time.js"(exports, module) {
    "use strict";
    module.exports = formatTime;
    var {
      DATE_FORMAT,
      DATE_FORMAT_SIMPLE
    } = require_constants2();
    var dateformat = require_dateformat();
    var createDate = require_create_date();
    var isValidDate = require_is_valid_date();
    function formatTime(epoch, translateTime = false) {
      if (translateTime === false) {
        return epoch;
      }
      const instant = createDate(epoch);
      if (!isValidDate(instant)) {
        return epoch;
      }
      if (translateTime === true) {
        return dateformat(instant, DATE_FORMAT_SIMPLE);
      }
      const upperFormat = translateTime.toUpperCase();
      if (upperFormat === "SYS:STANDARD") {
        return dateformat(instant, DATE_FORMAT);
      }
      const prefix = upperFormat.substr(0, 4);
      if (prefix === "SYS:" || prefix === "UTC:") {
        if (prefix === "UTC:") {
          return dateformat(instant, translateTime);
        }
        return dateformat(instant, translateTime.slice(4));
      }
      return dateformat(instant, `UTC:${translateTime}`);
    }
  }
});

// node_modules/pino-pretty/lib/utils/handle-custom-levels-names-opts.js
var require_handle_custom_levels_names_opts = __commonJS({
  "node_modules/pino-pretty/lib/utils/handle-custom-levels-names-opts.js"(exports, module) {
    "use strict";
    module.exports = handleCustomLevelsNamesOpts;
    function handleCustomLevelsNamesOpts(cLevels) {
      if (!cLevels) return {};
      if (typeof cLevels === "string") {
        return cLevels.split(",").reduce((agg, value, idx) => {
          const [levelName, levelNum = idx] = value.split(":");
          agg[levelName.toLowerCase()] = levelNum;
          return agg;
        }, {});
      } else if (Object.prototype.toString.call(cLevels) === "[object Object]") {
        return Object.keys(cLevels).reduce((agg, levelName) => {
          agg[levelName.toLowerCase()] = cLevels[levelName];
          return agg;
        }, {});
      } else {
        return {};
      }
    }
  }
});

// node_modules/pino-pretty/lib/utils/handle-custom-levels-opts.js
var require_handle_custom_levels_opts = __commonJS({
  "node_modules/pino-pretty/lib/utils/handle-custom-levels-opts.js"(exports, module) {
    "use strict";
    module.exports = handleCustomLevelsOpts;
    function handleCustomLevelsOpts(cLevels) {
      if (!cLevels) return {};
      if (typeof cLevels === "string") {
        return cLevels.split(",").reduce(
          (agg, value, idx) => {
            const [levelName, levelNum = idx] = value.split(":");
            agg[levelNum] = levelName.toUpperCase();
            return agg;
          },
          { default: "USERLVL" }
        );
      } else if (Object.prototype.toString.call(cLevels) === "[object Object]") {
        return Object.keys(cLevels).reduce((agg, levelName) => {
          agg[cLevels[levelName]] = levelName.toUpperCase();
          return agg;
        }, { default: "USERLVL" });
      } else {
        return {};
      }
    }
  }
});

// node_modules/pino-pretty/lib/utils/interpret-conditionals.js
var require_interpret_conditionals = __commonJS({
  "node_modules/pino-pretty/lib/utils/interpret-conditionals.js"(exports, module) {
    "use strict";
    module.exports = interpretConditionals;
    var getPropertyValue = require_get_property_value();
    function interpretConditionals(messageFormat, log) {
      messageFormat = messageFormat.replace(/{if (.*?)}(.*?){end}/g, replacer);
      messageFormat = messageFormat.replace(/{if (.*?)}/g, "");
      messageFormat = messageFormat.replace(/{end}/g, "");
      return messageFormat.replace(/\s+/g, " ").trim();
      function replacer(_2, key, value) {
        const propertyValue = getPropertyValue(log, key);
        if (propertyValue && value.includes(key)) {
          return value.replace(new RegExp("{" + key + "}", "g"), propertyValue);
        } else {
          return "";
        }
      }
    }
  }
});

// node_modules/pino-pretty/lib/utils/is-object.js
var require_is_object = __commonJS({
  "node_modules/pino-pretty/lib/utils/is-object.js"(exports, module) {
    "use strict";
    module.exports = isObject;
    function isObject(input) {
      return Object.prototype.toString.apply(input) === "[object Object]";
    }
  }
});

// node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js
var require_join_lines_with_indentation = __commonJS({
  "node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js"(exports, module) {
    "use strict";
    module.exports = joinLinesWithIndentation;
    function joinLinesWithIndentation({ input, ident = "    ", eol = "\n" }) {
      const lines = input.split(/\r?\n/);
      for (let i3 = 1; i3 < lines.length; i3 += 1) {
        lines[i3] = ident + lines[i3];
      }
      return lines.join(eol);
    }
  }
});

// node_modules/pino-pretty/lib/utils/parse-factory-options.js
var require_parse_factory_options = __commonJS({
  "node_modules/pino-pretty/lib/utils/parse-factory-options.js"(exports, module) {
    "use strict";
    module.exports = parseFactoryOptions;
    var {
      LEVEL_NAMES
    } = require_constants2();
    var colors = require_colors();
    var handleCustomLevelsOpts = require_handle_custom_levels_opts();
    var handleCustomLevelsNamesOpts = require_handle_custom_levels_names_opts();
    var handleLevelLabelData = require_get_level_label_data();
    function parseFactoryOptions(options) {
      const EOL = options.crlf ? "\r\n" : "\n";
      const IDENT = "    ";
      const {
        customPrettifiers,
        errorLikeObjectKeys,
        hideObject,
        levelFirst,
        levelKey,
        levelLabel,
        messageFormat,
        messageKey,
        minimumLevel,
        singleLine,
        timestampKey,
        translateTime
      } = options;
      const errorProps = options.errorProps.split(",");
      const useOnlyCustomProps = typeof options.useOnlyCustomProps === "boolean" ? options.useOnlyCustomProps : options.useOnlyCustomProps === "true";
      const customLevels = handleCustomLevelsOpts(options.customLevels);
      const customLevelNames = handleCustomLevelsNamesOpts(options.customLevels);
      const getLevelLabelData = handleLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames);
      let customColors;
      if (options.customColors) {
        if (typeof options.customColors === "string") {
          customColors = options.customColors.split(",").reduce((agg, value) => {
            const [level, color] = value.split(":");
            const condition = useOnlyCustomProps ? options.customLevels : customLevelNames[level] !== void 0;
            const levelNum = condition ? customLevelNames[level] : LEVEL_NAMES[level];
            const colorIdx = levelNum !== void 0 ? levelNum : level;
            agg.push([colorIdx, color]);
            return agg;
          }, []);
        } else if (typeof options.customColors === "object") {
          customColors = Object.keys(options.customColors).reduce((agg, value) => {
            const [level, color] = [value, options.customColors[value]];
            const condition = useOnlyCustomProps ? options.customLevels : customLevelNames[level] !== void 0;
            const levelNum = condition ? customLevelNames[level] : LEVEL_NAMES[level];
            const colorIdx = levelNum !== void 0 ? levelNum : level;
            agg.push([colorIdx, color]);
            return agg;
          }, []);
        } else {
          throw new Error("options.customColors must be of type string or object.");
        }
      }
      const customProperties = { customLevels, customLevelNames };
      if (useOnlyCustomProps === true && !options.customLevels) {
        customProperties.customLevels = void 0;
        customProperties.customLevelNames = void 0;
      }
      const includeKeys = options.include !== void 0 ? new Set(options.include.split(",")) : void 0;
      const ignoreKeys = !includeKeys && options.ignore ? new Set(options.ignore.split(",")) : void 0;
      const colorizer = colors(options.colorize, customColors, useOnlyCustomProps);
      const objectColorizer = options.colorizeObjects ? colorizer : colors(false, [], false);
      return {
        EOL,
        IDENT,
        colorizer,
        customColors,
        customLevelNames,
        customLevels,
        customPrettifiers,
        customProperties,
        errorLikeObjectKeys,
        errorProps,
        getLevelLabelData,
        hideObject,
        ignoreKeys,
        includeKeys,
        levelFirst,
        levelKey,
        levelLabel,
        messageFormat,
        messageKey,
        minimumLevel,
        objectColorizer,
        singleLine,
        timestampKey,
        translateTime,
        useOnlyCustomProps
      };
    }
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_2) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val2, k3, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k3);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k3, { value: replace });
          arr.push([parent, k3, val2, propertyDescriptor]);
        } else {
          replacerStack.push([val2, k3, replace]);
        }
      } else {
        parent[k3] = replace;
        arr.push([parent, k3, val2]);
      }
    }
    function decirc(val2, k3, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i3;
      if (typeof val2 === "object" && val2 !== null) {
        for (i3 = 0; i3 < stack.length; i3++) {
          if (stack[i3] === val2) {
            setReplace(CIRCULAR_REPLACE_NODE, val2, k3, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val2, k3, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val2, k3, parent);
          return;
        }
        stack.push(val2);
        if (Array.isArray(val2)) {
          for (i3 = 0; i3 < val2.length; i3++) {
            decirc(val2[i3], i3, i3, stack, val2, depth, options);
          }
        } else {
          var keys = Object.keys(val2);
          for (i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            decirc(val2[key], key, i3, stack, val2, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a3, b3) {
      if (a3 < b3) {
        return -1;
      }
      if (a3 > b3) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_2) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val2, k3, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i3;
      if (typeof val2 === "object" && val2 !== null) {
        for (i3 = 0; i3 < stack.length; i3++) {
          if (stack[i3] === val2) {
            setReplace(CIRCULAR_REPLACE_NODE, val2, k3, parent);
            return;
          }
        }
        try {
          if (typeof val2.toJSON === "function") {
            return;
          }
        } catch (_2) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val2, k3, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val2, k3, parent);
          return;
        }
        stack.push(val2);
        if (Array.isArray(val2)) {
          for (i3 = 0; i3 < val2.length; i3++) {
            deterministicDecirc(val2[i3], i3, i3, stack, val2, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val2).sort(compareFunction);
          for (i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            deterministicDecirc(val2[key], key, i3, stack, val2, depth, options);
            tmp[key] = val2[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k3, val2]);
            parent[k3] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k3, v6) {
        return v6;
      };
      return function(key, val2) {
        if (replacerStack.length > 0) {
          for (var i3 = 0; i3 < replacerStack.length; i3++) {
            var part = replacerStack[i3];
            if (part[1] === key && part[0] === val2) {
              val2 = part[2];
              replacerStack.splice(i3, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val2);
      };
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-error.js
var require_prettify_error = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-error.js"(exports, module) {
    "use strict";
    module.exports = prettifyError;
    var joinLinesWithIndentation = require_join_lines_with_indentation();
    function prettifyError({ keyName, lines, eol, ident }) {
      let result = "";
      const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
      const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol);
      for (let j3 = 0; j3 < splitLines.length; j3 += 1) {
        if (j3 !== 0) result += eol;
        const line = splitLines[j3];
        if (/^\s*"stack"/.test(line)) {
          const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line);
          if (matches && matches.length === 3) {
            const indentSize = /^\s*/.exec(line)[0].length + 4;
            const indentation = " ".repeat(indentSize);
            const stackMessage = matches[2];
            result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation);
          } else {
            result += line;
          }
        } else {
          result += line;
        }
      }
      return result;
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-object.js
var require_prettify_object = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-object.js"(exports, module) {
    "use strict";
    module.exports = prettifyObject;
    var {
      LOGGER_KEYS
    } = require_constants2();
    var stringifySafe = require_fast_safe_stringify();
    var joinLinesWithIndentation = require_join_lines_with_indentation();
    var prettifyError = require_prettify_error();
    function prettifyObject({
      log,
      excludeLoggerKeys = true,
      skipKeys = [],
      context
    }) {
      const {
        EOL: eol,
        IDENT: ident,
        customPrettifiers,
        errorLikeObjectKeys: errorLikeKeys,
        objectColorizer,
        singleLine,
        colorizer
      } = context;
      const keysToIgnore = [].concat(skipKeys);
      if (excludeLoggerKeys === true) Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS);
      let result = "";
      const { plain, errors } = Object.entries(log).reduce(({ plain: plain2, errors: errors2 }, [k3, v6]) => {
        if (keysToIgnore.includes(k3) === false) {
          const pretty2 = typeof customPrettifiers[k3] === "function" ? customPrettifiers[k3](v6, k3, log, { colors: colorizer.colors }) : v6;
          if (errorLikeKeys.includes(k3)) {
            errors2[k3] = pretty2;
          } else {
            plain2[k3] = pretty2;
          }
        }
        return { plain: plain2, errors: errors2 };
      }, { plain: {}, errors: {} });
      if (singleLine) {
        if (Object.keys(plain).length > 0) {
          result += objectColorizer.greyMessage(stringifySafe(plain));
        }
        result += eol;
        result = result.replace(/\\\\/gi, "\\");
      } else {
        Object.entries(plain).forEach(([keyName, keyValue]) => {
          let lines = typeof customPrettifiers[keyName] === "function" ? keyValue : stringifySafe(keyValue, null, 2);
          if (lines === void 0) return;
          lines = lines.replace(/\\\\/gi, "\\");
          const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
          result += `${ident}${keyName}:${joinedLines.startsWith(eol) ? "" : " "}${joinedLines}${eol}`;
        });
      }
      Object.entries(errors).forEach(([keyName, keyValue]) => {
        const lines = typeof customPrettifiers[keyName] === "function" ? keyValue : stringifySafe(keyValue, null, 2);
        if (lines === void 0) return;
        result += prettifyError({ keyName, lines, eol, ident });
      });
      return result;
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-error-log.js
var require_prettify_error_log = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-error-log.js"(exports, module) {
    "use strict";
    module.exports = prettifyErrorLog;
    var {
      LOGGER_KEYS
    } = require_constants2();
    var isObject = require_is_object();
    var joinLinesWithIndentation = require_join_lines_with_indentation();
    var prettifyObject = require_prettify_object();
    function prettifyErrorLog({ log, context }) {
      const {
        EOL: eol,
        IDENT: ident,
        errorProps: errorProperties,
        messageKey
      } = context;
      const stack = log.stack;
      const joinedLines = joinLinesWithIndentation({ input: stack, ident, eol });
      let result = `${ident}${joinedLines}${eol}`;
      if (errorProperties.length > 0) {
        const excludeProperties = LOGGER_KEYS.concat(messageKey, "type", "stack");
        let propertiesToPrint;
        if (errorProperties[0] === "*") {
          propertiesToPrint = Object.keys(log).filter((k3) => excludeProperties.includes(k3) === false);
        } else {
          propertiesToPrint = errorProperties.filter((k3) => excludeProperties.includes(k3) === false);
        }
        for (let i3 = 0; i3 < propertiesToPrint.length; i3 += 1) {
          const key = propertiesToPrint[i3];
          if (key in log === false) continue;
          if (isObject(log[key])) {
            const prettifiedObject = prettifyObject({
              log: log[key],
              excludeLoggerKeys: false,
              context: {
                ...context,
                IDENT: ident + ident
              }
            });
            result = `${result}${ident}${key}: {${eol}${prettifiedObject}${ident}}${eol}`;
            continue;
          }
          result = `${result}${ident}${key}: ${log[key]}${eol}`;
        }
      }
      return result;
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-level.js
var require_prettify_level = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-level.js"(exports, module) {
    "use strict";
    module.exports = prettifyLevel;
    var getPropertyValue = require_get_property_value();
    function prettifyLevel({ log, context }) {
      const {
        colorizer,
        customLevels,
        customLevelNames,
        levelKey,
        getLevelLabelData
      } = context;
      const prettifier = context.customPrettifiers?.level;
      const output = getPropertyValue(log, levelKey);
      if (output === void 0) return void 0;
      const labelColorized = colorizer(output, { customLevels, customLevelNames });
      if (prettifier) {
        const [label] = getLevelLabelData(output);
        return prettifier(output, levelKey, log, { label, labelColorized, colors: colorizer.colors });
      }
      return labelColorized;
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-message.js
var require_prettify_message = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-message.js"(exports, module) {
    "use strict";
    module.exports = prettifyMessage;
    var {
      LEVELS
    } = require_constants2();
    var getPropertyValue = require_get_property_value();
    var interpretConditionals = require_interpret_conditionals();
    function prettifyMessage({ log, context }) {
      const {
        colorizer,
        customLevels,
        levelKey,
        levelLabel,
        messageFormat,
        messageKey,
        useOnlyCustomProps
      } = context;
      if (messageFormat && typeof messageFormat === "string") {
        const parsedMessageFormat = interpretConditionals(messageFormat, log);
        const message = String(parsedMessageFormat).replace(
          /{([^{}]+)}/g,
          function(match, p1) {
            let level;
            if (p1 === levelLabel && (level = getPropertyValue(log, levelKey)) !== void 0) {
              const condition = useOnlyCustomProps ? customLevels === void 0 : customLevels[level] === void 0;
              return condition ? LEVELS[level] : customLevels[level];
            }
            return getPropertyValue(log, p1) || "";
          }
        );
        return colorizer.message(message);
      }
      if (messageFormat && typeof messageFormat === "function") {
        const msg = messageFormat(log, messageKey, levelLabel, { colors: colorizer.colors });
        return colorizer.message(msg);
      }
      if (messageKey in log === false) return void 0;
      if (typeof log[messageKey] !== "string" && typeof log[messageKey] !== "number" && typeof log[messageKey] !== "boolean") return void 0;
      return colorizer.message(log[messageKey]);
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-metadata.js
var require_prettify_metadata = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-metadata.js"(exports, module) {
    "use strict";
    module.exports = prettifyMetadata;
    function prettifyMetadata({ log, context }) {
      const { customPrettifiers: prettifiers, colorizer } = context;
      let line = "";
      if (log.name || log.pid || log.hostname) {
        line += "(";
        if (log.name) {
          line += prettifiers.name ? prettifiers.name(log.name, "name", log, { colors: colorizer.colors }) : log.name;
        }
        if (log.pid) {
          const prettyPid = prettifiers.pid ? prettifiers.pid(log.pid, "pid", log, { colors: colorizer.colors }) : log.pid;
          if (log.name && log.pid) {
            line += "/" + prettyPid;
          } else {
            line += prettyPid;
          }
        }
        if (log.hostname) {
          const prettyHostname = prettifiers.hostname ? prettifiers.hostname(log.hostname, "hostname", log, { colors: colorizer.colors }) : log.hostname;
          line += `${line === "(" ? "on" : " on"} ${prettyHostname}`;
        }
        line += ")";
      }
      if (log.caller) {
        const prettyCaller = prettifiers.caller ? prettifiers.caller(log.caller, "caller", log, { colors: colorizer.colors }) : log.caller;
        line += `${line === "" ? "" : " "}<${prettyCaller}>`;
      }
      if (line === "") {
        return void 0;
      } else {
        return line;
      }
    }
  }
});

// node_modules/pino-pretty/lib/utils/prettify-time.js
var require_prettify_time = __commonJS({
  "node_modules/pino-pretty/lib/utils/prettify-time.js"(exports, module) {
    "use strict";
    module.exports = prettifyTime;
    var formatTime = require_format_time();
    function prettifyTime({ log, context }) {
      const {
        timestampKey,
        translateTime: translateFormat
      } = context;
      const prettifier = context.customPrettifiers?.time;
      let time = null;
      if (timestampKey in log) {
        time = log[timestampKey];
      } else if ("timestamp" in log) {
        time = log.timestamp;
      }
      if (time === null) return void 0;
      const output = translateFormat ? formatTime(time, translateFormat) : time;
      return prettifier ? prettifier(output) : `[${output}]`;
    }
  }
});

// node_modules/pino-pretty/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/pino-pretty/lib/utils/index.js"(exports, module) {
    "use strict";
    module.exports = {
      buildSafeSonicBoom: require_build_safe_sonic_boom(),
      createDate: require_create_date(),
      deleteLogProperty: require_delete_log_property(),
      filterLog: require_filter_log(),
      formatTime: require_format_time(),
      getPropertyValue: require_get_property_value(),
      handleCustomLevelsNamesOpts: require_handle_custom_levels_names_opts(),
      handleCustomLevelsOpts: require_handle_custom_levels_opts(),
      interpretConditionals: require_interpret_conditionals(),
      isObject: require_is_object(),
      isValidDate: require_is_valid_date(),
      joinLinesWithIndentation: require_join_lines_with_indentation(),
      noop: require_noop(),
      parseFactoryOptions: require_parse_factory_options(),
      prettifyErrorLog: require_prettify_error_log(),
      prettifyError: require_prettify_error(),
      prettifyLevel: require_prettify_level(),
      prettifyMessage: require_prettify_message(),
      prettifyMetadata: require_prettify_metadata(),
      prettifyObject: require_prettify_object(),
      prettifyTime: require_prettify_time(),
      splitPropertyKey: require_split_property_key(),
      getLevelLabelData: require_get_level_label_data()
    };
  }
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports, module) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse4(text, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse4;
    module.exports.default = parse4;
    module.exports.parse = parse4;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter;
  }
});

// node_modules/pino-pretty/lib/pretty.js
var require_pretty = __commonJS({
  "node_modules/pino-pretty/lib/pretty.js"(exports, module) {
    "use strict";
    module.exports = pretty2;
    var sjs = require_secure_json_parse();
    var isObject = require_is_object();
    var prettifyErrorLog = require_prettify_error_log();
    var prettifyLevel = require_prettify_level();
    var prettifyMessage = require_prettify_message();
    var prettifyMetadata = require_prettify_metadata();
    var prettifyObject = require_prettify_object();
    var prettifyTime = require_prettify_time();
    var filterLog = require_filter_log();
    var {
      LEVELS,
      LEVEL_KEY,
      LEVEL_NAMES
    } = require_constants2();
    var jsonParser = (input) => {
      try {
        return { value: sjs.parse(input, { protoAction: "remove" }) };
      } catch (err) {
        return { err };
      }
    };
    function pretty2(inputData) {
      let log;
      if (!isObject(inputData)) {
        const parsed = jsonParser(inputData);
        if (parsed.err || !isObject(parsed.value)) {
          return inputData + this.EOL;
        }
        log = parsed.value;
      } else {
        log = inputData;
      }
      if (this.minimumLevel) {
        let condition;
        if (this.useOnlyCustomProps) {
          condition = this.customLevels;
        } else {
          condition = this.customLevelNames[this.minimumLevel] !== void 0;
        }
        let minimum;
        if (condition) {
          minimum = this.customLevelNames[this.minimumLevel];
        } else {
          minimum = LEVEL_NAMES[this.minimumLevel];
        }
        if (!minimum) {
          minimum = typeof this.minimumLevel === "string" ? LEVEL_NAMES[this.minimumLevel] : LEVEL_NAMES[LEVELS[this.minimumLevel].toLowerCase()];
        }
        const level = log[this.levelKey === void 0 ? LEVEL_KEY : this.levelKey];
        if (level < minimum) return;
      }
      const prettifiedMessage = prettifyMessage({ log, context: this.context });
      if (this.ignoreKeys || this.includeKeys) {
        log = filterLog({ log, context: this.context });
      }
      const prettifiedLevel = prettifyLevel({
        log,
        context: {
          ...this.context,
          // This is odd. The colorizer ends up relying on the value of
          // `customProperties` instead of the original `customLevels` and
          // `customLevelNames`.
          ...this.context.customProperties
        }
      });
      const prettifiedMetadata = prettifyMetadata({ log, context: this.context });
      const prettifiedTime = prettifyTime({ log, context: this.context });
      let line = "";
      if (this.levelFirst && prettifiedLevel) {
        line = `${prettifiedLevel}`;
      }
      if (prettifiedTime && line === "") {
        line = `${prettifiedTime}`;
      } else if (prettifiedTime) {
        line = `${line} ${prettifiedTime}`;
      }
      if (!this.levelFirst && prettifiedLevel) {
        if (line.length > 0) {
          line = `${line} ${prettifiedLevel}`;
        } else {
          line = prettifiedLevel;
        }
      }
      if (prettifiedMetadata) {
        if (line.length > 0) {
          line = `${line} ${prettifiedMetadata}:`;
        } else {
          line = prettifiedMetadata;
        }
      }
      if (line.endsWith(":") === false && line !== "") {
        line += ":";
      }
      if (prettifiedMessage !== void 0) {
        if (line.length > 0) {
          line = `${line} ${prettifiedMessage}`;
        } else {
          line = prettifiedMessage;
        }
      }
      if (line.length > 0 && !this.singleLine) {
        line += this.EOL;
      }
      if (log.type === "Error" && typeof log.stack === "string") {
        const prettifiedErrorLog = prettifyErrorLog({ log, context: this.context });
        if (this.singleLine) line += this.EOL;
        line += prettifiedErrorLog;
      } else if (this.hideObject === false) {
        const skipKeys = [
          this.messageKey,
          this.levelKey,
          this.timestampKey
        ].map((key) => key.replaceAll(/\\/g, "")).filter((key) => {
          return typeof log[key] === "string" || typeof log[key] === "number" || typeof log[key] === "boolean";
        });
        const prettifiedObject = prettifyObject({
          log,
          skipKeys,
          context: this.context
        });
        if (this.singleLine && !/^\s$/.test(prettifiedObject)) {
          line += " ";
        }
        line += prettifiedObject;
      }
      return line;
    }
  }
});

// node_modules/pino-pretty/index.js
var require_pino_pretty = __commonJS({
  "node_modules/pino-pretty/index.js"(exports, module) {
    "use strict";
    var { isColorSupported } = require_colorette();
    var pump = require_pump();
    var { Transform } = __require("stream");
    var abstractTransport = require_pino_abstract_transport();
    var colors = require_colors();
    var {
      ERROR_LIKE_KEYS,
      LEVEL_KEY,
      LEVEL_LABEL,
      MESSAGE_KEY,
      TIMESTAMP_KEY
    } = require_constants2();
    var {
      buildSafeSonicBoom,
      parseFactoryOptions
    } = require_utils();
    var pretty2 = require_pretty();
    var defaultOptions = {
      colorize: isColorSupported,
      colorizeObjects: true,
      crlf: false,
      customColors: null,
      customLevels: null,
      customPrettifiers: {},
      errorLikeObjectKeys: ERROR_LIKE_KEYS,
      errorProps: "",
      hideObject: false,
      ignore: "hostname",
      include: void 0,
      levelFirst: false,
      levelKey: LEVEL_KEY,
      levelLabel: LEVEL_LABEL,
      messageFormat: null,
      messageKey: MESSAGE_KEY,
      minimumLevel: void 0,
      outputStream: process.stdout,
      singleLine: false,
      timestampKey: TIMESTAMP_KEY,
      translateTime: true,
      useOnlyCustomProps: true
    };
    function prettyFactory(options) {
      const context = parseFactoryOptions(Object.assign({}, defaultOptions, options));
      return pretty2.bind({ ...context, context });
    }
    function build(opts = {}) {
      let pretty3 = prettyFactory(opts);
      let destination;
      return abstractTransport(function(source) {
        source.on("message", function pinoConfigListener(message) {
          if (!message || message.code !== "PINO_CONFIG") return;
          Object.assign(opts, {
            messageKey: message.config.messageKey,
            errorLikeObjectKeys: Array.from(/* @__PURE__ */ new Set([...opts.errorLikeObjectKeys || ERROR_LIKE_KEYS, message.config.errorKey])),
            customLevels: message.config.levels.values
          });
          pretty3 = prettyFactory(opts);
          source.off("message", pinoConfigListener);
        });
        const stream2 = new Transform({
          objectMode: true,
          autoDestroy: true,
          transform(chunk, enc, cb) {
            const line = pretty3(chunk);
            cb(null, line);
          }
        });
        if (typeof opts.destination === "object" && typeof opts.destination.write === "function") {
          destination = opts.destination;
        } else {
          destination = buildSafeSonicBoom({
            dest: opts.destination || 1,
            append: opts.append,
            mkdir: opts.mkdir,
            sync: opts.sync
            // by default sonic will be async
          });
        }
        source.on("unknown", function(line) {
          destination.write(line + "\n");
        });
        pump(source, stream2, destination);
        return stream2;
      }, {
        parse: "lines",
        close(err, cb) {
          destination.on("close", () => {
            cb(err);
          });
        }
      });
    }
    module.exports = build;
    module.exports.build = build;
    module.exports.PinoPretty = build;
    module.exports.prettyFactory = prettyFactory;
    module.exports.colorizerFactory = colors;
    module.exports.isColorSupported = isColorSupported;
    module.exports.default = build;
  }
});

// node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/tarn/dist/TimeoutError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "node_modules/tarn/dist/PromiseInspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports.PromiseInspection = PromiseInspection;
  }
});

// node_modules/tarn/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/tarn/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports.defer = defer;
    function now() {
      return Date.now();
    }
    exports.now = now;
    function duration(t1, t22) {
      return Math.abs(t22 - t1);
    }
    exports.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports.checkRequiredTime = checkRequiredTime;
    function delay(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports.delay = delay;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports.tryPromise = tryPromise;
  }
});

// node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "node_modules/tarn/dist/PendingOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils2();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "node_modules/tarn/dist/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports.Resource = Resource;
  }
});

// node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "node_modules/tarn/dist/Pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils2();
    var events_1 = __require("events");
    var timers_1 = __require("timers");
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i3 = 0, l3 = this.used.length; i3 < l3; ++i3) {
          const used = this.used[i3];
          if (used.resource === resource) {
            this.used.splice(i3, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "node_modules/tarn/dist/tarn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    module.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// node_modules/knex/lib/util/string.js
var require_string = __commonJS({
  "node_modules/knex/lib/util/string.js"(exports, module) {
    var charsRegex = /[\0\b\t\n\r\x1a"'\\]/g;
    var charsMap = {
      "\0": "\\0",
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "": "\\Z",
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\"
    };
    function wrapEscape(escapeFn) {
      return function finalEscape(val2, ctx = {}) {
        return escapeFn(val2, finalEscape, ctx);
      };
    }
    function makeEscape(config = {}) {
      const finalEscapeDate = config.escapeDate || dateToString;
      const finalEscapeArray = config.escapeArray || arrayToList;
      const finalEscapeBuffer = config.escapeBuffer || bufferToString;
      const finalEscapeString = config.escapeString || escapeString;
      const finalEscapeObject = config.escapeObject || escapeObject;
      const finalWrap = config.wrap || wrapEscape;
      function escapeFn(val2, finalEscape, ctx) {
        if (val2 === void 0 || val2 === null) {
          return "NULL";
        }
        switch (typeof val2) {
          case "boolean":
            return val2 ? "true" : "false";
          case "number":
            return val2 + "";
          case "object":
            if (val2 instanceof Date) {
              val2 = finalEscapeDate(val2, finalEscape, ctx);
            } else if (Array.isArray(val2)) {
              return finalEscapeArray(val2, finalEscape, ctx);
            } else if (Buffer.isBuffer(val2)) {
              return finalEscapeBuffer(val2, finalEscape, ctx);
            } else {
              return finalEscapeObject(val2, finalEscape, ctx);
            }
        }
        return finalEscapeString(val2, finalEscape, ctx);
      }
      return finalWrap ? finalWrap(escapeFn) : escapeFn;
    }
    function escapeObject(val2, finalEscape, ctx) {
      if (val2 && typeof val2.toSQL === "function") {
        return val2.toSQL(ctx);
      } else {
        return JSON.stringify(val2);
      }
    }
    function arrayToList(array, finalEscape, ctx) {
      let sql = "";
      for (let i3 = 0; i3 < array.length; i3++) {
        const val2 = array[i3];
        if (Array.isArray(val2)) {
          sql += (i3 === 0 ? "" : ", ") + "(" + arrayToList(val2, finalEscape, ctx) + ")";
        } else {
          sql += (i3 === 0 ? "" : ", ") + finalEscape(val2, ctx);
        }
      }
      return sql;
    }
    function bufferToString(buffer) {
      return "X" + escapeString(buffer.toString("hex"));
    }
    function escapeString(val2, finalEscape, ctx) {
      let chunkIndex = charsRegex.lastIndex = 0;
      let escapedVal = "";
      let match;
      while (match = charsRegex.exec(val2)) {
        escapedVal += val2.slice(chunkIndex, match.index) + charsMap[match[0]];
        chunkIndex = charsRegex.lastIndex;
      }
      if (chunkIndex === 0) {
        return "'" + val2 + "'";
      }
      if (chunkIndex < val2.length) {
        return "'" + escapedVal + val2.slice(chunkIndex) + "'";
      }
      return "'" + escapedVal + "'";
    }
    function dateToString(date, finalEscape, ctx = {}) {
      const timeZone = ctx.timeZone || "local";
      const dt = new Date(date);
      let year;
      let month;
      let day;
      let hour;
      let minute;
      let second;
      let millisecond;
      if (timeZone === "local") {
        year = dt.getFullYear();
        month = dt.getMonth() + 1;
        day = dt.getDate();
        hour = dt.getHours();
        minute = dt.getMinutes();
        second = dt.getSeconds();
        millisecond = dt.getMilliseconds();
      } else {
        const tz = convertTimezone(timeZone);
        if (tz !== false && tz !== 0) {
          dt.setTime(dt.getTime() + tz * 6e4);
        }
        year = dt.getUTCFullYear();
        month = dt.getUTCMonth() + 1;
        day = dt.getUTCDate();
        hour = dt.getUTCHours();
        minute = dt.getUTCMinutes();
        second = dt.getUTCSeconds();
        millisecond = dt.getUTCMilliseconds();
      }
      return zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    }
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = "0" + number;
      }
      return number;
    }
    function convertTimezone(tz) {
      if (tz === "Z") {
        return 0;
      }
      const m3 = tz.match(/([+\-\s])(\d\d):?(\d\d)?/);
      if (m3) {
        return (m3[1] == "-" ? -1 : 1) * (parseInt(m3[2], 10) + (m3[3] ? parseInt(m3[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
    module.exports = {
      arrayToList,
      bufferToString,
      dateToString,
      escapeString,
      charsRegex,
      charsMap,
      escapeObject,
      makeEscape
    };
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex2 = data.length - 1;
      if (index == lastIndex2) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash3(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash3.prototype.clear = hashClear;
    Hash3.prototype["delete"] = hashDelete;
    Hash3.prototype.get = hashGet;
    Hash3.prototype.has = hashHas;
    Hash3.prototype.set = hashSet;
    module.exports = Hash3;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash3 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash3(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash3()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e3) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module.exports = defaults;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    module.exports = uniqueId;
  }
});

// node_modules/knex/lib/util/timeout.js
var require_timeout = __commonJS({
  "node_modules/knex/lib/util/timeout.js"(exports, module) {
    var KnexTimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "KnexTimeoutError";
      }
    };
    function timeout(promise, ms) {
      return new Promise(function(resolve, reject) {
        const id = setTimeout(function() {
          reject(new KnexTimeoutError("operation timed out"));
        }, ms);
        function wrappedResolve(value) {
          clearTimeout(id);
          resolve(value);
        }
        function wrappedReject(err) {
          clearTimeout(id);
          reject(err);
        }
        promise.then(wrappedResolve, wrappedReject);
      });
    }
    module.exports.KnexTimeoutError = KnexTimeoutError;
    module.exports.timeout = timeout;
  }
});

// node_modules/knex/lib/execution/internal/ensure-connection-callback.js
var require_ensure_connection_callback = __commonJS({
  "node_modules/knex/lib/execution/internal/ensure-connection-callback.js"(exports, module) {
    function ensureConnectionCallback(runner) {
      runner.client.emit("start", runner.builder);
      runner.builder.emit("start", runner.builder);
      const sql = runner.builder.toSQL();
      if (runner.builder._debug) {
        runner.client.logger.debug(sql);
      }
      if (Array.isArray(sql)) {
        return runner.queryArray(sql);
      }
      return runner.query(sql);
    }
    function ensureConnectionStreamCallback(runner, params) {
      try {
        const sql = runner.builder.toSQL();
        if (Array.isArray(sql) && params.hasHandler) {
          throw new Error(
            "The stream may only be used with a single query statement."
          );
        }
        return runner.client.stream(
          runner.connection,
          sql,
          params.stream,
          params.options
        );
      } catch (e3) {
        params.stream.emit("error", e3);
        throw e3;
      }
    }
    module.exports = {
      ensureConnectionCallback,
      ensureConnectionStreamCallback
    };
  }
});

// node_modules/knex/lib/execution/runner.js
var require_runner = __commonJS({
  "node_modules/knex/lib/execution/runner.js"(exports, module) {
    var { KnexTimeoutError } = require_timeout();
    var { timeout } = require_timeout();
    var {
      ensureConnectionCallback,
      ensureConnectionStreamCallback
    } = require_ensure_connection_callback();
    var Transform;
    var Runner = class _Runner {
      constructor(client, builder) {
        this.client = client;
        this.builder = builder;
        this.queries = [];
        this.connection = void 0;
      }
      // "Run" the target, calling "toSQL" on the builder, returning
      // an object or array of queries to run, each of which are run on
      // a single connection.
      async run() {
        const runner = this;
        try {
          const res = await this.ensureConnection(ensureConnectionCallback);
          runner.builder.emit("end");
          return res;
        } catch (err) {
          if (runner.builder._events && runner.builder._events.error) {
            runner.builder.emit("error", err);
          }
          throw err;
        }
      }
      // Stream the result set, by passing through to the dialect's streaming
      // capabilities. If the options are
      stream(optionsOrHandler, handlerOrNil) {
        const firstOptionIsHandler = typeof optionsOrHandler === "function" && arguments.length === 1;
        const options = firstOptionIsHandler ? {} : optionsOrHandler;
        const handler2 = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;
        const hasHandler = typeof handler2 === "function";
        Transform = Transform || __require("stream").Transform;
        const queryContext = this.builder.queryContext();
        const stream2 = new Transform({
          objectMode: true,
          transform: (chunk, _2, callback) => {
            callback(null, this.client.postProcessResponse(chunk, queryContext));
          }
        });
        stream2.on("close", () => {
          this.client.releaseConnection(this.connection);
        });
        stream2.on("pipe", (sourceStream) => {
          const cleanSourceStream = () => {
            if (!sourceStream.closed) {
              sourceStream.destroy();
            }
          };
          if (stream2.closed) {
            cleanSourceStream();
          } else {
            stream2.on("close", cleanSourceStream);
          }
        });
        const connectionAcquirePromise = this.ensureConnection(
          ensureConnectionStreamCallback,
          {
            options,
            hasHandler,
            stream: stream2
          }
        ).catch((err) => {
          if (!this.connection) {
            stream2.emit("error", err);
          }
        });
        if (hasHandler) {
          handler2(stream2);
          return connectionAcquirePromise;
        }
        return stream2;
      }
      // Allow you to pipe the stream to a writable stream.
      pipe(writable, options) {
        return this.stream(options).pipe(writable);
      }
      // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
      // to run in sequence, and on the same connection, especially helpful when schema building
      // and dealing with foreign key constraints, etc.
      async query(obj) {
        const { __knexUid, __knexTxId } = this.connection;
        this.builder.emit("query", Object.assign({ __knexUid, __knexTxId }, obj));
        const runner = this;
        const queryContext = this.builder.queryContext();
        if (obj !== null && typeof obj === "object") {
          obj.queryContext = queryContext;
        }
        let queryPromise = this.client.query(this.connection, obj);
        if (obj.timeout) {
          queryPromise = timeout(queryPromise, obj.timeout);
        }
        return queryPromise.then((resp) => this.client.processResponse(resp, runner)).then((processedResponse) => {
          const postProcessedResponse = this.client.postProcessResponse(
            processedResponse,
            queryContext
          );
          this.builder.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          this.client.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          return postProcessedResponse;
        }).catch((error) => {
          if (!(error instanceof KnexTimeoutError)) {
            return Promise.reject(error);
          }
          const { timeout: timeout2, sql, bindings } = obj;
          let cancelQuery;
          if (obj.cancelOnTimeout) {
            cancelQuery = this.client.cancelQuery(this.connection);
          } else {
            this.connection.__knex__disposed = error;
            cancelQuery = Promise.resolve();
          }
          return cancelQuery.catch((cancelError) => {
            this.connection.__knex__disposed = error;
            throw Object.assign(cancelError, {
              message: `After query timeout of ${timeout2}ms exceeded, cancelling of query failed.`,
              sql,
              bindings,
              timeout: timeout2
            });
          }).then(() => {
            throw Object.assign(error, {
              message: `Defined query timeout of ${timeout2}ms exceeded when running query.`,
              sql,
              bindings,
              timeout: timeout2
            });
          });
        }).catch((error) => {
          this.builder.emit(
            "query-error",
            error,
            Object.assign({ __knexUid, __knexTxId, queryContext }, obj)
          );
          throw error;
        });
      }
      // In the case of the "schema builder" we call `queryArray`, which runs each
      // of the queries in sequence.
      async queryArray(queries) {
        if (queries.length === 1) {
          const query = queries[0];
          if (!query.statementsProducer) {
            return this.query(query);
          }
          const statements = await query.statementsProducer(
            void 0,
            this.connection
          );
          const sqlQueryObjects = statements.sql.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          const preQueryObjects = statements.pre.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          const postQueryObjects = statements.post.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          let results2 = [];
          await this.queryArray(preQueryObjects);
          try {
            await this.client.transaction(
              async (trx) => {
                const transactionRunner = new _Runner(trx.client, this.builder);
                transactionRunner.connection = this.connection;
                results2 = await transactionRunner.queryArray(sqlQueryObjects);
                if (statements.check) {
                  const foreignViolations = await trx.raw(statements.check);
                  if (foreignViolations.length > 0) {
                    throw new Error("FOREIGN KEY constraint failed");
                  }
                }
              },
              { connection: this.connection }
            );
          } finally {
            await this.queryArray(postQueryObjects);
          }
          return results2;
        }
        const results = [];
        for (const query of queries) {
          results.push(await this.queryArray([query]));
        }
        return results;
      }
      // Check whether there's a transaction flag, and that it has a connection.
      async ensureConnection(cb, cbParams) {
        if (this.builder._connection) {
          this.connection = this.builder._connection;
        }
        if (this.connection) {
          return cb(this, cbParams);
        }
        let acquiredConnection;
        try {
          acquiredConnection = await this.client.acquireConnection();
        } catch (error) {
          if (!(error instanceof KnexTimeoutError)) {
            return Promise.reject(error);
          }
          if (this.builder) {
            error.sql = this.builder.sql;
            error.bindings = this.builder.bindings;
          }
          throw error;
        }
        try {
          this.connection = acquiredConnection;
          return await cb(this, cbParams);
        } finally {
          await this.client.releaseConnection(acquiredConnection);
        }
      }
    };
    module.exports = Runner;
  }
});

// node_modules/knex/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/knex/node_modules/ms/index.js"(exports, module) {
    var s3 = 1e3;
    var m3 = s3 * 60;
    var h3 = m3 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y2 = d3 * 365.25;
    module.exports = function(val2, options) {
      options = options || {};
      var type = typeof val2;
      if (type === "string" && val2.length > 0) {
        return parse4(val2);
      } else if (type === "number" && isFinite(val2)) {
        return options.long ? fmtLong(val2) : fmtShort(val2);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val2)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y2;
        case "weeks":
        case "week":
        case "w":
          return n3 * w3;
        case "days":
        case "day":
        case "d":
          return n3 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms, msAbs, s3, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms / n3) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/knex/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/knex/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val2 = args[index];
              match = formatter.call(self2, val2);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v6) => {
            enableOverride = v6;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i3;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i3 = 0; i3 < len; i3++) {
          if (!split[i3]) {
            continue;
          }
          namespaces = split[i3].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i3;
        let len;
        for (i3 = 0, len = createDebug.skips.length; i3 < len; i3++) {
          if (createDebug.skips[i3].test(name)) {
            return false;
          }
        }
        for (i3 = 0, len = createDebug.names.length; i3 < len; i3++) {
          if (createDebug.names[i3].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val2) {
        if (val2 instanceof Error) {
          return val2.stack || val2.message;
        }
        return val2;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/knex/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/knex/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r3;
      try {
        r3 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v6) {
      try {
        return JSON.stringify(v6);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream2) {
      const level = supportsColor(stream2, stream2 && stream2.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/knex/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/knex/node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util2 = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
        return k3.toUpperCase();
      });
      let val2 = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val2)) {
        val2 = true;
      } else if (/^(no|off|false|disabled)$/i.test(val2)) {
        val2 = false;
      } else if (val2 === "null") {
        val2 = null;
      } else {
        val2 = Number(val2);
      }
      obj[prop] = val2;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i3 = 0; i3 < keys.length; i3++) {
        debug.inspectOpts[keys[i3]] = exports.inspectOpts[keys[i3]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v6) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v6, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v6) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v6, this.inspectOpts);
    };
  }
});

// node_modules/knex/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/knex/node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache3, key) {
      return cache3.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module.exports = last;
  }
});

// node_modules/lodash/differenceWith.js
var require_differenceWith = __commonJS({
  "node_modules/lodash/differenceWith.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var last = require_last();
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = void 0;
      }
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), void 0, comparator) : [];
    });
    module.exports = differenceWith;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
        if (cache3.has(key)) {
          return cache3.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache3.set(key, result) || cache3;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache3.size === MAX_MEMOIZE_SIZE) {
          cache3.clear();
        }
        return key;
      });
      var cache3 = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get2;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module.exports = isEmpty;
  }
});

// node_modules/lodash/_baseExtremum.js
var require_baseExtremum = __commonJS({
  "node_modules/lodash/_baseExtremum.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function baseExtremum(array, iteratee, comparator) {
      var index = -1, length = array.length;
      while (++index < length) {
        var value = array[index], current = iteratee(value);
        if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
          var computed = current, result = value;
        }
      }
      return result;
    }
    module.exports = baseExtremum;
  }
});

// node_modules/lodash/_baseGt.js
var require_baseGt = __commonJS({
  "node_modules/lodash/_baseGt.js"(exports, module) {
    function baseGt(value, other) {
      return value > other;
    }
    module.exports = baseGt;
  }
});

// node_modules/lodash/max.js
var require_max = __commonJS({
  "node_modules/lodash/max.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseGt = require_baseGt();
    var identity = require_identity();
    function max(array) {
      return array && array.length ? baseExtremum(array, identity, baseGt) : void 0;
    }
    module.exports = max;
  }
});

// node_modules/knex/lib/migrations/migrate/table-resolver.js
var require_table_resolver = __commonJS({
  "node_modules/knex/lib/migrations/migrate/table-resolver.js"(exports, module) {
    function getTableName(tableName, schemaName) {
      return schemaName ? `${schemaName}.${tableName}` : tableName;
    }
    function getTable(trxOrKnex, tableName, schemaName) {
      return schemaName ? trxOrKnex(tableName).withSchema(schemaName) : trxOrKnex(tableName);
    }
    function getLockTableName(tableName) {
      return tableName + "_lock";
    }
    function getLockTableNameWithSchema(tableName, schemaName) {
      return schemaName ? schemaName + "." + getLockTableName(tableName) : getLockTableName(tableName);
    }
    module.exports = {
      getLockTableName,
      getLockTableNameWithSchema,
      getTable,
      getTableName
    };
  }
});

// node_modules/knex/lib/migrations/migrate/table-creator.js
var require_table_creator = __commonJS({
  "node_modules/knex/lib/migrations/migrate/table-creator.js"(exports, module) {
    var {
      getTable,
      getLockTableName,
      getLockTableNameWithSchema,
      getTableName
    } = require_table_resolver();
    function ensureTable(tableName, schemaName, trxOrKnex) {
      const lockTable = getLockTableName(tableName);
      return getSchemaBuilder(trxOrKnex, schemaName).hasTable(tableName).then((exists) => {
        return !exists && _createMigrationTable(tableName, schemaName, trxOrKnex);
      }).then(() => {
        return getSchemaBuilder(trxOrKnex, schemaName).hasTable(lockTable);
      }).then((exists) => {
        return !exists && _createMigrationLockTable(lockTable, schemaName, trxOrKnex);
      }).then(() => {
        return getTable(trxOrKnex, lockTable, schemaName).select("*");
      }).then((data) => {
        return !data.length && _insertLockRowIfNeeded(tableName, schemaName, trxOrKnex);
      });
    }
    function _createMigrationTable(tableName, schemaName, trxOrKnex) {
      return getSchemaBuilder(trxOrKnex, schemaName).createTable(
        getTableName(tableName),
        function(t3) {
          t3.increments();
          t3.string("name");
          t3.integer("batch");
          t3.timestamp("migration_time");
        }
      );
    }
    function _createMigrationLockTable(tableName, schemaName, trxOrKnex) {
      return getSchemaBuilder(trxOrKnex, schemaName).createTable(
        tableName,
        function(t3) {
          t3.increments("index").primary();
          t3.integer("is_locked");
        }
      );
    }
    function _insertLockRowIfNeeded(tableName, schemaName, trxOrKnex) {
      const lockTableWithSchema = getLockTableNameWithSchema(tableName, schemaName);
      return trxOrKnex.select("*").from(lockTableWithSchema).then((data) => {
        return !data.length ? trxOrKnex.from(lockTableWithSchema).insert({ is_locked: 0 }) : null;
      });
    }
    function getSchemaBuilder(trxOrKnex, schemaName) {
      return schemaName ? trxOrKnex.schema.withSchema(schemaName) : trxOrKnex.schema;
    }
    module.exports = {
      ensureTable,
      getSchemaBuilder
    };
  }
});

// node_modules/knex/lib/migrations/migrate/migration-list-resolver.js
var require_migration_list_resolver = __commonJS({
  "node_modules/knex/lib/migrations/migrate/migration-list-resolver.js"(exports, module) {
    var { getTableName } = require_table_resolver();
    var { ensureTable } = require_table_creator();
    function listAll(migrationSource, loadExtensions) {
      return migrationSource.getMigrations(loadExtensions);
    }
    async function listCompleted(tableName, schemaName, trxOrKnex) {
      await ensureTable(tableName, schemaName, trxOrKnex);
      return await trxOrKnex.from(getTableName(tableName, schemaName)).orderBy("id").select("name");
    }
    function listAllAndCompleted(config, trxOrKnex) {
      return Promise.all([
        listAll(config.migrationSource, config.loadExtensions),
        listCompleted(config.tableName, config.schemaName, trxOrKnex)
      ]);
    }
    module.exports = {
      listAll,
      listAllAndCompleted,
      listCompleted
    };
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/assignInWith.js
var require_assignInWith = __commonJS({
  "node_modules/lodash/assignInWith.js"(exports, module) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    module.exports = assignInWith;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/isError.js
var require_isError = __commonJS({
  "node_modules/lodash/isError.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var isPlainObject = require_isPlainObject();
    var domExcTag = "[object DOMException]";
    var errorTag = "[object Error]";
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
    }
    module.exports = isError;
  }
});

// node_modules/lodash/attempt.js
var require_attempt = __commonJS({
  "node_modules/lodash/attempt.js"(exports, module) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var isError = require_isError();
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, void 0, args);
      } catch (e3) {
        return isError(e3) ? e3 : new Error(e3);
      }
    });
    module.exports = attempt;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module.exports = baseValues;
  }
});

// node_modules/lodash/_customDefaultsAssignIn.js
var require_customDefaultsAssignIn = __commonJS({
  "node_modules/lodash/_customDefaultsAssignIn.js"(exports, module) {
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    module.exports = customDefaultsAssignIn;
  }
});

// node_modules/lodash/_escapeStringChar.js
var require_escapeStringChar = __commonJS({
  "node_modules/lodash/_escapeStringChar.js"(exports, module) {
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    module.exports = escapeStringChar;
  }
});

// node_modules/lodash/_reInterpolate.js
var require_reInterpolate = __commonJS({
  "node_modules/lodash/_reInterpolate.js"(exports, module) {
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    module.exports = reInterpolate;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module) {
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = basePropertyOf;
  }
});

// node_modules/lodash/_escapeHtmlChar.js
var require_escapeHtmlChar = __commonJS({
  "node_modules/lodash/_escapeHtmlChar.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    module.exports = escapeHtmlChar;
  }
});

// node_modules/lodash/escape.js
var require_escape = __commonJS({
  "node_modules/lodash/escape.js"(exports, module) {
    var escapeHtmlChar = require_escapeHtmlChar();
    var toString = require_toString();
    var reUnescapedHtml = /[&<>"']/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
      string = toString(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape;
  }
});

// node_modules/lodash/_reEscape.js
var require_reEscape = __commonJS({
  "node_modules/lodash/_reEscape.js"(exports, module) {
    var reEscape = /<%-([\s\S]+?)%>/g;
    module.exports = reEscape;
  }
});

// node_modules/lodash/_reEvaluate.js
var require_reEvaluate = __commonJS({
  "node_modules/lodash/_reEvaluate.js"(exports, module) {
    var reEvaluate = /<%([\s\S]+?)%>/g;
    module.exports = reEvaluate;
  }
});

// node_modules/lodash/templateSettings.js
var require_templateSettings = __commonJS({
  "node_modules/lodash/templateSettings.js"(exports, module) {
    var escape = require_escape();
    var reEscape = require_reEscape();
    var reEvaluate = require_reEvaluate();
    var reInterpolate = require_reInterpolate();
    var templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "escape": reEscape,
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "evaluate": reEvaluate,
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "interpolate": reInterpolate,
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      "variable": "",
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      "imports": {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        "_": { "escape": escape }
      }
    };
    module.exports = templateSettings;
  }
});

// node_modules/lodash/template.js
var require_template = __commonJS({
  "node_modules/lodash/template.js"(exports, module) {
    var assignInWith = require_assignInWith();
    var attempt = require_attempt();
    var baseValues = require_baseValues();
    var customDefaultsAssignIn = require_customDefaultsAssignIn();
    var escapeStringChar = require_escapeStringChar();
    var isError = require_isError();
    var isIterateeCall = require_isIterateeCall();
    var keys = require_keys();
    var reInterpolate = require_reInterpolate();
    var templateSettings = require_templateSettings();
    var toString = require_toString();
    var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var reEmptyStringLeading = /\b__p \+= '';/g;
    var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
    var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function template(string, options, guard) {
      var settings = templateSettings.imports._.templateSettings || templateSettings;
      if (guard && isIterateeCall(string, options, guard)) {
        options = void 0;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);
      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
      var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
        "g"
      );
      var sourceURL = hasOwnProperty.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";
      var variable = hasOwnProperty.call(options, "variable") && options.variable;
      if (!variable) {
        source = "with (obj) {\n" + source + "\n}\n";
      } else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
      source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
      var result = attempt(function() {
        return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
      });
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }
    module.exports = template;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/knex/lib/migrations/util/fs.js
var require_fs = __commonJS({
  "node_modules/knex/lib/migrations/util/fs.js"(exports, module) {
    var fs = __require("fs");
    var flatten = require_flatten();
    var os = __require("os");
    var path = __require("path");
    var { promisify } = __require("util");
    var stat = promisify(fs.stat);
    var readFile = promisify(fs.readFile);
    var writeFile = promisify(fs.writeFile);
    var readdir = promisify(fs.readdir);
    var mkdir = promisify(fs.mkdir);
    function existsSync(path2) {
      try {
        fs.accessSync(path2);
        return true;
      } catch (e3) {
        return false;
      }
    }
    function createTemp() {
      return promisify(fs.mkdtemp)(`${os.tmpdir()}${path.sep}`);
    }
    function ensureDirectoryExists(dir) {
      return stat(dir).catch(() => mkdir(dir, { recursive: true }));
    }
    async function getFilepathsInFolder(dir, recursive = false) {
      const pathsList = await readdir(dir);
      return flatten(
        await Promise.all(
          pathsList.sort().map(async (currentPath) => {
            const currentFile = path.resolve(dir, currentPath);
            const statFile = await stat(currentFile);
            if (statFile && statFile.isDirectory()) {
              if (recursive) {
                return await getFilepathsInFolder(currentFile, true);
              }
              return [];
            }
            return [currentFile];
          })
        )
      );
    }
    module.exports = {
      existsSync,
      stat,
      readdir,
      readFile,
      writeFile,
      createTemp,
      ensureDirectoryExists,
      getFilepathsInFolder
    };
  }
});

// node_modules/knex/lib/migrations/util/template.js
var require_template2 = __commonJS({
  "node_modules/knex/lib/migrations/util/template.js"(exports, module) {
    var template = require_template();
    var { readFile, writeFile } = require_fs();
    var jsSourceTemplate = (content, options) => template(content, {
      interpolate: /<%=([\s\S]+?)%>/g,
      ...options
    });
    var jsFileTemplate = async (filePath, options) => {
      const contentBuffer = await readFile(filePath);
      return jsSourceTemplate(contentBuffer.toString(), options);
    };
    var writeJsFileUsingTemplate = async (targetFilePath, sourceFilePath, options, variables) => writeFile(
      targetFilePath,
      (await jsFileTemplate(sourceFilePath, options))(variables)
    );
    module.exports = {
      jsSourceTemplate,
      jsFileTemplate,
      writeJsFileUsingTemplate
    };
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get2 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get2(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports, module) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports, module) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module.exports = baseMap;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/get-package-type/is-node-modules.cjs
var require_is_node_modules = __commonJS({
  "node_modules/get-package-type/is-node-modules.cjs"(exports, module) {
    "use strict";
    var path = __require("path");
    function isNodeModules(directory) {
      let basename = path.basename(directory);
      if (path.sep === "\\") {
        basename = basename.toLowerCase();
      }
      return basename === "node_modules";
    }
    module.exports = isNodeModules;
  }
});

// node_modules/get-package-type/cache.cjs
var require_cache = __commonJS({
  "node_modules/get-package-type/cache.cjs"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Map();
  }
});

// node_modules/get-package-type/async.cjs
var require_async = __commonJS({
  "node_modules/get-package-type/async.cjs"(exports, module) {
    "use strict";
    var path = __require("path");
    var { promisify } = __require("util");
    var readFile = promisify(__require("fs").readFile);
    var isNodeModules = require_is_node_modules();
    var resultsCache = require_cache();
    var promiseCache = /* @__PURE__ */ new Map();
    async function getDirectoryTypeActual(directory) {
      if (isNodeModules(directory)) {
        return "commonjs";
      }
      try {
        return JSON.parse(await readFile(path.resolve(directory, "package.json"))).type || "commonjs";
      } catch (_2) {
      }
      const parent = path.dirname(directory);
      if (parent === directory) {
        return "commonjs";
      }
      return getDirectoryType(parent);
    }
    async function getDirectoryType(directory) {
      if (resultsCache.has(directory)) {
        return resultsCache.get(directory);
      }
      if (promiseCache.has(directory)) {
        return promiseCache.get(directory);
      }
      const promise = getDirectoryTypeActual(directory);
      promiseCache.set(directory, promise);
      const result = await promise;
      resultsCache.set(directory, result);
      promiseCache.delete(directory);
      return result;
    }
    function getPackageType(filename) {
      return getDirectoryType(path.resolve(path.dirname(filename)));
    }
    module.exports = getPackageType;
  }
});

// node_modules/get-package-type/sync.cjs
var require_sync = __commonJS({
  "node_modules/get-package-type/sync.cjs"(exports, module) {
    "use strict";
    var path = __require("path");
    var { readFileSync } = __require("fs");
    var isNodeModules = require_is_node_modules();
    var resultsCache = require_cache();
    function getDirectoryTypeActual(directory) {
      if (isNodeModules(directory)) {
        return "commonjs";
      }
      try {
        return JSON.parse(readFileSync(path.resolve(directory, "package.json"))).type || "commonjs";
      } catch (_2) {
      }
      const parent = path.dirname(directory);
      if (parent === directory) {
        return "commonjs";
      }
      return getDirectoryType(parent);
    }
    function getDirectoryType(directory) {
      if (resultsCache.has(directory)) {
        return resultsCache.get(directory);
      }
      const result = getDirectoryTypeActual(directory);
      resultsCache.set(directory, result);
      return result;
    }
    function getPackageTypeSync(filename) {
      return getDirectoryType(path.resolve(path.dirname(filename)));
    }
    module.exports = getPackageTypeSync;
  }
});

// node_modules/get-package-type/index.cjs
var require_get_package_type = __commonJS({
  "node_modules/get-package-type/index.cjs"(exports, module) {
    "use strict";
    var getPackageType = require_async();
    var getPackageTypeSync = require_sync();
    module.exports = (filename) => getPackageType(filename);
    module.exports.sync = getPackageTypeSync;
  }
});

// node_modules/knex/lib/migrations/util/is-module-type.js
var require_is_module_type = __commonJS({
  "node_modules/knex/lib/migrations/util/is-module-type.js"(exports, module) {
    var getPackageType = require_get_package_type();
    module.exports = async function isModuleType(filepath) {
      return filepath.endsWith(".mjs") || !filepath.endsWith(".cjs") && await getPackageType(filepath) === "module";
    };
  }
});

// node_modules/knex/lib/migrations/util/import-file.js
var require_import_file = __commonJS({
  "node_modules/knex/lib/migrations/util/import-file.js"(exports, module) {
    var isModuleType = require_is_module_type();
    module.exports = async function importFile(filepath) {
      return await isModuleType(filepath) ? import(__require("url").pathToFileURL(filepath)) : __require(filepath);
    };
  }
});

// node_modules/knex/lib/migrations/common/MigrationsLoader.js
var require_MigrationsLoader = __commonJS({
  "node_modules/knex/lib/migrations/common/MigrationsLoader.js"(exports, module) {
    var path = __require("path");
    var DEFAULT_LOAD_EXTENSIONS = Object.freeze([
      ".co",
      ".coffee",
      ".eg",
      ".iced",
      ".js",
      ".cjs",
      ".litcoffee",
      ".ls",
      ".ts"
    ]);
    var AbstractMigrationsLoader = class {
      constructor(migrationDirectories, sortDirsSeparately, loadExtensions) {
        this.sortDirsSeparately = sortDirsSeparately;
        if (!Array.isArray(migrationDirectories)) {
          migrationDirectories = [migrationDirectories];
        }
        this.migrationsPaths = migrationDirectories;
        this.loadExtensions = loadExtensions || DEFAULT_LOAD_EXTENSIONS;
      }
      getFile(migrationsInfo) {
        const absoluteDir = path.resolve(process.cwd(), migrationsInfo.directory);
        const _path = path.join(absoluteDir, migrationsInfo.file);
        const importFile = require_import_file();
        return importFile(_path);
      }
    };
    module.exports = {
      DEFAULT_LOAD_EXTENSIONS,
      AbstractMigrationsLoader
    };
  }
});

// node_modules/knex/lib/migrations/migrate/sources/fs-migrations.js
var require_fs_migrations = __commonJS({
  "node_modules/knex/lib/migrations/migrate/sources/fs-migrations.js"(exports, module) {
    var path = __require("path");
    var sortBy = require_sortBy();
    var { readdir } = require_fs();
    var { AbstractMigrationsLoader } = require_MigrationsLoader();
    var FsMigrations = class extends AbstractMigrationsLoader {
      /**
       * Gets the migration names
       * @returns Promise<string[]>
       */
      getMigrations(loadExtensions) {
        const readMigrationsPromises = this.migrationsPaths.map((configDir) => {
          const absoluteDir = path.resolve(process.cwd(), configDir);
          return readdir(absoluteDir).then((files) => ({
            files,
            configDir,
            absoluteDir
          }));
        });
        return Promise.all(readMigrationsPromises).then((allMigrations) => {
          const migrations = allMigrations.reduce((acc, migrationDirectory) => {
            if (this.sortDirsSeparately) {
              migrationDirectory.files = migrationDirectory.files.sort();
            }
            migrationDirectory.files.forEach(
              (file) => acc.push({ file, directory: migrationDirectory.configDir })
            );
            return acc;
          }, []);
          if (this.sortDirsSeparately) {
            return filterMigrations(
              this,
              migrations,
              loadExtensions || this.loadExtensions
            );
          }
          return filterMigrations(
            this,
            sortBy(migrations, "file"),
            loadExtensions || this.loadExtensions
          );
        });
      }
      getMigrationName(migration) {
        return migration.file;
      }
      getMigration(migrationInfo) {
        return this.getFile(migrationInfo);
      }
    };
    function filterMigrations(migrationSource, migrations, loadExtensions) {
      return migrations.filter((migration) => {
        const migrationName = migrationSource.getMigrationName(migration);
        const extension = path.extname(migrationName);
        return loadExtensions.includes(extension);
      });
    }
    module.exports = {
      FsMigrations
    };
  }
});

// node_modules/knex/node_modules/colorette/index.cjs
var require_colorette2 = __commonJS({
  "node_modules/knex/node_modules/colorette/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tty = __require("tty");
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule) return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      if (e3) {
        Object.keys(e3).forEach(function(k3) {
          if (k3 !== "default") {
            var d3 = Object.getOwnPropertyDescriptor(e3, k3);
            Object.defineProperty(n3, k3, d3.get ? d3 : {
              enumerable: true,
              get: function() {
                return e3[k3];
              }
            });
          }
        });
      }
      n3["default"] = e3;
      return Object.freeze(n3);
    }
    var tty__namespace = /* @__PURE__ */ _interopNamespace(tty);
    var {
      env = {},
      argv = [],
      platform = ""
    } = typeof process === "undefined" ? {} : process;
    var isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
    var isForced = "FORCE_COLOR" in env || argv.includes("--color");
    var isWindows = platform === "win32";
    var isDumbTerminal = env.TERM === "dumb";
    var isCompatibleTerminal = tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;
    var isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
    var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
    var replaceClose = (index, string, close, replace, head = string.substring(0, index) + replace, tail = string.substring(index + close.length), next = tail.indexOf(close)) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
    var clearBleed = (index, string, open, close, replace) => index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
    var filterEmpty = (open, close, replace = open, at = open.length + 1) => (string) => string || !(string === "" || string === void 0) ? clearBleed(
      ("" + string).indexOf(close, at),
      string,
      open,
      close,
      replace
    ) : "";
    var init = (open, close, replace) => filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
    var colors = {
      reset: init(0, 0),
      bold: init(1, 22, "\x1B[22m\x1B[1m"),
      dim: init(2, 22, "\x1B[22m\x1B[2m"),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49),
      blackBright: init(90, 39),
      redBright: init(91, 39),
      greenBright: init(92, 39),
      yellowBright: init(93, 39),
      blueBright: init(94, 39),
      magentaBright: init(95, 39),
      cyanBright: init(96, 39),
      whiteBright: init(97, 39),
      bgBlackBright: init(100, 49),
      bgRedBright: init(101, 49),
      bgGreenBright: init(102, 49),
      bgYellowBright: init(103, 49),
      bgBlueBright: init(104, 49),
      bgMagentaBright: init(105, 49),
      bgCyanBright: init(106, 49),
      bgWhiteBright: init(107, 49)
    };
    var createColors = ({ useColor = isColorSupported } = {}) => useColor ? colors : Object.keys(colors).reduce(
      (colors2, key) => ({ ...colors2, [key]: String }),
      {}
    );
    var {
      reset,
      bold,
      dim,
      italic,
      underline,
      inverse,
      hidden,
      strikethrough,
      black,
      red,
      green,
      yellow,
      blue,
      magenta,
      cyan,
      white,
      gray,
      bgBlack,
      bgRed,
      bgGreen,
      bgYellow,
      bgBlue,
      bgMagenta,
      bgCyan,
      bgWhite,
      blackBright,
      redBright,
      greenBright,
      yellowBright,
      blueBright,
      magentaBright,
      cyanBright,
      whiteBright,
      bgBlackBright,
      bgRedBright,
      bgGreenBright,
      bgYellowBright,
      bgBlueBright,
      bgMagentaBright,
      bgCyanBright,
      bgWhiteBright
    } = createColors();
    exports.bgBlack = bgBlack;
    exports.bgBlackBright = bgBlackBright;
    exports.bgBlue = bgBlue;
    exports.bgBlueBright = bgBlueBright;
    exports.bgCyan = bgCyan;
    exports.bgCyanBright = bgCyanBright;
    exports.bgGreen = bgGreen;
    exports.bgGreenBright = bgGreenBright;
    exports.bgMagenta = bgMagenta;
    exports.bgMagentaBright = bgMagentaBright;
    exports.bgRed = bgRed;
    exports.bgRedBright = bgRedBright;
    exports.bgWhite = bgWhite;
    exports.bgWhiteBright = bgWhiteBright;
    exports.bgYellow = bgYellow;
    exports.bgYellowBright = bgYellowBright;
    exports.black = black;
    exports.blackBright = blackBright;
    exports.blue = blue;
    exports.blueBright = blueBright;
    exports.bold = bold;
    exports.createColors = createColors;
    exports.cyan = cyan;
    exports.cyanBright = cyanBright;
    exports.dim = dim;
    exports.gray = gray;
    exports.green = green;
    exports.greenBright = greenBright;
    exports.hidden = hidden;
    exports.inverse = inverse;
    exports.isColorSupported = isColorSupported;
    exports.italic = italic;
    exports.magenta = magenta;
    exports.magentaBright = magentaBright;
    exports.red = red;
    exports.redBright = redBright;
    exports.reset = reset;
    exports.strikethrough = strikethrough;
    exports.underline = underline;
    exports.white = white;
    exports.whiteBright = whiteBright;
    exports.yellow = yellow;
    exports.yellowBright = yellowBright;
  }
});

// node_modules/knex/lib/util/is.js
var require_is = __commonJS({
  "node_modules/knex/lib/util/is.js"(exports, module) {
    function isString(value) {
      return typeof value === "string";
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    module.exports = {
      isString,
      isNumber,
      isBoolean,
      isUndefined,
      isObject,
      isFunction
    };
  }
});

// node_modules/knex/lib/logger.js
var require_logger = __commonJS({
  "node_modules/knex/lib/logger.js"(exports, module) {
    var color = require_colorette2();
    var { inspect } = __require("util");
    var { isString, isFunction } = require_is();
    var Logger = class {
      constructor(config = {}) {
        const {
          log: {
            debug,
            warn,
            error,
            deprecate,
            inspectionDepth,
            enableColors
          } = {}
        } = config;
        this._inspectionDepth = inspectionDepth || 5;
        this._enableColors = resolveIsEnabledColors(enableColors);
        this._debug = debug;
        this._warn = warn;
        this._error = error;
        this._deprecate = deprecate;
      }
      _log(message, userFn, colorFn) {
        if (userFn != null && !isFunction(userFn)) {
          throw new TypeError("Extensions to knex logger must be functions!");
        }
        if (isFunction(userFn)) {
          userFn(message);
          return;
        }
        if (!isString(message)) {
          message = inspect(message, {
            depth: this._inspectionDepth,
            colors: this._enableColors
          });
        }
        console.log(colorFn ? colorFn(message) : message);
      }
      debug(message) {
        this._log(message, this._debug);
      }
      warn(message) {
        this._log(message, this._warn, color.yellow);
      }
      error(message) {
        this._log(message, this._error, color.red);
      }
      deprecate(method, alternative) {
        const message = `${method} is deprecated, please use ${alternative}`;
        this._log(message, this._deprecate, color.yellow);
      }
    };
    function resolveIsEnabledColors(enableColorsParam) {
      if (enableColorsParam != null) {
        return enableColorsParam;
      }
      if (process && process.stdout) {
        return process.stdout.isTTY;
      }
      return false;
    }
    module.exports = Logger;
  }
});

// node_modules/knex/lib/migrations/migrate/migrator-configuration-merger.js
var require_migrator_configuration_merger = __commonJS({
  "node_modules/knex/lib/migrations/migrate/migrator-configuration-merger.js"(exports, module) {
    var { FsMigrations } = require_fs_migrations();
    var Logger = require_logger();
    var { DEFAULT_LOAD_EXTENSIONS } = require_MigrationsLoader();
    var defaultLogger = new Logger();
    var CONFIG_DEFAULT = Object.freeze({
      extension: "js",
      loadExtensions: DEFAULT_LOAD_EXTENSIONS,
      tableName: "knex_migrations",
      schemaName: null,
      directory: "./migrations",
      disableTransactions: false,
      disableMigrationsListValidation: false,
      sortDirsSeparately: false
    });
    function getMergedConfig(config, currentConfig, logger = defaultLogger) {
      const mergedConfig = Object.assign(
        {},
        CONFIG_DEFAULT,
        currentConfig || {},
        config
      );
      if (config && // If user specifies any FS related config,
      // clear specified migrationSource to avoid ambiguity
      (config.directory || config.sortDirsSeparately !== void 0 || config.loadExtensions)) {
        if (config.migrationSource) {
          logger.warn(
            "FS-related option specified for migration configuration. This resets migrationSource to default FsMigrations"
          );
        }
        mergedConfig.migrationSource = null;
      }
      if (!mergedConfig.migrationSource) {
        mergedConfig.migrationSource = new FsMigrations(
          mergedConfig.directory,
          mergedConfig.sortDirsSeparately,
          mergedConfig.loadExtensions
        );
      }
      return mergedConfig;
    }
    module.exports = {
      getMergedConfig
    };
  }
});

// node_modules/knex/lib/migrations/util/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/knex/lib/migrations/util/timestamp.js"(exports, module) {
    function yyyymmddhhmmss() {
      const now = /* @__PURE__ */ new Date();
      return now.getUTCFullYear().toString() + (now.getUTCMonth() + 1).toString().padStart(2, "0") + now.getUTCDate().toString().padStart(2, "0") + now.getUTCHours().toString().padStart(2, "0") + now.getUTCMinutes().toString().padStart(2, "0") + now.getUTCSeconds().toString().padStart(2, "0");
    }
    module.exports = { yyyymmddhhmmss };
  }
});

// node_modules/knex/lib/migrations/migrate/MigrationGenerator.js
var require_MigrationGenerator = __commonJS({
  "node_modules/knex/lib/migrations/migrate/MigrationGenerator.js"(exports, module) {
    var path = __require("path");
    var { writeJsFileUsingTemplate } = require_template2();
    var { getMergedConfig } = require_migrator_configuration_merger();
    var { ensureDirectoryExists } = require_fs();
    var { yyyymmddhhmmss } = require_timestamp();
    var MigrationGenerator = class {
      constructor(migrationConfig, logger) {
        this.config = getMergedConfig(migrationConfig, void 0, logger);
      }
      // Creates a new migration, with a given name.
      async make(name, config, logger) {
        this.config = getMergedConfig(config, this.config, logger);
        if (!name) {
          return Promise.reject(
            new Error("A name must be specified for the generated migration")
          );
        }
        await this._ensureFolder();
        const createdMigrationFilePath = await this._writeNewMigration(name);
        return createdMigrationFilePath;
      }
      // Ensures a folder for the migrations exist, dependent on the migration
      // config settings.
      _ensureFolder() {
        const dirs = this._absoluteConfigDirs();
        const promises = dirs.map(ensureDirectoryExists);
        return Promise.all(promises);
      }
      _getStubPath() {
        return this.config.stub || path.join(__dirname, "stub", this.config.extension + ".stub");
      }
      _getNewMigrationName(name) {
        if (name[0] === "-") name = name.slice(1);
        return yyyymmddhhmmss() + "_" + name + "." + this.config.extension.split("-")[0];
      }
      _getNewMigrationPath(name) {
        const fileName = this._getNewMigrationName(name);
        const dirs = this._absoluteConfigDirs();
        const dir = dirs.slice(-1)[0];
        return path.join(dir, fileName);
      }
      // Write a new migration to disk, using the config and generated filename,
      // passing any `variables` given in the config to the template.
      async _writeNewMigration(name) {
        const migrationPath = this._getNewMigrationPath(name);
        await writeJsFileUsingTemplate(
          migrationPath,
          this._getStubPath(),
          { variable: "d" },
          this.config.variables || {}
        );
        return migrationPath;
      }
      _absoluteConfigDirs() {
        const directories = Array.isArray(this.config.directory) ? this.config.directory : [this.config.directory];
        return directories.map((directory) => {
          if (!directory) {
            console.warn(
              "Failed to resolve config file, knex cannot determine where to generate migrations"
            );
          }
          return path.resolve(process.cwd(), directory);
        });
      }
    };
    module.exports = MigrationGenerator;
  }
});

// node_modules/knex/lib/migrations/migrate/Migrator.js
var require_Migrator = __commonJS({
  "node_modules/knex/lib/migrations/migrate/Migrator.js"(exports, module) {
    var differenceWith = require_differenceWith();
    var get2 = require_get();
    var isEmpty = require_isEmpty();
    var max = require_max();
    var {
      getLockTableName,
      getTable,
      getTableName
    } = require_table_resolver();
    var { getSchemaBuilder } = require_table_creator();
    var migrationListResolver = require_migration_list_resolver();
    var MigrationGenerator = require_MigrationGenerator();
    var { getMergedConfig } = require_migrator_configuration_merger();
    var { isBoolean, isFunction } = require_is();
    var LockError = class extends Error {
      constructor(msg) {
        super(msg);
        this.name = "MigrationLocked";
      }
    };
    var Migrator = class {
      constructor(knex2) {
        if (isFunction(knex2)) {
          if (!knex2.isTransaction) {
            this.knex = knex2.withUserParams({
              ...knex2.userParams
            });
          } else {
            this.knex = knex2;
          }
        } else {
          this.knex = Object.assign({}, knex2);
          this.knex.userParams = this.knex.userParams || {};
        }
        this.config = getMergedConfig(
          this.knex.client.config.migrations,
          void 0,
          this.knex.client.logger
        );
        this.generator = new MigrationGenerator(
          this.knex.client.config.migrations,
          this.knex.client.logger
        );
        this._activeMigration = {
          fileName: null
        };
      }
      // Migrators to the latest configuration.
      async latest(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        const allAndCompleted = await migrationListResolver.listAllAndCompleted(
          this.config,
          this.knex
        );
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, allAndCompleted);
        }
        const [all, completed] = allAndCompleted;
        const migrations = getNewMigrations(
          this.config.migrationSource,
          all,
          completed
        );
        const transactionForAll = !this.config.disableTransactions && !(await Promise.all(
          migrations.map(async (migration) => {
            const migrationContents = await this.config.migrationSource.getMigration(migration);
            return !this._useTransaction(migrationContents);
          })
        )).some((isTransactionUsed) => isTransactionUsed);
        if (transactionForAll) {
          return this.knex.transaction((trx) => {
            return this._runBatch(migrations, "up", trx);
          });
        } else {
          return this._runBatch(migrations, "up");
        }
      }
      // Runs the next migration that has not yet been run
      async up(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        const allAndCompleted = await migrationListResolver.listAllAndCompleted(
          this.config,
          this.knex
        );
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, allAndCompleted);
        }
        const [all, completed] = allAndCompleted;
        const newMigrations = getNewMigrations(
          this.config.migrationSource,
          all,
          completed
        );
        let migrationToRun;
        const name = this.config.name;
        if (name) {
          if (!completed.includes(name)) {
            migrationToRun = newMigrations.find((migration) => {
              return this.config.migrationSource.getMigrationName(migration) === name;
            });
            if (!migrationToRun) {
              throw new Error(`Migration "${name}" not found.`);
            }
          }
        } else {
          migrationToRun = newMigrations[0];
        }
        const useTransaction = !migrationToRun || this._useTransaction(
          await this.config.migrationSource.getMigration(migrationToRun)
        );
        const migrationsToRun = [];
        if (migrationToRun) {
          migrationsToRun.push(migrationToRun);
        }
        const transactionForAll = !this.config.disableTransactions && (!migrationToRun || useTransaction);
        if (transactionForAll) {
          return await this.knex.transaction((trx) => {
            return this._runBatch(migrationsToRun, "up", trx);
          });
        } else {
          return await this._runBatch(migrationsToRun, "up");
        }
      }
      // Rollback the last "batch", or all, of migrations that were run.
      rollback(config, all = false) {
        this._disableProcessing();
        return new Promise((resolve, reject) => {
          try {
            this.config = getMergedConfig(
              config,
              this.config,
              this.knex.client.logger
            );
          } catch (e3) {
            reject(e3);
          }
          migrationListResolver.listAllAndCompleted(this.config, this.knex).then((value) => {
            if (!this.config.disableMigrationsListValidation) {
              validateMigrationList(this.config.migrationSource, value);
            }
            return value;
          }).then((val2) => {
            const [allMigrations, completedMigrations] = val2;
            return all ? allMigrations.filter((migration) => {
              return completedMigrations.map((migration2) => migration2.name).includes(
                this.config.migrationSource.getMigrationName(migration)
              );
            }).reverse() : this._getLastBatch(val2);
          }).then((migrations) => {
            return this._runBatch(migrations, "down");
          }).then(resolve, reject);
        });
      }
      down(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        return migrationListResolver.listAllAndCompleted(this.config, this.knex).then((value) => {
          if (!this.config.disableMigrationsListValidation) {
            validateMigrationList(this.config.migrationSource, value);
          }
          return value;
        }).then(([all, completed]) => {
          const completedMigrations = all.filter((migration) => {
            return completed.map((migration2) => migration2.name).includes(this.config.migrationSource.getMigrationName(migration));
          });
          let migrationToRun;
          const name = this.config.name;
          if (name) {
            migrationToRun = completedMigrations.find((migration) => {
              return this.config.migrationSource.getMigrationName(migration) === name;
            });
            if (!migrationToRun) {
              throw new Error(`Migration "${name}" was not run.`);
            }
          } else {
            migrationToRun = completedMigrations[completedMigrations.length - 1];
          }
          const migrationsToRun = [];
          if (migrationToRun) {
            migrationsToRun.push(migrationToRun);
          }
          return this._runBatch(migrationsToRun, "down");
        });
      }
      status(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        return Promise.all([
          getTable(this.knex, this.config.tableName, this.config.schemaName).select(
            "*"
          ),
          migrationListResolver.listAll(this.config.migrationSource)
        ]).then(([db, code]) => db.length - code.length);
      }
      // Retrieves and returns the current migration version we're on, as a promise.
      // If no migrations have been run yet, return "none".
      currentVersion(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        return migrationListResolver.listCompleted(this.config.tableName, this.config.schemaName, this.knex).then((completed) => {
          const val2 = max(completed.map((value) => value.name.split("_")[0]));
          return val2 === void 0 ? "none" : val2;
        });
      }
      // list all migrations
      async list(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        const [all, completed] = await migrationListResolver.listAllAndCompleted(
          this.config,
          this.knex
        );
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, [all, completed]);
        }
        const newMigrations = getNewMigrations(
          this.config.migrationSource,
          all,
          completed
        );
        return [completed, newMigrations];
      }
      async forceFreeMigrationsLock(config) {
        this._disableProcessing();
        this.config = getMergedConfig(config, this.config, this.knex.client.logger);
        const { schemaName, tableName } = this.config;
        const lockTableName = getLockTableName(tableName);
        const { knex: knex2 } = this;
        const getLockTable = () => getTable(knex2, lockTableName, schemaName);
        const tableExists = await getSchemaBuilder(knex2, schemaName).hasTable(
          lockTableName
        );
        if (tableExists) {
          await getLockTable().del();
          await getLockTable().insert({
            is_locked: 0
          });
        }
      }
      // Creates a new migration, with a given name.
      make(name, config) {
        return this.generator.make(name, config, this.knex.client.logger);
      }
      _disableProcessing() {
        if (this.knex.disableProcessing) {
          this.knex.disableProcessing();
        }
      }
      _lockMigrations(trx) {
        const tableName = getLockTableName(this.config.tableName);
        return getTable(this.knex, tableName, this.config.schemaName).transacting(trx).where("is_locked", "=", 0).update({ is_locked: 1 }).then((rowCount) => {
          if (rowCount !== 1) {
            throw new Error("Migration table is already locked");
          }
        });
      }
      _getLock(trx) {
        const transact = trx ? (fn) => fn(trx) : (fn) => this.knex.transaction(fn);
        return transact((trx2) => {
          return this._lockMigrations(trx2);
        }).catch((err) => {
          throw new LockError(err.message);
        });
      }
      _freeLock(trx = this.knex) {
        const tableName = getLockTableName(this.config.tableName);
        return getTable(trx, tableName, this.config.schemaName).update({
          is_locked: 0
        });
      }
      // Run a batch of current migrations, in sequence.
      async _runBatch(migrations, direction, trx) {
        const canGetLockInTransaction = this.knex.client.driverName !== "cockroachdb";
        try {
          await this._getLock(canGetLockInTransaction ? trx : void 0);
          const completed = trx ? await migrationListResolver.listCompleted(
            this.config.tableName,
            this.config.schemaName,
            trx
          ) : [];
          migrations = getNewMigrations(
            this.config.migrationSource,
            migrations,
            completed
          );
          await Promise.all(
            migrations.map(this._validateMigrationStructure.bind(this))
          );
          let batchNo = await this._latestBatchNumber(trx);
          if (direction === "up") batchNo++;
          const res = await this._waterfallBatch(
            batchNo,
            migrations,
            direction,
            trx
          );
          await this._freeLock(canGetLockInTransaction ? trx : void 0);
          return res;
        } catch (error) {
          let cleanupReady = Promise.resolve();
          if (error instanceof LockError) {
            this.knex.client.logger.warn(
              `Can't take lock to run migrations: ${error.message}`
            );
            this.knex.client.logger.warn(
              "If you are sure migrations are not running you can release the lock manually by running 'knex migrate:unlock'"
            );
          } else {
            if (this._activeMigration.fileName) {
              this.knex.client.logger.warn(
                `migration file "${this._activeMigration.fileName}" failed`
              );
            }
            this.knex.client.logger.warn(
              `migration failed with error: ${error.message}`
            );
            cleanupReady = this._freeLock(
              canGetLockInTransaction ? trx : void 0
            );
          }
          try {
            await cleanupReady;
          } catch (e3) {
          }
          throw error;
        }
      }
      // Validates some migrations by requiring and checking for an `up` and `down`
      // function.
      async _validateMigrationStructure(migration) {
        const migrationName = this.config.migrationSource.getMigrationName(migration);
        const migrationContent = await this.config.migrationSource.getMigration(
          migration
        );
        if (typeof migrationContent.up !== "function" || typeof migrationContent.down !== "function") {
          throw new Error(
            `Invalid migration: ${migrationName} must have both an up and down function`
          );
        }
        return migration;
      }
      // Get the last batch of migrations, by name, ordered by insert id in reverse
      // order.
      async _getLastBatch([allMigrations]) {
        const { tableName, schemaName } = this.config;
        const migrationNames = await getTable(this.knex, tableName, schemaName).where("batch", function(qb) {
          qb.max("batch").from(getTableName(tableName, schemaName));
        }).orderBy("id", "desc");
        const lastBatchMigrations = migrationNames.map((migration) => {
          return allMigrations.find((entry) => {
            return this.config.migrationSource.getMigrationName(entry) === migration.name;
          });
        });
        return Promise.all(lastBatchMigrations);
      }
      // Returns the latest batch number.
      _latestBatchNumber(trx = this.knex) {
        return trx.from(getTableName(this.config.tableName, this.config.schemaName)).max("batch as max_batch").then((obj) => obj[0].max_batch || 0);
      }
      // If transaction config for a single migration is defined, use that.
      // Otherwise, rely on the common config. This allows enabling/disabling
      // transaction for a single migration at will, regardless of the common
      // config.
      _useTransaction(migrationContent, allTransactionsDisabled) {
        const singleTransactionValue = get2(migrationContent, "config.transaction");
        return isBoolean(singleTransactionValue) ? singleTransactionValue : !allTransactionsDisabled;
      }
      // Runs a batch of `migrations` in a specified `direction`, saving the
      // appropriate database information as the migrations are run.
      _waterfallBatch(batchNo, migrations, direction, trx) {
        const trxOrKnex = trx || this.knex;
        const { tableName, schemaName, disableTransactions } = this.config;
        let current = Promise.resolve();
        const log = [];
        migrations.forEach((migration) => {
          const name = this.config.migrationSource.getMigrationName(migration);
          this._activeMigration.fileName = name;
          const migrationContent = this.config.migrationSource.getMigration(migration);
          current = current.then(async () => await migrationContent).then((migrationContent2) => {
            this._activeMigration.fileName = name;
            if (!trx && this._useTransaction(migrationContent2, disableTransactions)) {
              this.knex.enableProcessing();
              return this._transaction(
                this.knex,
                migrationContent2,
                direction,
                name
              );
            }
            trxOrKnex.enableProcessing();
            return checkPromise(
              this.knex.client.logger,
              migrationContent2[direction](trxOrKnex),
              name
            );
          }).then(() => {
            trxOrKnex.disableProcessing();
            this.knex.disableProcessing();
            log.push(name);
            if (direction === "up") {
              return trxOrKnex.into(getTableName(tableName, schemaName)).insert({
                name,
                batch: batchNo,
                migration_time: /* @__PURE__ */ new Date()
              });
            }
            if (direction === "down") {
              return trxOrKnex.from(getTableName(tableName, schemaName)).where({ name }).del();
            }
          });
        });
        return current.then(() => [batchNo, log]);
      }
      _transaction(knex2, migrationContent, direction, name) {
        return knex2.transaction((trx) => {
          return checkPromise(
            knex2.client.logger,
            migrationContent[direction](trx),
            name,
            () => {
              trx.commit();
            }
          );
        });
      }
    };
    function validateMigrationList(migrationSource, migrations) {
      const [all, completed] = migrations;
      const diff = getMissingMigrations(migrationSource, completed, all);
      if (!isEmpty(diff)) {
        const names = diff.map((d3) => d3.name);
        throw new Error(
          `The migration directory is corrupt, the following files are missing: ${names.join(
            ", "
          )}`
        );
      }
    }
    function getMissingMigrations(migrationSource, completed, all) {
      return differenceWith(completed, all, (c3, a3) => {
        return c3.name === migrationSource.getMigrationName(a3);
      });
    }
    function getNewMigrations(migrationSource, all, completed) {
      return differenceWith(all, completed, (a3, c3) => {
        return c3.name === migrationSource.getMigrationName(a3);
      });
    }
    function checkPromise(logger, migrationPromise, name, commitFn) {
      if (!migrationPromise || typeof migrationPromise.then !== "function") {
        logger.warn(`migration ${name} did not return a promise`);
        if (commitFn) {
          commitFn();
        }
      }
      return migrationPromise;
    }
    module.exports = {
      Migrator
    };
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module.exports = isString;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module.exports = values;
  }
});

// node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/lodash/includes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module.exports = includes;
  }
});

// node_modules/knex/lib/migrations/seed/sources/fs-seeds.js
var require_fs_seeds = __commonJS({
  "node_modules/knex/lib/migrations/seed/sources/fs-seeds.js"(exports, module) {
    var path = __require("path");
    var flatten = require_flatten();
    var includes = require_includes();
    var { AbstractMigrationsLoader } = require_MigrationsLoader();
    var { getFilepathsInFolder } = require_fs();
    var filterByLoadExtensions = (extensions) => (value) => {
      const extension = path.extname(value);
      return includes(extensions, extension);
    };
    var FsSeeds = class extends AbstractMigrationsLoader {
      _getConfigDirectories(logger) {
        const directories = this.migrationsPaths;
        return directories.map((directory) => {
          if (!directory) {
            logger.warn(
              "Empty value passed as a directory for Seeder, this is not supported."
            );
          }
          return path.resolve(process.cwd(), directory);
        });
      }
      async getSeeds(config) {
        const { loadExtensions, recursive, specific } = config;
        const seeds = flatten(
          await Promise.all(
            this._getConfigDirectories(config.logger).map(
              (d3) => getFilepathsInFolder(d3, recursive)
            )
          )
        );
        let files = seeds.filter(filterByLoadExtensions(loadExtensions));
        if (!this.sortDirsSeparately) {
          files.sort();
        }
        if (specific) {
          files = files.filter((file) => path.basename(file) === specific);
          if (files.length === 0) {
            throw new Error(
              `Invalid argument provided: the specific seed "${specific}" does not exist.`
            );
          }
        }
        return files;
      }
      async getSeed(filepath) {
        const importFile = require_import_file();
        const seed = await importFile(filepath);
        return seed;
      }
    };
    module.exports = {
      FsSeeds
    };
  }
});

// node_modules/knex/lib/migrations/seed/seeder-configuration-merger.js
var require_seeder_configuration_merger = __commonJS({
  "node_modules/knex/lib/migrations/seed/seeder-configuration-merger.js"(exports, module) {
    var { FsSeeds } = require_fs_seeds();
    var Logger = require_logger();
    var { DEFAULT_LOAD_EXTENSIONS } = require_MigrationsLoader();
    var defaultLogger = new Logger();
    var CONFIG_DEFAULT = Object.freeze({
      extension: "js",
      directory: "./seeds",
      loadExtensions: DEFAULT_LOAD_EXTENSIONS,
      specific: null,
      timestampFilenamePrefix: false,
      recursive: false,
      sortDirsSeparately: false
    });
    function getMergedConfig(config, currentConfig, logger = defaultLogger) {
      const mergedConfig = Object.assign(
        {},
        CONFIG_DEFAULT,
        currentConfig || {},
        config,
        {
          logger
        }
      );
      if (config && // If user specifies any FS related config,
      // clear specified migrationSource to avoid ambiguity
      (config.directory || config.sortDirsSeparately !== void 0 || config.loadExtensions)) {
        if (config.seedSource) {
          logger.warn(
            "FS-related option specified for seed configuration. This resets seedSource to default FsMigrations"
          );
        }
        mergedConfig.seedSource = null;
      }
      if (!mergedConfig.seedSource) {
        mergedConfig.seedSource = new FsSeeds(
          mergedConfig.directory,
          mergedConfig.sortDirsSeparately,
          mergedConfig.loadExtensions
        );
      }
      return mergedConfig;
    }
    module.exports = {
      getMergedConfig
    };
  }
});

// node_modules/knex/lib/migrations/seed/Seeder.js
var require_Seeder = __commonJS({
  "node_modules/knex/lib/migrations/seed/Seeder.js"(exports, module) {
    var path = __require("path");
    var { ensureDirectoryExists } = require_fs();
    var { writeJsFileUsingTemplate } = require_template2();
    var { yyyymmddhhmmss } = require_timestamp();
    var { getMergedConfig } = require_seeder_configuration_merger();
    var Seeder = class {
      constructor(knex2) {
        this.knex = knex2;
        this.config = this.resolveConfig(knex2.client.config.seeds);
      }
      // Runs seed files for the given environment.
      async run(config) {
        this.config = this.resolveConfig(config);
        const files = await this.config.seedSource.getSeeds(this.config);
        return this._runSeeds(files);
      }
      // Creates a new seed file, with a given name.
      async make(name, config) {
        this.config = this.resolveConfig(config);
        if (!name)
          throw new Error("A name must be specified for the generated seed");
        await this._ensureFolder(config);
        const seedPath = await this._writeNewSeed(name);
        return seedPath;
      }
      // Ensures a folder for the seeds exist, dependent on the
      // seed config settings.
      _ensureFolder() {
        const dirs = this.config.seedSource._getConfigDirectories(
          this.config.logger
        );
        const promises = dirs.map(ensureDirectoryExists);
        return Promise.all(promises);
      }
      // Run seed files, in sequence.
      async _runSeeds(seeds) {
        for (const seed of seeds) {
          await this._validateSeedStructure(seed);
        }
        return this._waterfallBatch(seeds);
      }
      async _validateSeedStructure(filepath) {
        const seed = await this.config.seedSource.getSeed(filepath);
        if (typeof seed.seed !== "function") {
          throw new Error(
            `Invalid seed file: ${filepath} must have a seed function`
          );
        }
        return filepath;
      }
      _getStubPath() {
        return this.config.stub || path.join(__dirname, "stub", this.config.extension + ".stub");
      }
      _getNewStubFileName(name) {
        if (name[0] === "-") name = name.slice(1);
        if (this.config.timestampFilenamePrefix === true) {
          name = `${yyyymmddhhmmss()}_${name}`;
        }
        return `${name}.${this.config.extension}`;
      }
      _getNewStubFilePath(name) {
        const fileName = this._getNewStubFileName(name);
        const dirs = this.config.seedSource._getConfigDirectories(
          this.config.logger
        );
        const dir = dirs.slice(-1)[0];
        return path.join(dir, fileName);
      }
      // Write a new seed to disk, using the config and generated filename,
      // passing any `variables` given in the config to the template.
      async _writeNewSeed(name) {
        const seedPath = this._getNewStubFilePath(name);
        await writeJsFileUsingTemplate(
          seedPath,
          this._getStubPath(),
          { variable: "d" },
          this.config.variables || {}
        );
        return seedPath;
      }
      async _listAll(config) {
        this.config = this.resolveConfig(config);
        return this.config.seedSource.getSeeds(this.config);
      }
      // Runs a batch of seed files.
      async _waterfallBatch(seeds) {
        const { knex: knex2 } = this;
        const log = [];
        for (const seedPath of seeds) {
          const seed = await this.config.seedSource.getSeed(seedPath);
          try {
            await seed.seed(knex2);
            log.push(seedPath);
          } catch (originalError) {
            const error = new Error(
              `Error while executing "${seedPath}" seed: ${originalError.message}`
            );
            error.original = originalError;
            error.stack = error.stack.split("\n").slice(0, 2).join("\n") + "\n" + originalError.stack;
            throw error;
          }
        }
        return [log];
      }
      resolveConfig(config) {
        return getMergedConfig(config, this.config, this.knex.client.logger);
      }
    };
    module.exports = Seeder;
  }
});

// node_modules/knex/lib/knex-builder/FunctionHelper.js
var require_FunctionHelper = __commonJS({
  "node_modules/knex/lib/knex-builder/FunctionHelper.js"(exports, module) {
    var FunctionHelper = class {
      constructor(client) {
        this.client = client;
      }
      now(precision) {
        if (typeof precision === "number") {
          return this.client.raw(`CURRENT_TIMESTAMP(${precision})`);
        }
        return this.client.raw("CURRENT_TIMESTAMP");
      }
      uuid() {
        switch (this.client.driverName) {
          case "sqlite3":
          case "better-sqlite3":
            return this.client.raw(
              "(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))"
            );
          case "mssql":
            return this.client.raw("(NEWID())");
          case "pg":
          case "pgnative":
          case "cockroachdb":
            return this.client.raw("(gen_random_uuid())");
          case "oracle":
          case "oracledb":
            return this.client.raw("(random_uuid())");
          case "mysql":
          case "mysql2":
            return this.client.raw("(UUID())");
          default:
            throw new Error(
              `${this.client.driverName} does not have a uuid function`
            );
        }
      }
      uuidToBin(uuid, ordered = true) {
        const buf = Buffer.from(uuid.replace(/-/g, ""), "hex");
        return ordered ? Buffer.concat([
          buf.slice(6, 8),
          buf.slice(4, 6),
          buf.slice(0, 4),
          buf.slice(8, 16)
        ]) : Buffer.concat([
          buf.slice(0, 4),
          buf.slice(4, 6),
          buf.slice(6, 8),
          buf.slice(8, 16)
        ]);
      }
      binToUuid(bin, ordered = true) {
        const buf = Buffer.from(bin, "hex");
        return ordered ? [
          buf.toString("hex", 4, 8),
          buf.toString("hex", 2, 4),
          buf.toString("hex", 0, 2),
          buf.toString("hex", 8, 10),
          buf.toString("hex", 10, 16)
        ].join("-") : [
          buf.toString("hex", 0, 4),
          buf.toString("hex", 4, 6),
          buf.toString("hex", 6, 8),
          buf.toString("hex", 8, 10),
          buf.toString("hex", 10, 16)
        ].join("-");
      }
    };
    module.exports = FunctionHelper;
  }
});

// node_modules/knex/lib/query/method-constants.js
var require_method_constants = __commonJS({
  "node_modules/knex/lib/query/method-constants.js"(exports, module) {
    module.exports = [
      "with",
      "withRecursive",
      "withMaterialized",
      "withNotMaterialized",
      "select",
      "as",
      "columns",
      "column",
      "from",
      "fromJS",
      "fromRaw",
      "into",
      "withSchema",
      "table",
      "distinct",
      "join",
      "joinRaw",
      "innerJoin",
      "leftJoin",
      "leftOuterJoin",
      "rightJoin",
      "rightOuterJoin",
      "outerJoin",
      "fullOuterJoin",
      "crossJoin",
      "where",
      "andWhere",
      "orWhere",
      "whereNot",
      "orWhereNot",
      "whereLike",
      "andWhereLike",
      "orWhereLike",
      "whereILike",
      "andWhereILike",
      "orWhereILike",
      "whereRaw",
      "whereWrapped",
      "havingWrapped",
      "orWhereRaw",
      "whereExists",
      "orWhereExists",
      "whereNotExists",
      "orWhereNotExists",
      "whereIn",
      "orWhereIn",
      "whereNotIn",
      "orWhereNotIn",
      "whereNull",
      "orWhereNull",
      "whereNotNull",
      "orWhereNotNull",
      "whereBetween",
      "whereNotBetween",
      "andWhereBetween",
      "andWhereNotBetween",
      "orWhereBetween",
      "orWhereNotBetween",
      "groupBy",
      "groupByRaw",
      "orderBy",
      "orderByRaw",
      "union",
      "unionAll",
      "intersect",
      "except",
      "having",
      "havingRaw",
      "orHaving",
      "orHavingRaw",
      "offset",
      "limit",
      "count",
      "countDistinct",
      "min",
      "max",
      "sum",
      "sumDistinct",
      "avg",
      "avgDistinct",
      "increment",
      "decrement",
      "first",
      "debug",
      "pluck",
      "clearSelect",
      "clearWhere",
      "clearGroup",
      "clearOrder",
      "clearHaving",
      "insert",
      "update",
      "returning",
      "del",
      "delete",
      "truncate",
      "transacting",
      "connection",
      // JSON methods
      // Json manipulation functions
      "jsonExtract",
      "jsonSet",
      "jsonInsert",
      "jsonRemove",
      // Wheres Json
      "whereJsonObject",
      "orWhereJsonObject",
      "andWhereJsonObject",
      "whereNotJsonObject",
      "orWhereNotJsonObject",
      "andWhereNotJsonObject",
      "whereJsonPath",
      "orWhereJsonPath",
      "andWhereJsonPath",
      "whereJsonSupersetOf",
      "orWhereJsonSupersetOf",
      "andWhereJsonSupersetOf",
      "whereJsonNotSupersetOf",
      "orWhereJsonNotSupersetOf",
      "andWhereJsonNotSupersetOf",
      "whereJsonSubsetOf",
      "orWhereJsonSubsetOf",
      "andWhereJsonSubsetOf",
      "whereJsonNotSubsetOf",
      "orWhereJsonNotSubsetOf",
      "andWhereJsonNotSubsetOf"
    ];
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// node_modules/lodash/chunk.js
var require_chunk = __commonJS({
  "node_modules/lodash/chunk.js"(exports, module) {
    var baseSlice = require_baseSlice();
    var isIterateeCall = require_isIterateeCall();
    var toInteger = require_toInteger();
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
      while (index < length) {
        result[resIndex++] = baseSlice(array, index, index += size);
      }
      return result;
    }
    module.exports = chunk;
  }
});

// node_modules/knex/lib/execution/internal/delay.js
var require_delay = __commonJS({
  "node_modules/knex/lib/execution/internal/delay.js"(exports, module) {
    module.exports = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
  }
});

// node_modules/knex/lib/execution/batch-insert.js
var require_batch_insert = __commonJS({
  "node_modules/knex/lib/execution/batch-insert.js"(exports, module) {
    var chunk = require_chunk();
    var flatten = require_flatten();
    var delay = require_delay();
    var { isNumber } = require_is();
    function batchInsert(client, tableName, batch, chunkSize = 1e3) {
      let returning = void 0;
      let transaction = null;
      if (!isNumber(chunkSize) || chunkSize < 1) {
        throw new TypeError(`Invalid chunkSize: ${chunkSize}`);
      }
      if (!Array.isArray(batch)) {
        throw new TypeError(`Invalid batch: Expected array, got ${typeof batch}`);
      }
      const chunks = chunk(batch, chunkSize);
      const runInTransaction = (cb) => {
        if (transaction) {
          return cb(transaction);
        }
        return client.transaction(cb);
      };
      return Object.assign(
        Promise.resolve().then(async () => {
          await delay(1);
          return runInTransaction(async (tr) => {
            const chunksResults = [];
            for (const items of chunks) {
              chunksResults.push(await tr(tableName).insert(items, returning));
            }
            return flatten(chunksResults);
          });
        }),
        {
          returning(columns) {
            returning = columns;
            return this;
          },
          transacting(tr) {
            transaction = tr;
            return this;
          }
        }
      );
    }
    module.exports = batchInsert;
  }
});

// node_modules/knex/lib/util/security.js
var require_security = __commonJS({
  "node_modules/knex/lib/util/security.js"(exports, module) {
    function setHiddenProperty(target, source, propertyName = "password") {
      if (!source) {
        source = target;
      }
      Object.defineProperty(target, propertyName, {
        enumerable: false,
        value: source[propertyName]
      });
    }
    module.exports = {
      setHiddenProperty
    };
  }
});

// node_modules/knex/lib/knex-builder/make-knex.js
var require_make_knex = __commonJS({
  "node_modules/knex/lib/knex-builder/make-knex.js"(exports, module) {
    var { EventEmitter } = __require("events");
    var { Migrator } = require_Migrator();
    var Seeder = require_Seeder();
    var FunctionHelper = require_FunctionHelper();
    var QueryInterface = require_method_constants();
    var merge = require_merge();
    var batchInsert = require_batch_insert();
    var { isObject } = require_is();
    var { setHiddenProperty } = require_security();
    var KNEX_PROPERTY_DEFINITIONS = {
      client: {
        get() {
          return this.context.client;
        },
        set(client) {
          this.context.client = client;
        },
        configurable: true
      },
      userParams: {
        get() {
          return this.context.userParams;
        },
        set(userParams) {
          this.context.userParams = userParams;
        },
        configurable: true
      },
      schema: {
        get() {
          return this.client.schemaBuilder();
        },
        configurable: true
      },
      migrate: {
        get() {
          return new Migrator(this);
        },
        configurable: true
      },
      seed: {
        get() {
          return new Seeder(this);
        },
        configurable: true
      },
      fn: {
        get() {
          return new FunctionHelper(this.client);
        },
        configurable: true
      }
    };
    var CONTEXT_METHODS = [
      "raw",
      "batchInsert",
      "transaction",
      "transactionProvider",
      "initialize",
      "destroy",
      "ref",
      "withUserParams",
      "queryBuilder",
      "disableProcessing",
      "enableProcessing"
    ];
    for (const m3 of CONTEXT_METHODS) {
      KNEX_PROPERTY_DEFINITIONS[m3] = {
        value: function(...args) {
          return this.context[m3](...args);
        },
        configurable: true
      };
    }
    function makeKnex(client) {
      function knex2(tableName, options) {
        return createQueryBuilder(knex2.context, tableName, options);
      }
      redefineProperties(knex2, client);
      return knex2;
    }
    function initContext(knexFn) {
      const knexContext = knexFn.context || {};
      Object.assign(knexContext, {
        queryBuilder() {
          return this.client.queryBuilder();
        },
        raw() {
          return this.client.raw.apply(this.client, arguments);
        },
        batchInsert(table, batch, chunkSize = 1e3) {
          return batchInsert(this, table, batch, chunkSize);
        },
        // Creates a new transaction.
        // If container is provided, returns a promise for when the transaction is resolved.
        // If container is not provided, returns a promise with a transaction that is resolved
        // when transaction is ready to be used.
        transaction(container, _config) {
          if (!_config && isObject(container)) {
            _config = container;
            container = null;
          }
          const config = Object.assign({}, _config);
          config.userParams = this.userParams || {};
          if (config.doNotRejectOnRollback === void 0) {
            config.doNotRejectOnRollback = true;
          }
          return this._transaction(container, config);
        },
        // Internal method that actually establishes the Transaction.  It makes no assumptions
        // about the `config` or `outerTx`, and expects the caller to handle these details.
        _transaction(container, config, outerTx = null) {
          if (container) {
            const trx = this.client.transaction(container, config, outerTx);
            return trx;
          } else {
            return new Promise((resolve, reject) => {
              this.client.transaction(resolve, config, outerTx).catch(reject);
            });
          }
        },
        transactionProvider(config) {
          let trx;
          return () => {
            if (!trx) {
              trx = this.transaction(void 0, config);
            }
            return trx;
          };
        },
        // Typically never needed, initializes the pool for a knex client.
        initialize(config) {
          return this.client.initializePool(config);
        },
        // Convenience method for tearing down the pool.
        destroy(callback) {
          return this.client.destroy(callback);
        },
        ref(ref) {
          return this.client.ref(ref);
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to disable processing of internal queries in migrations
        disableProcessing() {
          if (this.userParams.isProcessingDisabled) {
            return;
          }
          this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;
          this.userParams.postProcessResponse = this.client.config.postProcessResponse;
          this.client.config.wrapIdentifier = null;
          this.client.config.postProcessResponse = null;
          this.userParams.isProcessingDisabled = true;
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
        enableProcessing() {
          if (!this.userParams.isProcessingDisabled) {
            return;
          }
          this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;
          this.client.config.postProcessResponse = this.userParams.postProcessResponse;
          this.userParams.isProcessingDisabled = false;
        },
        withUserParams(params) {
          const knexClone = shallowCloneFunction(knexFn);
          if (this.client) {
            knexClone.client = Object.create(this.client.constructor.prototype);
            merge(knexClone.client, this.client);
            knexClone.client.config = Object.assign({}, this.client.config);
            if (this.client.config.password) {
              setHiddenProperty(knexClone.client.config, this.client.config);
            }
          }
          redefineProperties(knexClone, knexClone.client);
          _copyEventListeners("query", knexFn, knexClone);
          _copyEventListeners("query-error", knexFn, knexClone);
          _copyEventListeners("query-response", knexFn, knexClone);
          _copyEventListeners("start", knexFn, knexClone);
          knexClone.userParams = params;
          return knexClone;
        }
      });
      if (!knexFn.context) {
        knexFn.context = knexContext;
      }
    }
    function _copyEventListeners(eventName, sourceKnex, targetKnex) {
      const listeners = sourceKnex.listeners(eventName);
      listeners.forEach((listener) => {
        targetKnex.on(eventName, listener);
      });
    }
    function redefineProperties(knex2, client) {
      for (let i3 = 0; i3 < QueryInterface.length; i3++) {
        const method = QueryInterface[i3];
        knex2[method] = function() {
          const builder = this.queryBuilder();
          return builder[method].apply(builder, arguments);
        };
      }
      Object.defineProperties(knex2, KNEX_PROPERTY_DEFINITIONS);
      initContext(knex2);
      knex2.client = client;
      knex2.userParams = {};
      const ee = new EventEmitter();
      for (const key in ee) {
        knex2[key] = ee[key];
      }
      if (knex2._internalListeners) {
        knex2._internalListeners.forEach(({ eventName, listener }) => {
          knex2.client.removeListener(eventName, listener);
        });
      }
      knex2._internalListeners = [];
      _addInternalListener(knex2, "start", (obj) => {
        knex2.emit("start", obj);
      });
      _addInternalListener(knex2, "query", (obj) => {
        knex2.emit("query", obj);
      });
      _addInternalListener(knex2, "query-error", (err, obj) => {
        knex2.emit("query-error", err, obj);
      });
      _addInternalListener(knex2, "query-response", (response, obj, builder) => {
        knex2.emit("query-response", response, obj, builder);
      });
    }
    function _addInternalListener(knex2, eventName, listener) {
      knex2.client.on(eventName, listener);
      knex2._internalListeners.push({
        eventName,
        listener
      });
    }
    function createQueryBuilder(knexContext, tableName, options) {
      const qb = knexContext.queryBuilder();
      if (!tableName)
        knexContext.client.logger.warn(
          "calling knex without a tableName is deprecated. Use knex.queryBuilder() instead."
        );
      return tableName ? qb.table(tableName, options) : qb;
    }
    function shallowCloneFunction(originalFunction) {
      const fnContext = Object.create(
        Object.getPrototypeOf(originalFunction),
        Object.getOwnPropertyDescriptors(originalFunction)
      );
      const knexContext = {};
      const knexFnWrapper = (tableName, options) => {
        return createQueryBuilder(knexContext, tableName, options);
      };
      const clonedFunction = knexFnWrapper.bind(fnContext);
      Object.assign(clonedFunction, originalFunction);
      clonedFunction.context = knexContext;
      return clonedFunction;
    }
    module.exports = makeKnex;
  }
});

// node_modules/knex/lib/util/noop.js
var require_noop2 = __commonJS({
  "node_modules/knex/lib/util/noop.js"(exports, module) {
    module.exports = function() {
    };
  }
});

// node_modules/knex/lib/util/finally-mixin.js
var require_finally_mixin = __commonJS({
  "node_modules/knex/lib/util/finally-mixin.js"(exports, module) {
    var noop = require_noop2();
    var finallyMixin = (prototype) => Object.assign(prototype, {
      finally(onFinally) {
        return this.then().finally(onFinally);
      }
    });
    module.exports = Promise.prototype.finally ? finallyMixin : noop;
  }
});

// node_modules/knex/lib/execution/transaction.js
var require_transaction = __commonJS({
  "node_modules/knex/lib/execution/transaction.js"(exports, module) {
    var { EventEmitter } = __require("events");
    var Debug = require_src();
    var uniqueId = require_uniqueId();
    var { callbackify } = __require("util");
    var makeKnex = require_make_knex();
    var { timeout, KnexTimeoutError } = require_timeout();
    var finallyMixin = require_finally_mixin();
    var debug = Debug("knex:tx");
    function DEFAULT_CONFIG() {
      return {
        userParams: {},
        doNotRejectOnRollback: true
      };
    }
    var validIsolationLevels = [
      // Doesn't really work in postgres, it treats it as read committed
      "read uncommitted",
      "read committed",
      "snapshot",
      // snapshot and repeatable read are basically the same, most "repeatable
      // read" implementations are actually "snapshot" also known as Multi Version
      // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop
      // repeated reads for inserts as it uses a pessimistic locking system so
      // you should probably use 'snapshot' to stop read skew.
      "repeatable read",
      // mysql pretends to have serializable, but it is not
      "serializable"
    ];
    var Transaction = class extends EventEmitter {
      constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {
        super();
        this.userParams = config.userParams;
        this.doNotRejectOnRollback = config.doNotRejectOnRollback;
        const txid = this.txid = uniqueId("trx");
        this.client = client;
        this.logger = client.logger;
        this.outerTx = outerTx;
        this.trxClient = void 0;
        this._completed = false;
        this._debug = client.config && client.config.debug;
        this.readOnly = config.readOnly;
        if (config.isolationLevel) {
          this.setIsolationLevel(config.isolationLevel);
        }
        debug(
          "%s: Starting %s transaction",
          txid,
          outerTx ? "nested" : "top level"
        );
        this._lastChild = Promise.resolve();
        const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();
        const basePromise = _previousSibling.then(
          () => this._evaluateContainer(config, container)
        );
        this._promise = basePromise.then((x3) => x3);
        if (outerTx) {
          outerTx._lastChild = basePromise.catch(() => {
          });
        }
      }
      isCompleted() {
        return this._completed || this.outerTx && this.outerTx.isCompleted() || false;
      }
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `SET TRANSACTION ${trxMode};`).then(
          () => this.query(conn, "BEGIN;")
        );
      }
      savepoint(conn) {
        return this.query(conn, `SAVEPOINT ${this.txid};`);
      }
      commit(conn, value) {
        return this.query(conn, "COMMIT;", 1, value);
      }
      release(conn, value) {
        return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);
      }
      setIsolationLevel(isolationLevel) {
        if (!validIsolationLevels.includes(isolationLevel)) {
          throw new Error(
            `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(
              validIsolationLevels
            )}`
          );
        }
        this.isolationLevel = isolationLevel;
        return this;
      }
      rollback(conn, error) {
        return timeout(this.query(conn, "ROLLBACK", 2, error), 5e3).catch(
          (err) => {
            if (!(err instanceof KnexTimeoutError)) {
              return Promise.reject(err);
            }
            this._rejecter(error);
          }
        );
      }
      rollbackTo(conn, error) {
        return timeout(
          this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),
          5e3
        ).catch((err) => {
          if (!(err instanceof KnexTimeoutError)) {
            return Promise.reject(err);
          }
          this._rejecter(error);
        });
      }
      query(conn, sql, status, value) {
        const q3 = this.trxClient.query(conn, sql).catch((err) => {
          status = 2;
          value = err;
          this._completed = true;
          debug("%s error running transaction query", this.txid);
        }).then((res) => {
          if (status === 1) {
            this._resolver(value);
          }
          if (status === 2) {
            if (value === void 0) {
              if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
                this._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            this._rejecter(value);
          }
          return res;
        });
        if (status === 1 || status === 2) {
          this._completed = true;
        }
        return q3;
      }
      debug(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      }
      async _evaluateContainer(config, container) {
        return this.acquireConnection(config, (connection) => {
          const trxClient = this.trxClient = makeTxClient(
            this,
            this.client,
            connection
          );
          const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);
          const executionPromise = new Promise((resolver, rejecter) => {
            this._resolver = resolver;
            this._rejecter = rejecter;
          });
          init.then(() => {
            return makeTransactor(this, connection, trxClient);
          }).then((transactor) => {
            this.transactor = transactor;
            if (this.outerTx) {
              transactor.parentTransaction = this.outerTx.transactor;
            }
            transactor.executionPromise = executionPromise;
            let result;
            try {
              result = container(transactor);
            } catch (err) {
              result = Promise.reject(err);
            }
            if (result && result.then && typeof result.then === "function") {
              result.then((val2) => {
                return transactor.commit(val2);
              }).catch((err) => {
                return transactor.rollback(err);
              });
            }
            return null;
          }).catch((e3) => {
            return this._rejecter(e3);
          });
          return executionPromise;
        });
      }
      // Acquire a connection and create a disposer - either using the one passed
      // via config or getting one off the client. The disposer will be called once
      // the original promise is marked completed.
      async acquireConnection(config, cb) {
        const configConnection = config && config.connection;
        const connection = configConnection || await this.client.acquireConnection();
        try {
          connection.__knexTxId = this.txid;
          return await cb(connection);
        } finally {
          if (!configConnection) {
            debug("%s: releasing connection", this.txid);
            this.client.releaseConnection(connection);
          } else {
            debug("%s: not releasing external connection", this.txid);
          }
        }
      }
      then(onResolve, onReject) {
        return this._promise.then(onResolve, onReject);
      }
      catch(...args) {
        return this._promise.catch(...args);
      }
      asCallback(cb) {
        callbackify(() => this._promise)(cb);
        return this._promise;
      }
    };
    finallyMixin(Transaction.prototype);
    function makeTransactor(trx, connection, trxClient) {
      const transactor = makeKnex(trxClient);
      transactor.context.withUserParams = () => {
        throw new Error(
          "Cannot set user params on a transaction - it can only inherit params from main knex instance"
        );
      };
      transactor.isTransaction = true;
      transactor.userParams = trx.userParams || {};
      transactor.context.transaction = function(container, options) {
        if (!options) {
          options = { doNotRejectOnRollback: true };
        } else if (options.doNotRejectOnRollback === void 0) {
          options.doNotRejectOnRollback = true;
        }
        return this._transaction(container, options, trx);
      };
      transactor.savepoint = function(container, options) {
        return transactor.transaction(container, options);
      };
      if (trx.client.transacting) {
        transactor.commit = (value) => trx.release(connection, value);
        transactor.rollback = (error) => trx.rollbackTo(connection, error);
      } else {
        transactor.commit = (value) => trx.commit(connection, value);
        transactor.rollback = (error) => trx.rollback(connection, error);
      }
      transactor.isCompleted = () => trx.isCompleted();
      return transactor;
    }
    function makeTxClient(trx, client, connection) {
      const trxClient = Object.create(client.constructor.prototype);
      trxClient.version = client.version;
      trxClient.config = client.config;
      trxClient.driver = client.driver;
      trxClient.connectionSettings = client.connectionSettings;
      trxClient.transacting = true;
      trxClient.valueForUndefined = client.valueForUndefined;
      trxClient.logger = client.logger;
      trxClient.on("start", function(arg) {
        trx.emit("start", arg);
        client.emit("start", arg);
      });
      trxClient.on("query", function(arg) {
        trx.emit("query", arg);
        client.emit("query", arg);
      });
      trxClient.on("query-error", function(err, obj) {
        trx.emit("query-error", err, obj);
        client.emit("query-error", err, obj);
      });
      trxClient.on("query-response", function(response, obj, builder) {
        trx.emit("query-response", response, obj, builder);
        client.emit("query-response", response, obj, builder);
      });
      const _query = trxClient.query;
      trxClient.query = function(conn, obj) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed) completedError(trx, obj);
            resolve(_query.call(trxClient, conn, obj));
          } catch (e3) {
            reject(e3);
          }
        });
      };
      const _stream = trxClient.stream;
      trxClient.stream = function(conn, obj, stream2, options) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed) completedError(trx, obj);
            resolve(_stream.call(trxClient, conn, obj, stream2, options));
          } catch (e3) {
            reject(e3);
          }
        });
      };
      trxClient.acquireConnection = function() {
        return Promise.resolve(connection);
      };
      trxClient.releaseConnection = function() {
        return Promise.resolve();
      };
      return trxClient;
    }
    function completedError(trx, obj) {
      const sql = typeof obj === "string" ? obj : obj && obj.sql;
      debug("%s: Transaction completed: %s", trx.txid, sql);
      throw new Error(
        "Transaction query already complete, run with DEBUG=knex:tx for more info"
      );
    }
    module.exports = Transaction;
  }
});

// node_modules/knex/lib/execution/internal/query-executioner.js
var require_query_executioner = __commonJS({
  "node_modules/knex/lib/execution/internal/query-executioner.js"(exports, module) {
    var _debugQuery = require_src()("knex:query");
    var debugBindings = require_src()("knex:bindings");
    var debugQuery = (sql, txId) => _debugQuery(sql.replace(/%/g, "%%"), txId);
    var { isString } = require_is();
    function formatQuery(sql, bindings, timeZone, client) {
      bindings = bindings == null ? [] : [].concat(bindings);
      let index = 0;
      return sql.replace(/\\?\?/g, (match) => {
        if (match === "\\?") {
          return "?";
        }
        if (index === bindings.length) {
          return match;
        }
        const value = bindings[index++];
        return client._escapeBinding(value, { timeZone });
      });
    }
    function enrichQueryObject(connection, queryParam, client) {
      const queryObject = isString(queryParam) ? { sql: queryParam } : queryParam;
      queryObject.bindings = client.prepBindings(queryObject.bindings);
      queryObject.sql = client.positionBindings(queryObject.sql);
      const { __knexUid, __knexTxId } = connection;
      client.emit("query", Object.assign({ __knexUid, __knexTxId }, queryObject));
      debugQuery(queryObject.sql, __knexTxId);
      debugBindings(queryObject.bindings, __knexTxId);
      return queryObject;
    }
    function executeQuery(connection, queryObject, client) {
      return client._query(connection, queryObject).catch((err) => {
        if (client.config && client.config.compileSqlOnError === false) {
          err.message = queryObject.sql + " - " + err.message;
        } else {
          err.message = formatQuery(queryObject.sql, queryObject.bindings, void 0, client) + " - " + err.message;
        }
        client.emit(
          "query-error",
          err,
          Object.assign(
            { __knexUid: connection.__knexUid, __knexTxId: connection.__knexUid },
            queryObject
          )
        );
        throw err;
      });
    }
    module.exports = {
      enrichQueryObject,
      executeQuery,
      formatQuery
    };
  }
});

// node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/lodash/assign.js"(exports, module) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module.exports = assign;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module.exports = clone;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports, module) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module.exports = forEach;
  }
});

// node_modules/lodash/each.js
var require_each = __commonJS({
  "node_modules/lodash/each.js"(exports, module) {
    module.exports = require_forEach();
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module.exports = baseFilter;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module.exports = negate;
  }
});

// node_modules/lodash/reject.js
var require_reject = __commonJS({
  "node_modules/lodash/reject.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    module.exports = reject;
  }
});

// node_modules/lodash/tail.js
var require_tail = __commonJS({
  "node_modules/lodash/tail.js"(exports, module) {
    var baseSlice = require_baseSlice();
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }
    module.exports = tail;
  }
});

// node_modules/lodash/_iteratorToArray.js
var require_iteratorToArray = __commonJS({
  "node_modules/lodash/_iteratorToArray.js"(exports, module) {
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    module.exports = iteratorToArray;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module) {
    function asciiToArray(string) {
      return string.split("");
    }
    module.exports = asciiToArray;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module.exports = stringToArray;
  }
});

// node_modules/lodash/toArray.js
var require_toArray = __commonJS({
  "node_modules/lodash/toArray.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var copyArray = require_copyArray();
    var getTag = require_getTag();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var iteratorToArray = require_iteratorToArray();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var stringToArray = require_stringToArray();
    var values = require_values();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var symIterator = Symbol2 ? Symbol2.iterator : void 0;
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
      return func(value);
    }
    module.exports = toArray;
  }
});

// node_modules/knex/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/knex/lib/constants.js"(exports, module) {
    var CLIENT_ALIASES = Object.freeze({
      pg: "postgres",
      postgresql: "postgres",
      sqlite: "sqlite3"
    });
    var SUPPORTED_CLIENTS = Object.freeze(
      [
        "mssql",
        "mysql",
        "mysql2",
        "oracledb",
        "postgres",
        "pgnative",
        "redshift",
        "sqlite3",
        "cockroachdb",
        "better-sqlite3"
      ].concat(Object.keys(CLIENT_ALIASES))
    );
    var DRIVER_NAMES = Object.freeze({
      MsSQL: "mssql",
      MySQL: "mysql",
      MySQL2: "mysql2",
      Oracle: "oracledb",
      PostgreSQL: "pg",
      PgNative: "pgnative",
      Redshift: "pg-redshift",
      SQLite: "sqlite3",
      CockroachDB: "cockroachdb",
      BetterSQLite3: "better-sqlite3"
    });
    var POOL_CONFIG_OPTIONS = Object.freeze([
      "maxWaitingClients",
      "testOnBorrow",
      "fifo",
      "priorityRange",
      "autostart",
      "evictionRunIntervalMillis",
      "numTestsPerRun",
      "softIdleTimeoutMillis",
      "Promise"
    ]);
    var COMMA_NO_PAREN_REGEX = /,[\s](?![^(]*\))/g;
    module.exports = {
      CLIENT_ALIASES,
      SUPPORTED_CLIENTS,
      POOL_CONFIG_OPTIONS,
      COMMA_NO_PAREN_REGEX,
      DRIVER_NAMES
    };
  }
});

// node_modules/knex/lib/util/helpers.js
var require_helpers = __commonJS({
  "node_modules/knex/lib/util/helpers.js"(exports, module) {
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var { CLIENT_ALIASES } = require_constants3();
    var { isFunction } = require_is();
    function normalizeArr(...args) {
      if (Array.isArray(args[0])) {
        return args[0];
      }
      return args;
    }
    function containsUndefined(mixed) {
      let argContainsUndefined = false;
      if (isTypedArray(mixed)) return false;
      if (mixed && isFunction(mixed.toSQL)) {
        return argContainsUndefined;
      }
      if (Array.isArray(mixed)) {
        for (let i3 = 0; i3 < mixed.length; i3++) {
          if (argContainsUndefined) break;
          argContainsUndefined = containsUndefined(mixed[i3]);
        }
      } else if (isPlainObject(mixed)) {
        Object.keys(mixed).forEach((key) => {
          if (!argContainsUndefined) {
            argContainsUndefined = containsUndefined(mixed[key]);
          }
        });
      } else {
        argContainsUndefined = mixed === void 0;
      }
      return argContainsUndefined;
    }
    function getUndefinedIndices(mixed) {
      const indices = [];
      if (Array.isArray(mixed)) {
        mixed.forEach((item, index) => {
          if (containsUndefined(item)) {
            indices.push(index);
          }
        });
      } else if (isPlainObject(mixed)) {
        Object.keys(mixed).forEach((key) => {
          if (containsUndefined(mixed[key])) {
            indices.push(key);
          }
        });
      } else {
        indices.push(0);
      }
      return indices;
    }
    function addQueryContext(Target) {
      Target.prototype.queryContext = function(context) {
        if (context === void 0) {
          return this._queryContext;
        }
        this._queryContext = context;
        return this;
      };
    }
    function resolveClientNameWithAliases(clientName) {
      return CLIENT_ALIASES[clientName] || clientName;
    }
    function toNumber(val2, fallback) {
      if (val2 === void 0 || val2 === null) return fallback;
      const number = parseInt(val2, 10);
      return isNaN(number) ? fallback : number;
    }
    module.exports = {
      addQueryContext,
      containsUndefined,
      getUndefinedIndices,
      normalizeArr,
      resolveClientNameWithAliases,
      toNumber
    };
  }
});

// node_modules/knex/lib/query/joinclause.js
var require_joinclause = __commonJS({
  "node_modules/knex/lib/query/joinclause.js"(exports, module) {
    var assert = __require("assert");
    function getClauseFromArguments(compilerType, bool, first, operator, second) {
      if (typeof first === "function") {
        return {
          type: "onWrapped",
          value: first,
          bool
        };
      }
      switch (arguments.length) {
        case 3:
          return { type: "onRaw", value: first, bool };
        case 4:
          return {
            type: compilerType,
            column: first,
            operator: "=",
            value: operator,
            bool
          };
        default:
          return {
            type: compilerType,
            column: first,
            operator,
            value: second,
            bool
          };
      }
    }
    var JoinClause = class {
      constructor(table, type, schema) {
        this.schema = schema;
        this.table = table;
        this.joinType = type;
        this.and = this;
        this.clauses = [];
      }
      get or() {
        return this._bool("or");
      }
      // Adds an "on" clause to the current join object.
      on(first) {
        if (typeof first === "object" && typeof first.toSQL !== "function") {
          const keys = Object.keys(first);
          let i3 = -1;
          const method = this._bool() === "or" ? "orOn" : "on";
          while (++i3 < keys.length) {
            this[method](keys[i3], first[keys[i3]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onBasic", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      }
      // Adds an "or on" clause to the current join object.
      orOn(first, operator, second) {
        return this._bool("or").on.apply(this, arguments);
      }
      onJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
        this.clauses.push({
          type: "onJsonPathEquals",
          columnFirst,
          jsonPathFirst,
          columnSecond,
          jsonPathSecond,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orOnJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
        return this._bool("or").onJsonPathEquals.apply(this, arguments);
      }
      // Adds a "using" clause to the current join.
      using(column) {
        return this.clauses.push({ type: "onUsing", column, bool: this._bool() });
      }
      onVal(first) {
        if (typeof first === "object" && typeof first.toSQL !== "function") {
          const keys = Object.keys(first);
          let i3 = -1;
          const method = this._bool() === "or" ? "orOnVal" : "onVal";
          while (++i3 < keys.length) {
            this[method](keys[i3], first[keys[i3]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onVal", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      }
      andOnVal() {
        return this.onVal(...arguments);
      }
      orOnVal() {
        return this._bool("or").onVal(...arguments);
      }
      onBetween(column, values) {
        assert(
          Array.isArray(values),
          "The second argument to onBetween must be an array."
        );
        assert(
          values.length === 2,
          "You must specify 2 values for the onBetween clause"
        );
        this.clauses.push({
          type: "onBetween",
          column,
          value: values,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      onNotBetween(column, values) {
        return this._not(true).onBetween(column, values);
      }
      orOnBetween(column, values) {
        return this._bool("or").onBetween(column, values);
      }
      orOnNotBetween(column, values) {
        return this._bool("or")._not(true).onBetween(column, values);
      }
      onIn(column, values) {
        if (Array.isArray(values) && values.length === 0) return this.on(1, "=", 0);
        this.clauses.push({
          type: "onIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      onNotIn(column, values) {
        return this._not(true).onIn(column, values);
      }
      orOnIn(column, values) {
        return this._bool("or").onIn(column, values);
      }
      orOnNotIn(column, values) {
        return this._bool("or")._not(true).onIn(column, values);
      }
      onNull(column) {
        this.clauses.push({
          type: "onNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orOnNull(callback) {
        return this._bool("or").onNull(callback);
      }
      onNotNull(callback) {
        return this._not(true).onNull(callback);
      }
      orOnNotNull(callback) {
        return this._not(true)._bool("or").onNull(callback);
      }
      onExists(callback) {
        this.clauses.push({
          type: "onExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orOnExists(callback) {
        return this._bool("or").onExists(callback);
      }
      onNotExists(callback) {
        return this._not(true).onExists(callback);
      }
      orOnNotExists(callback) {
        return this._not(true)._bool("or").onExists(callback);
      }
      // Explicitly set the type of join, useful within a function when creating a grouped join.
      type(type) {
        this.joinType = type;
        return this;
      }
      _bool(bool) {
        if (arguments.length === 1) {
          this._boolFlag = bool;
          return this;
        }
        const ret = this._boolFlag || "and";
        this._boolFlag = "and";
        return ret;
      }
      _not(val2) {
        if (arguments.length === 1) {
          this._notFlag = val2;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      }
    };
    Object.assign(JoinClause.prototype, {
      grouping: "join"
    });
    JoinClause.prototype.andOn = JoinClause.prototype.on;
    JoinClause.prototype.andOnIn = JoinClause.prototype.onIn;
    JoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;
    JoinClause.prototype.andOnNull = JoinClause.prototype.onNull;
    JoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;
    JoinClause.prototype.andOnExists = JoinClause.prototype.onExists;
    JoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;
    JoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;
    JoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;
    JoinClause.prototype.andOnJsonPathEquals = JoinClause.prototype.onJsonPathEquals;
    module.exports = JoinClause;
  }
});

// node_modules/knex/lib/query/analytic.js
var require_analytic = __commonJS({
  "node_modules/knex/lib/query/analytic.js"(exports, module) {
    var assert = __require("assert");
    var Analytic = class {
      constructor(method, schema, alias, orderBy, partitions) {
        this.schema = schema;
        this.type = "analytic";
        this.method = method;
        this.order = orderBy || [];
        this.partitions = partitions || [];
        this.alias = alias;
        this.and = this;
        this.grouping = "columns";
      }
      partitionBy(column, direction) {
        assert(
          Array.isArray(column) || typeof column === "string",
          `The argument to an analytic partitionBy function must be either a string
            or an array of string.`
        );
        if (Array.isArray(column)) {
          this.partitions = this.partitions.concat(column);
        } else {
          this.partitions.push({ column, order: direction });
        }
        return this;
      }
      orderBy(column, direction) {
        assert(
          Array.isArray(column) || typeof column === "string",
          `The argument to an analytic orderBy function must be either a string
            or an array of string.`
        );
        if (Array.isArray(column)) {
          this.order = this.order.concat(column);
        } else {
          this.order.push({ column, order: direction });
        }
        return this;
      }
    };
    module.exports = Analytic;
  }
});

// node_modules/knex/lib/util/save-async-stack.js
var require_save_async_stack = __commonJS({
  "node_modules/knex/lib/util/save-async-stack.js"(exports, module) {
    module.exports = function saveAsyncStack(instance, lines) {
      if (instance.client.config.asyncStackTraces) {
        instance._asyncStack = {
          error: new Error(),
          lines
        };
      }
    };
  }
});

// node_modules/knex/lib/query/constants.js
var require_constants4 = __commonJS({
  "node_modules/knex/lib/query/constants.js"(exports, module) {
    module.exports = {
      lockMode: {
        forShare: "forShare",
        forUpdate: "forUpdate",
        forNoKeyUpdate: "forNoKeyUpdate",
        forKeyShare: "forKeyShare"
      },
      waitMode: {
        skipLocked: "skipLocked",
        noWait: "noWait"
      }
    };
  }
});

// node_modules/knex/lib/builder-interface-augmenter.js
var require_builder_interface_augmenter = __commonJS({
  "node_modules/knex/lib/builder-interface-augmenter.js"(exports, module) {
    var clone = require_clone();
    var isEmpty = require_isEmpty();
    var { callbackify } = __require("util");
    var finallyMixin = require_finally_mixin();
    var { formatQuery } = require_query_executioner();
    function augmentWithBuilderInterface(Target) {
      Target.prototype.toQuery = function(tz) {
        let data = this.toSQL(this._method, tz);
        if (!Array.isArray(data)) data = [data];
        if (!data.length) {
          return "";
        }
        return data.map((statement) => {
          return formatQuery(statement.sql, statement.bindings, tz, this.client);
        }).reduce((a3, c3) => a3.concat(a3.endsWith(";") ? "\n" : ";\n", c3));
      };
      Target.prototype.then = function() {
        let result = this.client.runner(this).run();
        if (this.client.config.asyncStackTraces) {
          result = result.catch((err) => {
            err.originalStack = err.stack;
            const firstLine = err.stack.split("\n")[0];
            const { error, lines } = this._asyncStack;
            const stackByLines = error.stack.split("\n");
            const asyncStack = stackByLines.slice(lines);
            asyncStack.unshift(firstLine);
            err.stack = asyncStack.join("\n");
            throw err;
          });
        }
        return result.then.apply(result, arguments);
      };
      Target.prototype.options = function(opts) {
        this._options = this._options || [];
        this._options.push(clone(opts) || {});
        return this;
      };
      Target.prototype.connection = function(connection) {
        this._connection = connection;
        this.client.processPassedConnection(connection);
        return this;
      };
      Target.prototype.debug = function(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      };
      Target.prototype.transacting = function(transaction) {
        if (transaction && transaction.client) {
          if (!transaction.client.transacting) {
            transaction.client.logger.warn(
              `Invalid transaction value: ${transaction.client}`
            );
          } else {
            this.client = transaction.client;
          }
        }
        if (isEmpty(transaction)) {
          this.client.logger.error(
            "Invalid value on transacting call, potential bug"
          );
          throw Error(
            "Invalid transacting value (null, undefined or empty object)"
          );
        }
        return this;
      };
      Target.prototype.stream = function(options) {
        return this.client.runner(this).stream(options);
      };
      Target.prototype.pipe = function(writable, options) {
        return this.client.runner(this).pipe(writable, options);
      };
      Target.prototype.asCallback = function(cb) {
        const promise = this.then();
        callbackify(() => promise)(cb);
        return promise;
      };
      Target.prototype.catch = function(onReject) {
        return this.then().catch(onReject);
      };
      Object.defineProperty(Target.prototype, Symbol.toStringTag, {
        get: () => "object"
      });
      finallyMixin(Target.prototype);
    }
    module.exports = {
      augmentWithBuilderInterface
    };
  }
});

// node_modules/knex/lib/query/querybuilder.js
var require_querybuilder = __commonJS({
  "node_modules/knex/lib/query/querybuilder.js"(exports, module) {
    var assert = __require("assert");
    var { EventEmitter } = __require("events");
    var assign = require_assign();
    var clone = require_clone();
    var each = require_each();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var last = require_last();
    var reject = require_reject();
    var tail = require_tail();
    var toArray = require_toArray();
    var { addQueryContext, normalizeArr } = require_helpers();
    var JoinClause = require_joinclause();
    var Analytic = require_analytic();
    var saveAsyncStack = require_save_async_stack();
    var {
      isBoolean,
      isNumber,
      isObject,
      isString,
      isFunction
    } = require_is();
    var { lockMode, waitMode } = require_constants4();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var SELECT_COMMANDS = /* @__PURE__ */ new Set(["pluck", "first", "select"]);
    var CLEARABLE_STATEMENTS = /* @__PURE__ */ new Set([
      "with",
      "select",
      "columns",
      "hintComments",
      "where",
      "union",
      "join",
      "group",
      "order",
      "having",
      "limit",
      "offset",
      "counter",
      "counters"
    ]);
    var LOCK_MODES = /* @__PURE__ */ new Set([
      lockMode.forShare,
      lockMode.forUpdate,
      lockMode.forNoKeyUpdate,
      lockMode.forKeyShare
    ]);
    var Builder = class _Builder extends EventEmitter {
      constructor(client) {
        super();
        this.client = client;
        this.and = this;
        this._single = {};
        this._comments = [];
        this._statements = [];
        this._method = "select";
        if (client.config) {
          saveAsyncStack(this, 5);
          this._debug = client.config.debug;
        }
        this._joinFlag = "inner";
        this._boolFlag = "and";
        this._notFlag = false;
        this._asColumnFlag = false;
      }
      toString() {
        return this.toQuery();
      }
      // Convert the current query "toSQL"
      toSQL(method, tz) {
        return this.client.queryCompiler(this).toSQL(method || this._method, tz);
      }
      // Create a shallow clone of the current query builder.
      clone() {
        const cloned = new this.constructor(this.client);
        cloned._method = this._method;
        cloned._single = clone(this._single);
        cloned._comments = clone(this._comments);
        cloned._statements = clone(this._statements);
        cloned._debug = this._debug;
        if (this._options !== void 0) {
          cloned._options = clone(this._options);
        }
        if (this._queryContext !== void 0) {
          cloned._queryContext = clone(this._queryContext);
        }
        if (this._connection !== void 0) {
          cloned._connection = this._connection;
        }
        return cloned;
      }
      timeout(ms, { cancel } = {}) {
        if (isNumber(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      }
      // With
      // ------
      isValidStatementArg(statement) {
        return typeof statement === "function" || statement instanceof _Builder || statement && statement.isRawInstance;
      }
      _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {
        const [query, columnList] = typeof nothingOrStatement === "undefined" ? [statementOrColumnList, void 0] : [nothingOrStatement, statementOrColumnList];
        if (typeof alias !== "string") {
          throw new Error(`${method}() first argument must be a string`);
        }
        if (this.isValidStatementArg(query) && typeof columnList === "undefined") {
          return;
        }
        const isNonEmptyNameList = Array.isArray(columnList) && columnList.length > 0 && columnList.every((it) => typeof it === "string");
        if (!isNonEmptyNameList) {
          throw new Error(
            `${method}() second argument must be a statement or non-empty column name list.`
          );
        }
        if (this.isValidStatementArg(query)) {
          return;
        }
        throw new Error(
          `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`
        );
      }
      with(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
      }
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        throw new Error("With materialized is not supported by this dialect");
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        throw new Error("With materialized is not supported by this dialect");
      }
      // Helper for compiling any advanced `with` queries.
      withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {
        const [query, columnList] = typeof nothingOrStatement === "undefined" ? [statementOrColumnList, void 0] : [nothingOrStatement, statementOrColumnList];
        const statement = {
          grouping: "with",
          type: "withWrapped",
          alias,
          columnList,
          value: query
        };
        if (materialized !== void 0) {
          statement.materialized = materialized;
        }
        this._statements.push(statement);
        return this;
      }
      // With Recursive
      // ------
      withRecursive(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "withRecursive"
        );
        return this.withRecursiveWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement
        );
      }
      // Helper for compiling any advanced `withRecursive` queries.
      withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {
        this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
        this._statements[this._statements.length - 1].recursive = true;
        return this;
      }
      // Select
      // ------
      // Adds a column or columns to the list of "columns"
      // being selected on the query.
      columns(column) {
        if (!column && column !== 0) return this;
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...arguments)
        });
        return this;
      }
      // Adds a comment to the query
      comment(txt) {
        if (!isString(txt)) {
          throw new Error("Comment must be a string");
        }
        const forbiddenChars = ["/*", "*/", "?"];
        if (forbiddenChars.some((chars) => txt.includes(chars))) {
          throw new Error(`Cannot include ${forbiddenChars.join(", ")} in comment`);
        }
        this._comments.push({
          comment: txt
        });
        return this;
      }
      // Allow for a sub-select to be explicitly aliased as a column,
      // without needing to compile the query in a where.
      as(column) {
        this._single.as = column;
        return this;
      }
      // Adds a single hint or an array of hits to the list of "hintComments" on the query.
      hintComment(hints) {
        hints = Array.isArray(hints) ? hints : [hints];
        if (hints.some((hint) => !isString(hint))) {
          throw new Error("Hint comment must be a string");
        }
        if (hints.some((hint) => hint.includes("/*") || hint.includes("*/"))) {
          throw new Error('Hint comment cannot include "/*" or "*/"');
        }
        if (hints.some((hint) => hint.includes("?"))) {
          throw new Error('Hint comment cannot include "?"');
        }
        this._statements.push({
          grouping: "hintComments",
          value: hints
        });
        return this;
      }
      // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
      withSchema(schemaName) {
        this._single.schema = schemaName;
        return this;
      }
      // Sets the `tableName` on the query.
      // Alias to "from" for select and "into" for insert statements
      // e.g. builder.insert({a: value}).into('tableName')
      // `options`: options object containing keys:
      //   - `only`: whether the query should use SQL's ONLY to not return
      //           inheriting table data. Defaults to false.
      table(tableName, options = {}) {
        this._single.table = tableName;
        this._single.only = options.only === true;
        return this;
      }
      // Adds a `distinct` clause to the query.
      distinct(...args) {
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...args),
          distinct: true
        });
        return this;
      }
      distinctOn(...args) {
        if (isEmpty(args)) {
          throw new Error("distinctOn requires at least on argument");
        }
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...args),
          distinctOn: true
        });
        return this;
      }
      // Adds a join clause to the query, allowing for advanced joins
      // with an anonymous function as the second argument.
      join(table, first, ...args) {
        let join;
        const schema = table instanceof _Builder || typeof table === "function" ? void 0 : this._single.schema;
        const joinType = this._joinType();
        if (typeof first === "function") {
          join = new JoinClause(table, joinType, schema);
          first.call(join, join);
        } else if (joinType === "raw") {
          join = new JoinClause(this.client.raw(table, first), "raw");
        } else {
          join = new JoinClause(table, joinType, schema);
          if (first) {
            join.on(first, ...args);
          }
        }
        this._statements.push(join);
        return this;
      }
      using(tables) {
        throw new Error(
          "'using' function is only available in PostgreSQL dialect with Delete statements."
        );
      }
      // JOIN blocks:
      innerJoin(...args) {
        return this._joinType("inner").join(...args);
      }
      leftJoin(...args) {
        return this._joinType("left").join(...args);
      }
      leftOuterJoin(...args) {
        return this._joinType("left outer").join(...args);
      }
      rightJoin(...args) {
        return this._joinType("right").join(...args);
      }
      rightOuterJoin(...args) {
        return this._joinType("right outer").join(...args);
      }
      outerJoin(...args) {
        return this._joinType("outer").join(...args);
      }
      fullOuterJoin(...args) {
        return this._joinType("full outer").join(...args);
      }
      crossJoin(...args) {
        return this._joinType("cross").join(...args);
      }
      joinRaw(...args) {
        return this._joinType("raw").join(...args);
      }
      // Where modifiers:
      get or() {
        return this._bool("or");
      }
      get not() {
        return this._not(true);
      }
      // The where function can be used in several ways:
      // The most basic is `where(key, value)`, which expands to
      // where key = value.
      where(column, operator, value) {
        const argsLength = arguments.length;
        if (column === false || column === true) {
          return this.where(1, "=", column ? 1 : 0);
        }
        if (typeof column === "function") {
          return this.whereWrapped(column);
        }
        if (isObject(column) && !column.isRawInstance)
          return this._objectWhere(column);
        if (column && column.isRawInstance && argsLength === 1)
          return this.whereRaw(column);
        if (argsLength === 2) {
          value = operator;
          operator = "=";
          if (value === null) {
            return this.whereNull(column);
          }
        }
        const checkOperator = `${operator}`.toLowerCase().trim();
        if (argsLength === 3) {
          if (checkOperator === "in" || checkOperator === "not in") {
            return this._not(checkOperator === "not in").whereIn(column, value);
          }
          if (checkOperator === "between" || checkOperator === "not between") {
            return this._not(checkOperator === "not between").whereBetween(
              column,
              value
            );
          }
        }
        if (value === null) {
          if (checkOperator === "is" || checkOperator === "is not") {
            return this._not(checkOperator === "is not").whereNull(column);
          }
        }
        this._statements.push({
          grouping: "where",
          type: "whereBasic",
          column,
          operator,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        });
        return this;
      }
      whereColumn(...args) {
        this._asColumnFlag = true;
        this.where(...args);
        this._asColumnFlag = false;
        return this;
      }
      // Adds an `or where` clause to the query.
      orWhere(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.whereWrapped(function() {
            for (const key in obj) {
              this.andWhere(key, obj[key]);
            }
          });
        }
        return this.where(column, ...args);
      }
      orWhereColumn(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.whereWrapped(function() {
            for (const key in obj) {
              this.andWhereColumn(key, "=", obj[key]);
            }
          });
        }
        return this.whereColumn(column, ...args);
      }
      // Adds an `not where` clause to the query.
      whereNot(column, ...args) {
        if (args.length >= 2) {
          if (args[0] === "in" || args[0] === "between") {
            this.client.logger.warn(
              'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
            );
          }
        }
        return this._not(true).where(column, ...args);
      }
      whereNotColumn(...args) {
        return this._not(true).whereColumn(...args);
      }
      // Adds an `or not where` clause to the query.
      orWhereNot(...args) {
        return this._bool("or").whereNot(...args);
      }
      orWhereNotColumn(...args) {
        return this._bool("or").whereNotColumn(...args);
      }
      // Processes an object literal provided in a "where" clause.
      _objectWhere(obj) {
        const boolVal = this._bool();
        const notVal = this._not() ? "Not" : "";
        for (const key in obj) {
          this[boolVal + "Where" + notVal](key, obj[key]);
        }
        return this;
      }
      // Adds a raw `where` clause to the query.
      whereRaw(sql, bindings) {
        const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "where",
          type: "whereRaw",
          value: raw,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orWhereRaw(sql, bindings) {
        return this._bool("or").whereRaw(sql, bindings);
      }
      // Helper for compiling any advanced `where` queries.
      whereWrapped(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereWrapped",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `where exists` clause to the query.
      whereExists(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds an `or where exists` clause to the query.
      orWhereExists(callback) {
        return this._bool("or").whereExists(callback);
      }
      // Adds a `where not exists` clause to the query.
      whereNotExists(callback) {
        return this._not(true).whereExists(callback);
      }
      // Adds a `or where not exists` clause to the query.
      orWhereNotExists(callback) {
        return this._bool("or").whereNotExists(callback);
      }
      // Adds a `where in` clause to the query.
      whereIn(column, values) {
        if (Array.isArray(values) && isEmpty(values))
          return this.where(this._not());
        this._statements.push({
          grouping: "where",
          type: "whereIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where in` clause to the query.
      orWhereIn(column, values) {
        return this._bool("or").whereIn(column, values);
      }
      // Adds a `where not in` clause to the query.
      whereNotIn(column, values) {
        return this._not(true).whereIn(column, values);
      }
      // Adds a `or where not in` clause to the query.
      orWhereNotIn(column, values) {
        return this._bool("or")._not(true).whereIn(column, values);
      }
      // Adds a `where null` clause to the query.
      whereNull(column) {
        this._statements.push({
          grouping: "where",
          type: "whereNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where null` clause to the query.
      orWhereNull(column) {
        return this._bool("or").whereNull(column);
      }
      // Adds a `where not null` clause to the query.
      whereNotNull(column) {
        return this._not(true).whereNull(column);
      }
      // Adds a `or where not null` clause to the query.
      orWhereNotNull(column) {
        return this._bool("or").whereNotNull(column);
      }
      // Adds a `where between` clause to the query.
      whereBetween(column, values) {
        assert(
          Array.isArray(values),
          "The second argument to whereBetween must be an array."
        );
        assert(
          values.length === 2,
          "You must specify 2 values for the whereBetween clause"
        );
        this._statements.push({
          grouping: "where",
          type: "whereBetween",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `where not between` clause to the query.
      whereNotBetween(column, values) {
        return this._not(true).whereBetween(column, values);
      }
      // Adds a `or where between` clause to the query.
      orWhereBetween(column, values) {
        return this._bool("or").whereBetween(column, values);
      }
      // Adds a `or where not between` clause to the query.
      orWhereNotBetween(column, values) {
        return this._bool("or").whereNotBetween(column, values);
      }
      _whereLike(type, column, value) {
        this._statements.push({
          grouping: "where",
          type,
          column,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        });
        return this;
      }
      // Adds a `where like` clause to the query.
      whereLike(column, value) {
        return this._whereLike("whereLike", column, value);
      }
      // Adds a `or where like` clause to the query.
      orWhereLike(column, value) {
        return this._bool("or")._whereLike("whereLike", column, value);
      }
      // Adds a `where ilike` clause to the query.
      whereILike(column, value) {
        return this._whereLike("whereILike", column, value);
      }
      // Adds a `or where ilike` clause to the query.
      orWhereILike(column, value) {
        return this._bool("or")._whereLike("whereILike", column, value);
      }
      // Adds a `group by` clause to the query.
      groupBy(item) {
        if (item && item.isRawInstance) {
          return this.groupByRaw.apply(this, arguments);
        }
        this._statements.push({
          grouping: "group",
          type: "groupByBasic",
          value: normalizeArr(...arguments)
        });
        return this;
      }
      // Adds a raw `group by` clause to the query.
      groupByRaw(sql, bindings) {
        const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "group",
          type: "groupByRaw",
          value: raw
        });
        return this;
      }
      // Adds a `order by` clause to the query.
      orderBy(column, direction, nulls = "") {
        if (Array.isArray(column)) {
          return this._orderByArray(column);
        }
        this._statements.push({
          grouping: "order",
          type: "orderByBasic",
          value: column,
          direction,
          nulls
        });
        return this;
      }
      // Adds a `order by` with multiple columns to the query.
      _orderByArray(columnDefs) {
        for (let i3 = 0; i3 < columnDefs.length; i3++) {
          const columnInfo = columnDefs[i3];
          if (isObject(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo["column"],
              direction: columnInfo["order"],
              nulls: columnInfo["nulls"]
            });
          } else if (isString(columnInfo) || isNumber(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo
            });
          }
        }
        return this;
      }
      // Add a raw `order by` clause to the query.
      orderByRaw(sql, bindings) {
        const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "order",
          type: "orderByRaw",
          value: raw
        });
        return this;
      }
      _union(clause, args) {
        let callbacks = args[0];
        let wrap = args[1];
        if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {
          if (!Array.isArray(callbacks)) {
            callbacks = [callbacks];
          }
          for (let i3 = 0, l3 = callbacks.length; i3 < l3; i3++) {
            this._statements.push({
              grouping: "union",
              clause,
              value: callbacks[i3],
              wrap: wrap || false
            });
          }
        } else {
          callbacks = toArray(args).slice(0, args.length - 1);
          wrap = args[args.length - 1];
          if (!isBoolean(wrap)) {
            callbacks.push(wrap);
            wrap = false;
          }
          this._union(clause, [callbacks, wrap]);
        }
        return this;
      }
      // Add a union statement to the query.
      union(...args) {
        return this._union("union", args);
      }
      // Adds a union all statement to the query.
      unionAll(...args) {
        return this._union("union all", args);
      }
      intersect(...args) {
        return this._union("intersect", args);
      }
      except(...args) {
        return this._union("except", args);
      }
      // Adds a `having` clause to the query.
      having(column, operator, value) {
        if (column.isRawInstance && arguments.length === 1) {
          return this.havingRaw(column);
        }
        if (typeof column === "function") {
          return this.havingWrapped(column);
        }
        this._statements.push({
          grouping: "having",
          type: "havingBasic",
          column,
          operator,
          value,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orHaving(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.havingWrapped(function() {
            for (const key in obj) {
              this.andHaving(key, obj[key]);
            }
          });
        }
        return this.having(column, ...args);
      }
      // Helper for compiling any advanced `having` queries.
      havingWrapped(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingWrapped",
          value: callback,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      havingNull(column) {
        this._statements.push({
          grouping: "having",
          type: "havingNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingNull(callback) {
        return this._bool("or").havingNull(callback);
      }
      havingNotNull(callback) {
        return this._not(true).havingNull(callback);
      }
      orHavingNotNull(callback) {
        return this._not(true)._bool("or").havingNull(callback);
      }
      havingExists(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingExists(callback) {
        return this._bool("or").havingExists(callback);
      }
      havingNotExists(callback) {
        return this._not(true).havingExists(callback);
      }
      orHavingNotExists(callback) {
        return this._not(true)._bool("or").havingExists(callback);
      }
      havingBetween(column, values) {
        assert(
          Array.isArray(values),
          "The second argument to havingBetween must be an array."
        );
        assert(
          values.length === 2,
          "You must specify 2 values for the havingBetween clause"
        );
        this._statements.push({
          grouping: "having",
          type: "havingBetween",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingBetween(column, values) {
        return this._bool("or").havingBetween(column, values);
      }
      havingNotBetween(column, values) {
        return this._not(true).havingBetween(column, values);
      }
      orHavingNotBetween(column, values) {
        return this._not(true)._bool("or").havingBetween(column, values);
      }
      havingIn(column, values) {
        if (Array.isArray(values) && isEmpty(values))
          return this.where(this._not());
        this._statements.push({
          grouping: "having",
          type: "havingIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where in` clause to the query.
      orHavingIn(column, values) {
        return this._bool("or").havingIn(column, values);
      }
      // Adds a `where not in` clause to the query.
      havingNotIn(column, values) {
        return this._not(true).havingIn(column, values);
      }
      // Adds a `or where not in` clause to the query.
      orHavingNotIn(column, values) {
        return this._bool("or")._not(true).havingIn(column, values);
      }
      // Adds a raw `having` clause to the query.
      havingRaw(sql, bindings) {
        const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "having",
          type: "havingRaw",
          value: raw,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orHavingRaw(sql, bindings) {
        return this._bool("or").havingRaw(sql, bindings);
      }
      // set the skip binding parameter (= insert the raw value in the query) for an attribute.
      _setSkipBinding(attribute, options) {
        let skipBinding = options;
        if (isObject(options)) {
          skipBinding = options.skipBinding;
        }
        this._single.skipBinding = this._single.skipBinding || {};
        this._single.skipBinding[attribute] = skipBinding;
      }
      // Only allow a single "offset" to be set for the current query.
      offset(value, options) {
        if (value == null || value.isRawInstance || value instanceof _Builder) {
          this._single.offset = value;
        } else {
          const val2 = parseInt(value, 10);
          if (isNaN(val2)) {
            this.client.logger.warn("A valid integer must be provided to offset");
          } else if (val2 < 0) {
            throw new Error(`A non-negative integer must be provided to offset.`);
          } else {
            this._single.offset = val2;
          }
        }
        this._setSkipBinding("offset", options);
        return this;
      }
      // Only allow a single "limit" to be set for the current query.
      limit(value, options) {
        const val2 = parseInt(value, 10);
        if (isNaN(val2)) {
          this.client.logger.warn("A valid integer must be provided to limit");
        } else {
          this._single.limit = val2;
          this._setSkipBinding("limit", options);
        }
        return this;
      }
      // Retrieve the "count" result of the query.
      count(column, options) {
        return this._aggregate("count", column || "*", options);
      }
      // Retrieve the minimum value of a given column.
      min(column, options) {
        return this._aggregate("min", column, options);
      }
      // Retrieve the maximum value of a given column.
      max(column, options) {
        return this._aggregate("max", column, options);
      }
      // Retrieve the sum of the values of a given column.
      sum(column, options) {
        return this._aggregate("sum", column, options);
      }
      // Retrieve the average of the values of a given column.
      avg(column, options) {
        return this._aggregate("avg", column, options);
      }
      // Retrieve the "count" of the distinct results of the query.
      countDistinct(...columns) {
        let options;
        if (columns.length > 1 && isPlainObject(last(columns))) {
          [options] = columns.splice(columns.length - 1, 1);
        }
        if (!columns.length) {
          columns = "*";
        } else if (columns.length === 1) {
          columns = columns[0];
        }
        return this._aggregate("count", columns, { ...options, distinct: true });
      }
      // Retrieve the sum of the distinct values of a given column.
      sumDistinct(column, options) {
        return this._aggregate("sum", column, { ...options, distinct: true });
      }
      // Retrieve the vg of the distinct results of the query.
      avgDistinct(column, options) {
        return this._aggregate("avg", column, { ...options, distinct: true });
      }
      // Increments a column's value by the specified amount.
      increment(column, amount = 1) {
        if (isObject(column)) {
          for (const key in column) {
            this._counter(key, column[key]);
          }
          return this;
        }
        return this._counter(column, amount);
      }
      // Decrements a column's value by the specified amount.
      decrement(column, amount = 1) {
        if (isObject(column)) {
          for (const key in column) {
            this._counter(key, -column[key]);
          }
          return this;
        }
        return this._counter(column, -amount);
      }
      // Clears increments/decrements
      clearCounters() {
        this._single.counter = {};
        return this;
      }
      // Sets the values for a `select` query, informing that only the first
      // row should be returned (limit 1).
      first(...args) {
        if (this._method && this._method !== "select") {
          throw new Error(`Cannot chain .first() on "${this._method}" query`);
        }
        this.select(normalizeArr(...args));
        this._method = "first";
        this.limit(1);
        return this;
      }
      // Use existing connection to execute the query
      // Same value that client.acquireConnection() for an according client returns should be passed
      connection(_connection) {
        this._connection = _connection;
        this.client.processPassedConnection(_connection);
        return this;
      }
      // Pluck a column from a query.
      pluck(column) {
        if (this._method && this._method !== "select") {
          throw new Error(`Cannot chain .pluck() on "${this._method}" query`);
        }
        this._method = "pluck";
        this._single.pluck = column;
        this._statements.push({
          grouping: "columns",
          type: "pluck",
          value: column
        });
        return this;
      }
      // Deprecated. Remove everything from select clause
      clearSelect() {
        this._clearGrouping("columns");
        return this;
      }
      // Deprecated. Remove everything from where clause
      clearWhere() {
        this._clearGrouping("where");
        return this;
      }
      // Deprecated. Remove everything from group clause
      clearGroup() {
        this._clearGrouping("group");
        return this;
      }
      // Deprecated. Remove everything from order clause
      clearOrder() {
        this._clearGrouping("order");
        return this;
      }
      // Deprecated. Remove everything from having clause
      clearHaving() {
        this._clearGrouping("having");
        return this;
      }
      // Remove everything from statement clause
      clear(statement) {
        if (!CLEARABLE_STATEMENTS.has(statement))
          throw new Error(`Knex Error: unknown statement '${statement}'`);
        if (statement.startsWith("counter")) return this.clearCounters();
        if (statement === "select") {
          statement = "columns";
        }
        this._clearGrouping(statement);
        return this;
      }
      // Insert & Update
      // ------
      // Sets the values for an `insert` query.
      insert(values, returning, options) {
        this._method = "insert";
        if (!isEmpty(returning)) this.returning(returning, options);
        this._single.insert = values;
        return this;
      }
      // Sets the values for an `update`, allowing for both
      // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
      update(values, returning, options) {
        let ret;
        const obj = this._single.update || {};
        this._method = "update";
        if (isString(values)) {
          if (isPlainObject(returning)) {
            obj[values] = JSON.stringify(returning);
          } else {
            obj[values] = returning;
          }
          if (arguments.length > 2) {
            ret = arguments[2];
          }
        } else {
          const keys = Object.keys(values);
          if (this._single.update) {
            this.client.logger.warn("Update called multiple times with objects.");
          }
          let i3 = -1;
          while (++i3 < keys.length) {
            obj[keys[i3]] = values[keys[i3]];
          }
          ret = arguments[1];
        }
        if (!isEmpty(ret)) this.returning(ret, options);
        this._single.update = obj;
        return this;
      }
      // Sets the returning value for the query.
      returning(returning, options) {
        this._single.returning = returning;
        this._single.options = options;
        return this;
      }
      onConflict(columns) {
        if (typeof columns === "string") {
          columns = [columns];
        }
        return new OnConflictBuilder(this, columns || true);
      }
      // Delete
      // ------
      // Executes a delete statement on the query;
      delete(ret, options) {
        this._method = "del";
        if (!isEmpty(ret)) this.returning(ret, options);
        return this;
      }
      // Truncates a table, ends the query chain.
      truncate(tableName) {
        this._method = "truncate";
        if (tableName) {
          this._single.table = tableName;
        }
        return this;
      }
      // Retrieves columns for the table specified by `knex(tableName)`
      columnInfo(column) {
        this._method = "columnInfo";
        this._single.columnInfo = column;
        return this;
      }
      // Set a lock for update constraint.
      forUpdate(...tables) {
        this._single.lock = lockMode.forUpdate;
        if (tables.length === 1 && Array.isArray(tables[0])) {
          this._single.lockTables = tables[0];
        } else {
          this._single.lockTables = tables;
        }
        return this;
      }
      // Set a lock for share constraint.
      forShare(...tables) {
        this._single.lock = lockMode.forShare;
        this._single.lockTables = tables;
        return this;
      }
      // Set a lock for no key update constraint.
      forNoKeyUpdate(...tables) {
        this._single.lock = lockMode.forNoKeyUpdate;
        this._single.lockTables = tables;
        return this;
      }
      // Set a lock for key share constraint.
      forKeyShare(...tables) {
        this._single.lock = lockMode.forKeyShare;
        this._single.lockTables = tables;
        return this;
      }
      // Skips locked rows when using a lock constraint.
      skipLocked() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".skipLocked() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.noWait) {
          throw new Error(".skipLocked() cannot be used together with .noWait()!");
        }
        this._single.waitMode = waitMode.skipLocked;
        return this;
      }
      // Causes error when acessing a locked row instead of waiting for it to be released.
      noWait() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".noWait() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.skipLocked) {
          throw new Error(".noWait() cannot be used together with .skipLocked()!");
        }
        this._single.waitMode = waitMode.noWait;
        return this;
      }
      // Takes a JS object of methods to call and calls them
      fromJS(obj) {
        each(obj, (val2, key) => {
          if (typeof this[key] !== "function") {
            this.client.logger.warn(`Knex Error: unknown key ${key}`);
          }
          if (Array.isArray(val2)) {
            this[key].apply(this, val2);
          } else {
            this[key](val2);
          }
        });
        return this;
      }
      fromRaw(sql, bindings) {
        const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
        return this.from(raw);
      }
      // Passes query to provided callback function, useful for e.g. composing
      // domain-specific helpers
      modify(callback) {
        callback.apply(this, [this].concat(tail(arguments)));
        return this;
      }
      upsert(values, returning, options) {
        throw new Error(
          `Upsert is not yet supported for dialect ${this.client.dialect}`
        );
      }
      // JSON support functions
      _json(nameFunction, params) {
        this._statements.push({
          grouping: "columns",
          type: "json",
          method: nameFunction,
          params
        });
        return this;
      }
      jsonExtract() {
        const column = arguments[0];
        let path;
        let alias;
        let singleValue = true;
        if (arguments.length >= 2) {
          path = arguments[1];
        }
        if (arguments.length >= 3) {
          alias = arguments[2];
        }
        if (arguments.length === 4) {
          singleValue = arguments[3];
        }
        if (arguments.length === 2 && Array.isArray(arguments[0]) && isBoolean(arguments[1])) {
          singleValue = arguments[1];
        }
        return this._json("jsonExtract", {
          column,
          path,
          alias,
          singleValue
          // boolean used only in MSSQL to use function for extract value instead of object/array.
        });
      }
      jsonSet(column, path, value, alias) {
        return this._json("jsonSet", {
          column,
          path,
          value,
          alias
        });
      }
      jsonInsert(column, path, value, alias) {
        return this._json("jsonInsert", {
          column,
          path,
          value,
          alias
        });
      }
      jsonRemove(column, path, alias) {
        return this._json("jsonRemove", {
          column,
          path,
          alias
        });
      }
      // Wheres for JSON
      _isJsonObject(jsonValue) {
        return isObject(jsonValue) && !(jsonValue instanceof _Builder);
      }
      _whereJsonWrappedValue(type, column, value) {
        const whereJsonClause = {
          grouping: "where",
          type,
          column,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        };
        if (arguments[3]) {
          whereJsonClause.operator = arguments[3];
        }
        if (arguments[4]) {
          whereJsonClause.jsonPath = arguments[4];
        }
        this._statements.push(whereJsonClause);
      }
      whereJsonObject(column, value) {
        this._whereJsonWrappedValue("whereJsonObject", column, value);
        return this;
      }
      orWhereJsonObject(column, value) {
        return this._bool("or").whereJsonObject(column, value);
      }
      whereNotJsonObject(column, value) {
        return this._not(true).whereJsonObject(column, value);
      }
      orWhereNotJsonObject(column, value) {
        return this._bool("or").whereNotJsonObject(column, value);
      }
      whereJsonPath(column, path, operator, value) {
        this._whereJsonWrappedValue("whereJsonPath", column, value, operator, path);
        return this;
      }
      orWhereJsonPath(column, path, operator, value) {
        return this._bool("or").whereJsonPath(column, path, operator, value);
      }
      // Json superset wheres
      whereJsonSupersetOf(column, value) {
        this._whereJsonWrappedValue("whereJsonSupersetOf", column, value);
        return this;
      }
      whereJsonNotSupersetOf(column, value) {
        return this._not(true).whereJsonSupersetOf(column, value);
      }
      orWhereJsonSupersetOf(column, value) {
        return this._bool("or").whereJsonSupersetOf(column, value);
      }
      orWhereJsonNotSupersetOf(column, value) {
        return this._bool("or").whereJsonNotSupersetOf(column, value);
      }
      // Json subset wheres
      whereJsonSubsetOf(column, value) {
        this._whereJsonWrappedValue("whereJsonSubsetOf", column, value);
        return this;
      }
      whereJsonNotSubsetOf(column, value) {
        return this._not(true).whereJsonSubsetOf(column, value);
      }
      orWhereJsonSubsetOf(column, value) {
        return this._bool("or").whereJsonSubsetOf(column, value);
      }
      orWhereJsonNotSubsetOf(column, value) {
        return this._bool("or").whereJsonNotSubsetOf(column, value);
      }
      whereJsonHasNone(column, values) {
        this._not(true).whereJsonHasAll(column, values);
        return this;
      }
      // end of wheres for JSON
      _analytic(alias, second, third) {
        let analytic;
        const { schema } = this._single;
        const method = this._analyticMethod();
        alias = typeof alias === "string" ? alias : null;
        assert(
          typeof second === "function" || second.isRawInstance || Array.isArray(second) || typeof second === "string" || typeof second === "object",
          `The second argument to an analytic function must be either a function, a raw,
       an array of string or object, an object or a single string.`
        );
        if (third) {
          assert(
            Array.isArray(third) || typeof third === "string" || typeof third === "object",
            "The third argument to an analytic function must be either a string, an array of string or object or an object."
          );
        }
        if (isFunction(second)) {
          analytic = new Analytic(method, schema, alias);
          second.call(analytic, analytic);
        } else if (second.isRawInstance) {
          const raw = second;
          analytic = {
            grouping: "columns",
            type: "analytic",
            method,
            raw,
            alias
          };
        } else {
          const order = !Array.isArray(second) ? [second] : second;
          let partitions = third || [];
          partitions = !Array.isArray(partitions) ? [partitions] : partitions;
          analytic = {
            grouping: "columns",
            type: "analytic",
            method,
            order,
            alias,
            partitions
          };
        }
        this._statements.push(analytic);
        return this;
      }
      rank(...args) {
        return this._analyticMethod("rank")._analytic(...args);
      }
      denseRank(...args) {
        return this._analyticMethod("dense_rank")._analytic(...args);
      }
      rowNumber(...args) {
        return this._analyticMethod("row_number")._analytic(...args);
      }
      // ----------------------------------------------------------------------
      // Helper for the incrementing/decrementing queries.
      _counter(column, amount) {
        amount = parseFloat(amount);
        this._method = "update";
        this._single.counter = this._single.counter || {};
        this._single.counter[column] = amount;
        return this;
      }
      // Helper to get or set the "boolFlag" value.
      _bool(val2) {
        if (arguments.length === 1) {
          this._boolFlag = val2;
          return this;
        }
        const ret = this._boolFlag;
        this._boolFlag = "and";
        return ret;
      }
      // Helper to get or set the "notFlag" value.
      _not(val2) {
        if (arguments.length === 1) {
          this._notFlag = val2;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      }
      // Helper to get or set the "joinFlag" value.
      _joinType(val2) {
        if (arguments.length === 1) {
          this._joinFlag = val2;
          return this;
        }
        const ret = this._joinFlag || "inner";
        this._joinFlag = "inner";
        return ret;
      }
      _analyticMethod(val2) {
        if (arguments.length === 1) {
          this._analyticFlag = val2;
          return this;
        }
        return this._analyticFlag || "row_number";
      }
      // Helper for compiling any aggregate queries.
      _aggregate(method, column, options = {}) {
        this._statements.push({
          grouping: "columns",
          type: column.isRawInstance ? "aggregateRaw" : "aggregate",
          method,
          value: column,
          aggregateDistinct: options.distinct || false,
          alias: options.as
        });
        return this;
      }
      // Helper function for clearing or reseting a grouping type from the builder
      _clearGrouping(grouping) {
        if (grouping in this._single) {
          this._single[grouping] = void 0;
        } else {
          this._statements = reject(this._statements, { grouping });
        }
      }
      // Helper function that checks if the builder will emit a select query
      _isSelectQuery() {
        return SELECT_COMMANDS.has(this._method);
      }
      // Helper function that checks if the query has a lock mode set
      _hasLockMode() {
        return LOCK_MODES.has(this._single.lock);
      }
    };
    Builder.prototype.select = Builder.prototype.columns;
    Builder.prototype.column = Builder.prototype.columns;
    Builder.prototype.andWhereNot = Builder.prototype.whereNot;
    Builder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;
    Builder.prototype.andWhere = Builder.prototype.where;
    Builder.prototype.andWhereColumn = Builder.prototype.whereColumn;
    Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
    Builder.prototype.andWhereBetween = Builder.prototype.whereBetween;
    Builder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;
    Builder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;
    Builder.prototype.andWhereNotJsonObject = Builder.prototype.whereNotJsonObject;
    Builder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;
    Builder.prototype.andWhereLike = Builder.prototype.whereLike;
    Builder.prototype.andWhereILike = Builder.prototype.whereILike;
    Builder.prototype.andHaving = Builder.prototype.having;
    Builder.prototype.andHavingIn = Builder.prototype.havingIn;
    Builder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;
    Builder.prototype.andHavingNull = Builder.prototype.havingNull;
    Builder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;
    Builder.prototype.andHavingExists = Builder.prototype.havingExists;
    Builder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;
    Builder.prototype.andHavingBetween = Builder.prototype.havingBetween;
    Builder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;
    Builder.prototype.from = Builder.prototype.table;
    Builder.prototype.into = Builder.prototype.table;
    Builder.prototype.del = Builder.prototype.delete;
    augmentWithBuilderInterface(Builder);
    addQueryContext(Builder);
    Builder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {
        throw new Error(
          `Can't extend QueryBuilder with existing method ('${methodName}').`
        );
      }
      assign(Builder.prototype, { [methodName]: fn });
    };
    var OnConflictBuilder = class {
      constructor(builder, columns) {
        this.builder = builder;
        this._columns = columns;
      }
      // Sets insert query to ignore conflicts
      ignore() {
        this.builder._single.onConflict = this._columns;
        this.builder._single.ignore = true;
        return this.builder;
      }
      // Sets insert query to update on conflict
      merge(updates) {
        this.builder._single.onConflict = this._columns;
        this.builder._single.merge = { updates };
        return this.builder;
      }
      // Prevent
      then() {
        throw new Error(
          "Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()"
        );
      }
    };
    module.exports = Builder;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports, module) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module.exports = reduce;
  }
});

// node_modules/lodash/transform.js
var require_transform = __commonJS({
  "node_modules/lodash/transform.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
        return iteratee(accumulator, value, index, object2);
      });
      return accumulator;
    }
    module.exports = transform;
  }
});

// node_modules/knex/lib/formatter/formatterUtils.js
var require_formatterUtils = __commonJS({
  "node_modules/knex/lib/formatter/formatterUtils.js"(exports, module) {
    var { isObject } = require_is();
    function compileCallback(callback, method, client, bindingsHolder) {
      const builder = client.queryBuilder();
      callback.call(builder, builder);
      const compiler = client.queryCompiler(builder, bindingsHolder.bindings);
      return compiler.toSQL(method || builder._method || "select");
    }
    function wrapAsIdentifier(value, builder, client) {
      const queryContext = builder.queryContext();
      return client.wrapIdentifier((value || "").trim(), queryContext);
    }
    function formatDefault(value, type, client) {
      if (value === void 0) {
        return "";
      } else if (value === null) {
        return "null";
      } else if (value && value.isRawInstance) {
        return value.toQuery();
      } else if (type === "bool") {
        if (value === "false") value = 0;
        return `'${value ? 1 : 0}'`;
      } else if ((type === "json" || type === "jsonb") && isObject(value)) {
        return `'${JSON.stringify(value)}'`;
      } else {
        return client._escapeBinding(value.toString());
      }
    }
    module.exports = {
      compileCallback,
      wrapAsIdentifier,
      formatDefault
    };
  }
});

// node_modules/knex/lib/formatter/wrappingFormatter.js
var require_wrappingFormatter = __commonJS({
  "node_modules/knex/lib/formatter/wrappingFormatter.js"(exports, module) {
    var transform = require_transform();
    var QueryBuilder = require_querybuilder();
    var { compileCallback, wrapAsIdentifier } = require_formatterUtils();
    var orderBys = ["asc", "desc"];
    var operators = transform(
      [
        "=",
        "<",
        ">",
        "<=",
        ">=",
        "<>",
        "!=",
        "like",
        "not like",
        "between",
        "not between",
        "ilike",
        "not ilike",
        "exists",
        "not exist",
        "rlike",
        "not rlike",
        "regexp",
        "not regexp",
        "match",
        "&",
        "|",
        "^",
        "<<",
        ">>",
        "~",
        "~=",
        "~*",
        "!~",
        "!~*",
        "#",
        "&&",
        "@>",
        "<@",
        "||",
        "&<",
        "&>",
        "-|-",
        "@@",
        "!!",
        ["?", "\\?"],
        ["?|", "\\?|"],
        ["?&", "\\?&"]
      ],
      (result, key) => {
        if (Array.isArray(key)) {
          result[key[0]] = key[1];
        } else {
          result[key] = key;
        }
      },
      {}
    );
    function columnize(target, builder, client, bindingHolder) {
      const columns = Array.isArray(target) ? target : [target];
      let str = "", i3 = -1;
      while (++i3 < columns.length) {
        if (i3 > 0) str += ", ";
        str += wrap(columns[i3], void 0, builder, client, bindingHolder);
      }
      return str;
    }
    function wrap(value, isParameter, builder, client, bindingHolder) {
      const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);
      if (raw) return raw;
      switch (typeof value) {
        case "function":
          return outputQuery(
            compileCallback(value, void 0, client, bindingHolder),
            true,
            builder,
            client
          );
        case "object":
          return parseObject(value, builder, client, bindingHolder);
        case "number":
          return value;
        default:
          return wrapString(value + "", builder, client);
      }
    }
    function unwrapRaw(value, isParameter, builder, client, bindingsHolder) {
      let query;
      if (value instanceof QueryBuilder) {
        query = client.queryCompiler(value).toSQL();
        if (query.bindings) {
          bindingsHolder.bindings.push(...query.bindings);
        }
        return outputQuery(query, isParameter, builder, client);
      }
      if (value && value.isRawInstance) {
        value.client = client;
        if (builder._queryContext) {
          value.queryContext = () => {
            return builder._queryContext;
          };
        }
        query = value.toSQL();
        if (query.bindings) {
          bindingsHolder.bindings.push(...query.bindings);
        }
        return query.sql;
      }
      if (isParameter) {
        bindingsHolder.bindings.push(value);
      }
    }
    function operator(value, builder, client, bindingsHolder) {
      const raw = unwrapRaw(value, void 0, builder, client, bindingsHolder);
      if (raw) return raw;
      const operator2 = operators[(value || "").toLowerCase()];
      if (!operator2) {
        throw new TypeError(`The operator "${value}" is not permitted`);
      }
      return operator2;
    }
    function wrapString(value, builder, client) {
      const asIndex = value.toLowerCase().indexOf(" as ");
      if (asIndex !== -1) {
        const first = value.slice(0, asIndex);
        const second = value.slice(asIndex + 4);
        return client.alias(
          wrapString(first, builder, client),
          wrapAsIdentifier(second, builder, client)
        );
      }
      const wrapped = [];
      let i3 = -1;
      const segments = value.split(".");
      while (++i3 < segments.length) {
        value = segments[i3];
        if (i3 === 0 && segments.length > 1) {
          wrapped.push(wrapString((value || "").trim(), builder, client));
        } else {
          wrapped.push(wrapAsIdentifier(value, builder, client));
        }
      }
      return wrapped.join(".");
    }
    function parseObject(obj, builder, client, formatter) {
      const ret = [];
      for (const alias in obj) {
        const queryOrIdentifier = obj[alias];
        if (typeof queryOrIdentifier === "function") {
          const compiled = compileCallback(
            queryOrIdentifier,
            void 0,
            client,
            formatter
          );
          compiled.as = alias;
          ret.push(outputQuery(compiled, true, builder, client));
        } else if (queryOrIdentifier instanceof QueryBuilder) {
          ret.push(
            client.alias(
              `(${wrap(queryOrIdentifier, void 0, builder, client, formatter)})`,
              wrapAsIdentifier(alias, builder, client)
            )
          );
        } else {
          ret.push(
            client.alias(
              wrap(queryOrIdentifier, void 0, builder, client, formatter),
              wrapAsIdentifier(alias, builder, client)
            )
          );
        }
      }
      return ret.join(", ");
    }
    function outputQuery(compiled, isParameter, builder, client) {
      let sql = compiled.sql || "";
      if (sql) {
        if ((compiled.method === "select" || compiled.method === "first") && (isParameter || compiled.as)) {
          sql = `(${sql})`;
          if (compiled.as)
            return client.alias(sql, wrapString(compiled.as, builder, client));
        }
      }
      return sql;
    }
    function rawOrFn(value, method, builder, client, bindingHolder) {
      if (typeof value === "function") {
        return outputQuery(
          compileCallback(value, method, client, bindingHolder),
          void 0,
          builder,
          client
        );
      }
      return unwrapRaw(value, void 0, builder, client, bindingHolder) || "";
    }
    function direction(value, builder, client, bindingsHolder) {
      const raw = unwrapRaw(value, void 0, builder, client, bindingsHolder);
      if (raw) return raw;
      return orderBys.indexOf((value || "").toLowerCase()) !== -1 ? value : "asc";
    }
    module.exports = {
      columnize,
      direction,
      operator,
      outputQuery,
      rawOrFn,
      unwrapRaw,
      wrap,
      wrapString
    };
  }
});

// node_modules/knex/lib/formatter/rawFormatter.js
var require_rawFormatter = __commonJS({
  "node_modules/knex/lib/formatter/rawFormatter.js"(exports, module) {
    var { columnize } = require_wrappingFormatter();
    function replaceRawArrBindings(raw, client) {
      const bindingsHolder = {
        bindings: []
      };
      const builder = raw;
      const expectedBindings = raw.bindings.length;
      const values = raw.bindings;
      let index = 0;
      const sql = raw.sql.replace(/\\?\?\??/g, function(match) {
        if (match === "\\?") {
          return match;
        }
        const value = values[index++];
        if (match === "??") {
          return columnize(value, builder, client, bindingsHolder);
        }
        return client.parameter(value, builder, bindingsHolder);
      });
      if (expectedBindings !== index) {
        throw new Error(`Expected ${expectedBindings} bindings, saw ${index}`);
      }
      return {
        method: "raw",
        sql,
        bindings: bindingsHolder.bindings
      };
    }
    function replaceKeyBindings(raw, client) {
      const bindingsHolder = {
        bindings: []
      };
      const builder = raw;
      const values = raw.bindings;
      const regex = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;
      const sql = raw.sql.replace(regex, function(match, p1, p22, p3, p4) {
        if (match !== p1) {
          return p1;
        }
        const part = p22 || p3 || p4;
        const key = match.trim();
        const isIdentifier = key[key.length - 1] === ":";
        const value = values[part];
        if (value === void 0) {
          if (Object.prototype.hasOwnProperty.call(values, part)) {
            bindingsHolder.bindings.push(value);
          }
          return match;
        }
        if (isIdentifier) {
          return match.replace(
            p1,
            columnize(value, builder, client, bindingsHolder)
          );
        }
        return match.replace(p1, client.parameter(value, builder, bindingsHolder));
      });
      return {
        method: "raw",
        sql,
        bindings: bindingsHolder.bindings
      };
    }
    module.exports = {
      replaceKeyBindings,
      replaceRawArrBindings
    };
  }
});

// node_modules/knex/lib/util/nanoid.js
var require_nanoid = __commonJS({
  "node_modules/knex/lib/util/nanoid.js"(exports, module) {
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var numberAlphabet = "0123456789";
    function nanoid(size = 21) {
      let id = "";
      let i3 = size;
      while (i3--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    }
    function nanonum(size = 21) {
      let id = "";
      let i3 = size;
      while (i3--) {
        id += numberAlphabet[Math.random() * 10 | 0];
      }
      return id;
    }
    module.exports = { nanoid, nanonum };
  }
});

// node_modules/knex/lib/raw.js
var require_raw = __commonJS({
  "node_modules/knex/lib/raw.js"(exports, module) {
    var { EventEmitter } = __require("events");
    var debug = require_src();
    var assign = require_assign();
    var isPlainObject = require_isPlainObject();
    var reduce = require_reduce();
    var {
      replaceRawArrBindings,
      replaceKeyBindings
    } = require_rawFormatter();
    var helpers = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    var { nanoid } = require_nanoid();
    var { isNumber, isObject } = require_is();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var debugBindings = debug("knex:bindings");
    var Raw = class extends EventEmitter {
      constructor(client) {
        super();
        this.client = client;
        this.sql = "";
        this.bindings = [];
        this._wrappedBefore = void 0;
        this._wrappedAfter = void 0;
        if (client && client.config) {
          this._debug = client.config.debug;
          saveAsyncStack(this, 4);
        }
      }
      set(sql, bindings) {
        this.sql = sql;
        this.bindings = isObject(bindings) && !bindings.toSQL || bindings === void 0 ? bindings : [bindings];
        return this;
      }
      timeout(ms, { cancel } = {}) {
        if (isNumber(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      }
      // Wraps the current sql with `before` and `after`.
      wrap(before, after) {
        this._wrappedBefore = before;
        this._wrappedAfter = after;
        return this;
      }
      // Calls `toString` on the Knex object.
      toString() {
        return this.toQuery();
      }
      // Returns the raw sql for the query.
      toSQL(method, tz) {
        let obj;
        if (Array.isArray(this.bindings)) {
          obj = replaceRawArrBindings(this, this.client);
        } else if (this.bindings && isPlainObject(this.bindings)) {
          obj = replaceKeyBindings(this, this.client);
        } else {
          obj = {
            method: "raw",
            sql: this.sql,
            bindings: this.bindings === void 0 ? [] : [this.bindings]
          };
        }
        if (this._wrappedBefore) {
          obj.sql = this._wrappedBefore + obj.sql;
        }
        if (this._wrappedAfter) {
          obj.sql = obj.sql + this._wrappedAfter;
        }
        obj.options = reduce(this._options, assign, {});
        if (this._timeout) {
          obj.timeout = this._timeout;
          if (this._cancelOnTimeout) {
            obj.cancelOnTimeout = this._cancelOnTimeout;
          }
        }
        obj.bindings = obj.bindings || [];
        if (helpers.containsUndefined(obj.bindings)) {
          const undefinedBindingIndices = helpers.getUndefinedIndices(
            this.bindings
          );
          debugBindings(obj.bindings);
          throw new Error(
            `Undefined binding(s) detected for keys [${undefinedBindingIndices}] when compiling RAW query: ${obj.sql}`
          );
        }
        obj.__knexQueryUid = nanoid();
        Object.defineProperties(obj, {
          toNative: {
            value: () => ({
              sql: this.client.positionBindings(obj.sql),
              bindings: this.client.prepBindings(obj.bindings)
            }),
            enumerable: false
          }
        });
        return obj;
      }
    };
    Raw.prototype.isRawInstance = true;
    augmentWithBuilderInterface(Raw);
    helpers.addQueryContext(Raw);
    module.exports = Raw;
  }
});

// node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/lodash/compact.js"(exports, module) {
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = compact;
  }
});

// node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/lodash/_arrayAggregator.js"(exports, module) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module.exports = arrayAggregator;
  }
});

// node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/lodash/_baseAggregator.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module.exports = baseAggregator;
  }
});

// node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/lodash/_createAggregator.js"(exports, module) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module.exports = createAggregator;
  }
});

// node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/lodash/groupBy.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module.exports = groupBy;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports, module) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module.exports = has;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map2(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module.exports = map2;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex2 = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex2) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/lodash/pickBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    module.exports = pickBy;
  }
});

// node_modules/lodash/omitBy.js
var require_omitBy = __commonJS({
  "node_modules/lodash/omitBy.js"(exports, module) {
    var baseIteratee = require_baseIteratee();
    var negate = require_negate();
    var pickBy = require_pickBy();
    function omitBy(object, predicate) {
      return pickBy(object, negate(baseIteratee(predicate)));
    }
    module.exports = omitBy;
  }
});

// node_modules/knex/lib/query/querycompiler.js
var require_querycompiler = __commonJS({
  "node_modules/knex/lib/query/querycompiler.js"(exports, module) {
    var helpers = require_helpers();
    var Raw = require_raw();
    var QueryBuilder = require_querybuilder();
    var JoinClause = require_joinclause();
    var debug = require_src();
    var assign = require_assign();
    var compact = require_compact();
    var groupBy = require_groupBy();
    var has = require_has();
    var isEmpty = require_isEmpty();
    var map2 = require_map();
    var omitBy = require_omitBy();
    var reduce = require_reduce();
    var { nanoid } = require_nanoid();
    var { isString, isUndefined } = require_is();
    var {
      columnize: columnize_,
      direction: direction_,
      operator: operator_,
      wrap: wrap_,
      unwrapRaw: unwrapRaw_,
      rawOrFn: rawOrFn_
    } = require_wrappingFormatter();
    var debugBindings = debug("knex:bindings");
    var components = [
      "comments",
      "columns",
      "join",
      "where",
      "union",
      "group",
      "having",
      "order",
      "limit",
      "offset",
      "lock",
      "waitMode"
    ];
    var QueryCompiler = class {
      constructor(client, builder, bindings) {
        this.client = client;
        this.method = builder._method || "select";
        this.options = builder._options;
        this.single = builder._single;
        this.queryComments = builder._comments;
        this.timeout = builder._timeout || false;
        this.cancelOnTimeout = builder._cancelOnTimeout || false;
        this.grouped = groupBy(builder._statements, "grouping");
        this.formatter = client.formatter(builder);
        this._emptyInsertValue = "default values";
        this.first = this.select;
        this.bindings = bindings || [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.builder = this.formatter.builder;
      }
      // Collapse the builder into a single object
      toSQL(method, tz) {
        this._undefinedInWhereClause = false;
        this.undefinedBindingsInfo = [];
        method = method || this.method;
        const val2 = this[method]() || "";
        const query = {
          method,
          options: reduce(this.options, assign, {}),
          timeout: this.timeout,
          cancelOnTimeout: this.cancelOnTimeout,
          bindings: this.bindingsHolder.bindings || [],
          __knexQueryUid: nanoid()
        };
        Object.defineProperties(query, {
          toNative: {
            value: () => {
              return {
                sql: this.client.positionBindings(query.sql),
                bindings: this.client.prepBindings(query.bindings)
              };
            },
            enumerable: false
          }
        });
        if (isString(val2)) {
          query.sql = val2;
        } else {
          assign(query, val2);
        }
        if (method === "select" || method === "first") {
          if (this.single.as) {
            query.as = this.single.as;
          }
        }
        if (this._undefinedInWhereClause) {
          debugBindings(query.bindings);
          throw new Error(
            `Undefined binding(s) detected when compiling ${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
              ", "
            )}] query: ${query.sql}`
          );
        }
        return query;
      }
      // Compiles the `select` statement, or nested sub-selects by calling each of
      // the component compilers, trimming out the empties, and returning a
      // generated query string.
      select() {
        let sql = this.with();
        let unionStatement = "";
        const firstStatements = [];
        const endStatements = [];
        components.forEach((component) => {
          const statement = this[component](this);
          switch (component) {
            case "union":
              unionStatement = statement;
              break;
            case "comments":
            case "columns":
            case "join":
            case "where":
              firstStatements.push(statement);
              break;
            default:
              endStatements.push(statement);
              break;
          }
        });
        const wrapMainQuery = this.grouped.union && this.grouped.union.map((u3) => u3.wrap).some((u3) => u3);
        if (this.onlyUnions()) {
          const statements = compact(firstStatements.concat(endStatements)).join(
            " "
          );
          sql += unionStatement + (statements ? " " + statements : "");
        } else {
          const allStatements = (wrapMainQuery ? "(" : "") + compact(firstStatements).join(" ") + (wrapMainQuery ? ")" : "");
          const endStat = compact(endStatements).join(" ");
          sql += allStatements + (unionStatement ? " " + unionStatement : "") + (endStat ? " " + endStat : endStat);
        }
        return sql;
      }
      pluck() {
        let toPluck = this.single.pluck;
        if (toPluck.indexOf(".") !== -1) {
          toPluck = toPluck.split(".").slice(-1)[0];
        }
        return {
          sql: this.select(),
          pluck: toPluck
        };
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const insertValues = this.single.insert || [];
        const sql = this.with() + `insert into ${this.tableName} `;
        const body = this._insertBody(insertValues);
        return body === "" ? "" : sql + body;
      }
      _onConflictClause(columns) {
        return columns instanceof Raw ? this.formatter.wrap(columns) : `(${this.formatter.columnize(columns)})`;
      }
      _buildInsertValues(insertData) {
        let sql = "";
        let i3 = -1;
        while (++i3 < insertData.values.length) {
          if (i3 !== 0) sql += "), (";
          sql += this.client.parameterize(
            insertData.values[i3],
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          );
        }
        return sql;
      }
      _insertBody(insertValues) {
        let sql = "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return sql + this._emptyInsertValue;
        }
        const insertData = this._prepInsert(insertValues);
        if (typeof insertData === "string") {
          sql += insertData;
        } else {
          if (insertData.columns.length) {
            sql += `(${columnize_(
              insertData.columns,
              this.builder,
              this.client,
              this.bindingsHolder
            )}`;
            sql += ") values (" + this._buildInsertValues(insertData) + ")";
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql += this._emptyInsertValue;
          } else {
            sql = "";
          }
        }
        return sql;
      }
      // Compiles the "update" query.
      update() {
        const withSQL = this.with();
        const { tableName } = this;
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        return withSQL + `update ${this.single.only ? "only " : ""}${tableName} set ` + updateData.join(", ") + (wheres ? ` ${wheres}` : "");
      }
      _hintComments() {
        let hints = this.grouped.hintComments || [];
        hints = hints.map((hint) => compact(hint.value).join(" "));
        hints = compact(hints).join(" ");
        return hints ? `/*+ ${hints} */ ` : "";
      }
      // Compiles the columns in the query, specifying if an item was distinct.
      columns() {
        let distinctClause = "";
        if (this.onlyUnions()) return "";
        const hints = this._hintComments();
        const columns = this.grouped.columns || [];
        let i3 = -1, sql = [];
        if (columns) {
          while (++i3 < columns.length) {
            const stmt = columns[i3];
            if (stmt.distinct) distinctClause = "distinct ";
            if (stmt.distinctOn) {
              distinctClause = this.distinctOn(stmt.value);
              continue;
            }
            if (stmt.type === "aggregate") {
              sql.push(...this.aggregate(stmt));
            } else if (stmt.type === "aggregateRaw") {
              sql.push(this.aggregateRaw(stmt));
            } else if (stmt.type === "analytic") {
              sql.push(this.analytic(stmt));
            } else if (stmt.type === "json") {
              sql.push(this.json(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql.push(
                columnize_(
                  stmt.value,
                  this.builder,
                  this.client,
                  this.bindingsHolder
                )
              );
            }
          }
        }
        if (sql.length === 0) sql = ["*"];
        const select = this.onlyJson() ? "" : "select ";
        return `${select}${hints}${distinctClause}` + sql.join(", ") + (this.tableName ? ` from ${this.single.only ? "only " : ""}${this.tableName}` : "");
      }
      // Add comments to the query
      comments() {
        if (!this.queryComments.length) return "";
        return this.queryComments.map((comment) => `/* ${comment.comment} */`).join(" ");
      }
      _aggregate(stmt, { aliasSeparator = " as ", distinctParentheses } = {}) {
        const value = stmt.value;
        const method = stmt.method;
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        const wrap = (identifier) => wrap_(
          identifier,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        const addAlias = (value2, alias2) => {
          if (alias2) {
            return value2 + aliasSeparator + wrap(alias2);
          }
          return value2;
        };
        const aggregateArray = (value2, alias2) => {
          let columns = value2.map(wrap).join(", ");
          if (distinct) {
            const openParen = distinctParentheses ? "(" : " ";
            const closeParen = distinctParentheses ? ")" : "";
            columns = distinct.trim() + openParen + columns + closeParen;
          }
          const aggregated = `${method}(${columns})`;
          return addAlias(aggregated, alias2);
        };
        const aggregateString = (value2, alias2) => {
          const aggregated = `${method}(${distinct + wrap(value2)})`;
          return addAlias(aggregated, alias2);
        };
        if (Array.isArray(value)) {
          return [aggregateArray(value)];
        }
        if (typeof value === "object") {
          if (stmt.alias) {
            throw new Error("When using an object explicit alias can not be used");
          }
          return Object.entries(value).map(([alias2, column2]) => {
            if (Array.isArray(column2)) {
              return aggregateArray(column2, alias2);
            }
            return aggregateString(column2, alias2);
          });
        }
        const splitOn = value.toLowerCase().indexOf(" as ");
        let column = value;
        let { alias } = stmt;
        if (splitOn !== -1) {
          column = value.slice(0, splitOn);
          if (alias) {
            throw new Error(`Found multiple aliases for same column: ${column}`);
          }
          alias = value.slice(splitOn + 4);
        }
        return [aggregateString(column, alias)];
      }
      aggregate(stmt) {
        return this._aggregate(stmt);
      }
      aggregateRaw(stmt) {
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        return `${stmt.method}(${distinct + unwrapRaw_(
          stmt.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        )})`;
      }
      _joinTable(join) {
        return join.schema && !(join.table instanceof Raw) ? `${join.schema}.${join.table}` : join.table;
      }
      // Compiles all each of the `join` clauses on the query,
      // including any nested join queries.
      join() {
        let sql = "";
        let i3 = -1;
        const joins = this.grouped.join;
        if (!joins) return "";
        while (++i3 < joins.length) {
          const join = joins[i3];
          const table = this._joinTable(join);
          if (i3 > 0) sql += " ";
          if (join.joinType === "raw") {
            sql += unwrapRaw_(
              join.table,
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            );
          } else {
            sql += join.joinType + " join " + wrap_(
              table,
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            );
            let ii = -1;
            while (++ii < join.clauses.length) {
              const clause = join.clauses[ii];
              if (ii > 0) {
                sql += ` ${clause.bool} `;
              } else {
                sql += ` ${clause.type === "onUsing" ? "using" : "on"} `;
              }
              const val2 = this[clause.type](clause);
              if (val2) {
                sql += val2;
              }
            }
          }
        }
        return sql;
      }
      onBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      onNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      onExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      onIn(statement) {
        if (Array.isArray(statement.column)) return this.multiOnIn(statement);
        let values;
        if (statement.value instanceof Raw) {
          values = this.client.parameter(
            statement.value,
            this.builder,
            this.formatter
          );
        } else {
          values = this.client.parameterize(
            statement.value,
            void 0,
            this.builder,
            this.bindingsHolder
          );
        }
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "in ") + this.wrap(values);
      }
      multiOnIn(statement) {
        let i3 = -1, sql = `(${columnize_(
          statement.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}) `;
        sql += this._not(statement, "in ") + "((";
        while (++i3 < statement.value.length) {
          if (i3 !== 0) sql += "),(";
          sql += this.client.parameterize(
            statement.value[i3],
            void 0,
            this.builder,
            this.bindingsHolder
          );
        }
        return sql + "))";
      }
      // Compiles all `where` statements on the query.
      where() {
        const wheres = this.grouped.where;
        if (!wheres) return;
        const sql = [];
        let i3 = -1;
        while (++i3 < wheres.length) {
          const stmt = wheres[i3];
          if (Object.prototype.hasOwnProperty.call(stmt, "value") && helpers.containsUndefined(stmt.value)) {
            this.undefinedBindingsInfo.push(stmt.column);
            this._undefinedInWhereClause = true;
          }
          const val2 = this[stmt.type](stmt);
          if (val2) {
            if (sql.length === 0) {
              sql[0] = "where";
            } else {
              sql.push(stmt.bool);
            }
            sql.push(val2);
          }
        }
        return sql.length > 1 ? sql.join(" ") : "";
      }
      group() {
        return this._groupsOrders("group");
      }
      order() {
        return this._groupsOrders("order");
      }
      // Compiles the `having` statements.
      having() {
        const havings = this.grouped.having;
        if (!havings) return "";
        const sql = ["having"];
        for (let i3 = 0, l3 = havings.length; i3 < l3; i3++) {
          const s3 = havings[i3];
          const val2 = this[s3.type](s3);
          if (val2) {
            if (sql.length === 0) {
              sql[0] = "where";
            }
            if (sql.length > 1 || sql.length === 1 && sql[0] !== "having") {
              sql.push(s3.bool);
            }
            sql.push(val2);
          }
        }
        return sql.length > 1 ? sql.join(" ") : "";
      }
      havingRaw(statement) {
        return this._not(statement, "") + unwrapRaw_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      havingWrapped(statement) {
        const val2 = rawOrFn_(
          statement.value,
          "where",
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return val2 && this._not(statement, "") + "(" + val2.slice(6) + ")" || "";
      }
      havingBasic(statement) {
        return this._not(statement, "") + wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this.client.parameter(statement.value, this.builder, this.bindingsHolder);
      }
      havingNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      havingExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      havingBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      havingIn(statement) {
        if (Array.isArray(statement.column)) return this.multiHavingIn(statement);
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "in ") + this.wrap(
          this.client.parameterize(
            statement.value,
            void 0,
            this.builder,
            this.bindingsHolder
          )
        );
      }
      multiHavingIn(statement) {
        return this.multiOnIn(statement);
      }
      // Compile the "union" queries attached to the main query.
      union() {
        const onlyUnions = this.onlyUnions();
        const unions = this.grouped.union;
        if (!unions) return "";
        let sql = "";
        for (let i3 = 0, l3 = unions.length; i3 < l3; i3++) {
          const union = unions[i3];
          if (i3 > 0) sql += " ";
          if (i3 > 0 || !onlyUnions) sql += union.clause + " ";
          const statement = rawOrFn_(
            union.value,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
          if (statement) {
            const wrap = union.wrap;
            if (wrap) sql += "(";
            sql += statement;
            if (wrap) sql += ")";
          }
        }
        return sql;
      }
      // If we haven't specified any columns or a `tableName`, we're assuming this
      // is only being used for unions.
      onlyUnions() {
        return (!this.grouped.columns || !!this.grouped.columns[0].value) && this.grouped.union && !this.tableName;
      }
      _getValueOrParameterFromAttribute(attribute, rawValue) {
        if (this.single.skipBinding[attribute] === true) {
          return rawValue !== void 0 && rawValue !== null ? rawValue : this.single[attribute];
        }
        return this.client.parameter(
          this.single[attribute],
          this.builder,
          this.bindingsHolder
        );
      }
      onlyJson() {
        return !this.tableName && this.grouped.columns && this.grouped.columns.length === 1 && this.grouped.columns[0].type === "json";
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit) return "";
        return `limit ${this._getValueOrParameterFromAttribute("limit")}`;
      }
      offset() {
        if (!this.single.offset) return "";
        return `offset ${this._getValueOrParameterFromAttribute("offset")}`;
      }
      // Compiles a `delete` query.
      del() {
        const { tableName } = this;
        const withSQL = this.with();
        const wheres = this.where();
        const joins = this.join();
        const deleteSelector = joins ? tableName + " " : "";
        return withSQL + `delete ${deleteSelector}from ${this.single.only ? "only " : ""}${tableName}` + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "");
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate ${this.tableName}`;
      }
      // Compiles the "locks".
      lock() {
        if (this.single.lock) {
          return this[this.single.lock]();
        }
      }
      // Compiles the wait mode on the locks.
      waitMode() {
        if (this.single.waitMode) {
          return this[this.single.waitMode]();
        }
      }
      // Fail on unsupported databases
      skipLocked() {
        throw new Error(
          ".skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+"
        );
      }
      // Fail on unsupported databases
      noWait() {
        throw new Error(
          ".noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+"
        );
      }
      distinctOn(value) {
        throw new Error(".distinctOn() is currently only supported on PostgreSQL");
      }
      // On Clause
      // ------
      onWrapped(clause) {
        const self2 = this;
        const wrapJoin = new JoinClause();
        clause.value.call(wrapJoin, wrapJoin);
        let sql = "";
        for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {
          const wrapClause = wrapJoin.clauses[ii];
          if (ii > 0) {
            sql += ` ${wrapClause.bool} `;
          }
          const val2 = self2[wrapClause.type](wrapClause);
          if (val2) {
            sql += val2;
          }
        }
        if (sql.length) {
          return `(${sql})`;
        }
        return "";
      }
      onBasic(clause) {
        const toWrap = clause.value instanceof QueryBuilder;
        return wrap_(
          clause.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          clause.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + (toWrap ? "(" : "") + wrap_(
          clause.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + (toWrap ? ")" : "");
      }
      onVal(clause) {
        return wrap_(
          clause.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          clause.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this.client.parameter(clause.value, this.builder, this.bindingsHolder);
      }
      onRaw(clause) {
        return unwrapRaw_(
          clause.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      onUsing(clause) {
        return "(" + columnize_(
          clause.column,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      // Where Clause
      // ------
      _valueClause(statement) {
        return statement.asColumn ? wrap_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) : this.client.parameter(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
      }
      _columnClause(statement) {
        let columns;
        if (Array.isArray(statement.column)) {
          columns = `(${columnize_(
            statement.column,
            this.builder,
            this.client,
            this.bindingsHolder
          )})`;
        } else {
          columns = wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        }
        return columns;
      }
      whereIn(statement) {
        const values = this.client.values(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "in "
        )}${values}`;
      }
      whereLike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      whereILike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "ilike "
        )}${this._valueClause(statement)}`;
      }
      whereNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      // Compiles a basic "where" clause.
      whereBasic(statement) {
        return this._not(statement, "") + wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._valueClause(statement);
      }
      whereExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      whereWrapped(statement) {
        const val2 = rawOrFn_(
          statement.value,
          "where",
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return val2 && this._not(statement, "") + "(" + val2.slice(6) + ")" || "";
      }
      whereBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      // Compiles a "whereRaw" query.
      whereRaw(statement) {
        return this._not(statement, "") + unwrapRaw_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      _jsonWrapValue(jsonValue) {
        if (!this.builder._isJsonObject(jsonValue)) {
          try {
            return JSON.stringify(JSON.parse(jsonValue.replace(/\n|\t/g, "")));
          } catch (e3) {
            return jsonValue;
          }
        }
        return JSON.stringify(jsonValue);
      }
      _jsonValueClause(statement) {
        statement.value = this._jsonWrapValue(statement.value);
        return this._valueClause(statement);
      }
      whereJsonObject(statement) {
        return `${this._columnClause(statement)} ${statement.not ? "!=" : "="} ${this._jsonValueClause(statement)}`;
      }
      wrap(str) {
        if (str.charAt(0) !== "(") return `(${str})`;
        return str;
      }
      json(stmt) {
        return this[stmt.method](stmt.params);
      }
      analytic(stmt) {
        let sql = "";
        const self2 = this;
        sql += stmt.method + "() over (";
        if (stmt.raw) {
          sql += stmt.raw;
        } else {
          if (stmt.partitions.length) {
            sql += "partition by ";
            sql += map2(stmt.partitions, function(partition) {
              if (isString(partition)) {
                return self2.formatter.columnize(partition);
              } else return self2.formatter.columnize(partition.column) + (partition.order ? " " + partition.order : "");
            }).join(", ") + " ";
          }
          sql += "order by ";
          sql += map2(stmt.order, function(order) {
            if (isString(order)) {
              return self2.formatter.columnize(order);
            } else return self2.formatter.columnize(order.column) + (order.order ? " " + order.order : "");
          }).join(", ");
        }
        sql += ")";
        if (stmt.alias) {
          sql += " as " + stmt.alias;
        }
        return sql;
      }
      // Compiles all `with` statements on the query.
      with() {
        if (!this.grouped.with || !this.grouped.with.length) {
          return "";
        }
        const withs = this.grouped.with;
        if (!withs) return;
        const sql = [];
        let i3 = -1;
        let isRecursive = false;
        while (++i3 < withs.length) {
          const stmt = withs[i3];
          if (stmt.recursive) {
            isRecursive = true;
          }
          const val2 = this[stmt.type](stmt);
          sql.push(val2);
        }
        return `with ${isRecursive ? "recursive " : ""}${sql.join(", ")} `;
      }
      withWrapped(statement) {
        const val2 = rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        const columnList = statement.columnList ? "(" + columnize_(
          statement.columnList,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        const materialized = statement.materialized === void 0 ? "" : statement.materialized ? "materialized " : "not materialized ";
        return val2 && columnize_(
          statement.alias,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + columnList + " as " + materialized + "(" + val2 + ")" || "";
      }
      // Determines whether to add a "not" prefix to the where clause.
      _not(statement, str) {
        if (statement.not) return `not ${str}`;
        return str;
      }
      _prepInsert(data) {
        const isRaw = rawOrFn_(
          data,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        if (isRaw) return isRaw;
        let columns = [];
        const values = [];
        if (!Array.isArray(data)) data = data ? [data] : [];
        let i3 = -1;
        while (++i3 < data.length) {
          if (data[i3] == null) break;
          if (i3 === 0) columns = Object.keys(data[i3]).sort();
          const row = new Array(columns.length);
          const keys = Object.keys(data[i3]);
          let j3 = -1;
          while (++j3 < keys.length) {
            const key = keys[j3];
            let idx = columns.indexOf(key);
            if (idx === -1) {
              columns = columns.concat(key).sort();
              idx = columns.indexOf(key);
              let k3 = -1;
              while (++k3 < values.length) {
                values[k3].splice(idx, 0, void 0);
              }
              row.splice(idx, 0, void 0);
            }
            row[idx] = data[i3][key];
          }
          values.push(row);
        }
        return {
          columns,
          values
        };
      }
      // "Preps" the update.
      _prepUpdate(data = {}) {
        const { counter = {} } = this.single;
        for (const column of Object.keys(counter)) {
          if (has(data, column)) {
            this.client.logger.warn(
              `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`
            );
            continue;
          }
          let value = counter[column];
          const symbol = value < 0 ? "-" : "+";
          if (symbol === "-") {
            value = -value;
          }
          data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);
        }
        data = omitBy(data, isUndefined);
        const vals = [];
        const columns = Object.keys(data);
        let i3 = -1;
        while (++i3 < columns.length) {
          vals.push(
            wrap_(
              columns[i3],
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            ) + " = " + this.client.parameter(
              data[columns[i3]],
              this.builder,
              this.bindingsHolder
            )
          );
        }
        if (isEmpty(vals)) {
          throw new Error(
            [
              "Empty .update() call detected!",
              "Update data does not contain any values to update.",
              "This will result in a faulty query.",
              this.single.table ? `Table: ${this.single.table}.` : "",
              this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ""
            ].join(" ")
          );
        }
        return vals;
      }
      _formatGroupsItemValue(value, nulls) {
        const { formatter } = this;
        let nullOrder = "";
        if (nulls === "last") {
          nullOrder = " is null";
        } else if (nulls === "first") {
          nullOrder = " is not null";
        }
        let groupOrder;
        if (value instanceof Raw) {
          groupOrder = unwrapRaw_(
            value,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        } else if (value instanceof QueryBuilder || nulls) {
          groupOrder = "(" + formatter.columnize(value) + nullOrder + ")";
        } else {
          groupOrder = formatter.columnize(value);
        }
        return groupOrder;
      }
      _basicGroupOrder(item, type) {
        const column = this._formatGroupsItemValue(item.value, item.nulls);
        const direction = type === "order" && item.type !== "orderByRaw" ? ` ${direction_(
          item.direction,
          this.builder,
          this.client,
          this.bindingsHolder
        )}` : "";
        return column + direction;
      }
      _groupOrder(item, type) {
        return this._basicGroupOrder(item, type);
      }
      _groupOrderNulls(item, type) {
        const column = this._formatGroupsItemValue(item.value);
        const direction = type === "order" && item.type !== "orderByRaw" ? ` ${direction_(
          item.direction,
          this.builder,
          this.client,
          this.bindingsHolder
        )}` : "";
        if (item.nulls && !(item.value instanceof Raw)) {
          return `${column}${direction ? direction : ""} nulls ${item.nulls}`;
        }
        return column + direction;
      }
      // Compiles the `order by` statements.
      _groupsOrders(type) {
        const items = this.grouped[type];
        if (!items) return "";
        const sql = items.map((item) => {
          return this._groupOrder(item, type);
        });
        return sql.length ? type + " by " + sql.join(", ") : "";
      }
      // Get the table name, wrapping it if necessary.
      // Implemented as a property to prevent ordering issues as described in #704.
      get tableName() {
        if (!this._tableName) {
          let tableName = this.single.table;
          const schemaName = this.single.schema;
          if (tableName && schemaName) {
            const isQueryBuilder = tableName instanceof QueryBuilder;
            const isRawQuery = tableName instanceof Raw;
            const isFunction = typeof tableName === "function";
            if (!isQueryBuilder && !isRawQuery && !isFunction) {
              tableName = `${schemaName}.${tableName}`;
            }
          }
          this._tableName = tableName ? (
            // Wrap subQuery with parenthesis, #3485
            wrap_(
              tableName,
              tableName instanceof QueryBuilder,
              this.builder,
              this.client,
              this.bindingsHolder
            )
          ) : "";
        }
        return this._tableName;
      }
      _jsonPathWrap(extraction) {
        return this.client.parameter(
          extraction.path || extraction[1],
          this.builder,
          this.bindingsHolder
        );
      }
      // Json common functions
      _jsonExtract(nameFunction, params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        if (!Array.isArray(nameFunction)) {
          nameFunction = [nameFunction];
        }
        return extractions.map((extraction) => {
          let jsonCol = `${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this._jsonPathWrap(extraction)}`;
          nameFunction.forEach((f3) => {
            jsonCol = f3 + "(" + jsonCol + ")";
          });
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      _jsonSet(nameFunction, params) {
        const jsonSet = `${nameFunction}(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )}, ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonSet, this.formatter.wrap(params.alias)) : jsonSet;
      }
      _whereJsonPath(nameFunction, statement) {
        return `${nameFunction}(${this._columnClause(
          statement
        )}, ${this._jsonPathWrap({ path: statement.jsonPath })}) ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      _onJsonPathEquals(nameJoinFunction, clause) {
        return nameJoinFunction + "(" + wrap_(
          clause.columnFirst,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.parameter(
          clause.jsonPathFirst,
          this.builder,
          this.bindingsHolder
        ) + ") = " + nameJoinFunction + "(" + wrap_(
          clause.columnSecond,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.parameter(
          clause.jsonPathSecond,
          this.builder,
          this.bindingsHolder
        ) + ")";
      }
    };
    module.exports = QueryCompiler;
  }
});

// node_modules/knex/lib/schema/builder.js
var require_builder = __commonJS({
  "node_modules/knex/lib/schema/builder.js"(exports, module) {
    var { EventEmitter } = __require("events");
    var toArray = require_toArray();
    var assign = require_assign();
    var { addQueryContext } = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var SchemaBuilder = class extends EventEmitter {
      constructor(client) {
        super();
        this.client = client;
        this._sequence = [];
        if (client.config) {
          this._debug = client.config.debug;
          saveAsyncStack(this, 4);
        }
      }
      withSchema(schemaName) {
        this._schema = schemaName;
        return this;
      }
      toString() {
        return this.toQuery();
      }
      toSQL() {
        return this.client.schemaCompiler(this).toSQL();
      }
      async generateDdlCommands() {
        return await this.client.schemaCompiler(this).generateDdlCommands();
      }
    };
    [
      "createTable",
      "createTableIfNotExists",
      "createTableLike",
      "createView",
      "createViewOrReplace",
      "createMaterializedView",
      "refreshMaterializedView",
      "dropView",
      "dropViewIfExists",
      "dropMaterializedView",
      "dropMaterializedViewIfExists",
      "createSchema",
      "createSchemaIfNotExists",
      "dropSchema",
      "dropSchemaIfExists",
      "createExtension",
      "createExtensionIfNotExists",
      "dropExtension",
      "dropExtensionIfExists",
      "table",
      "alterTable",
      "view",
      "alterView",
      "hasTable",
      "hasColumn",
      "dropTable",
      "renameTable",
      "renameView",
      "dropTableIfExists",
      "raw"
    ].forEach(function(method) {
      SchemaBuilder.prototype[method] = function() {
        if (method === "createTableIfNotExists") {
          this.client.logger.warn(
            [
              "Use async .hasTable to check if table exists and then use plain .createTable. Since ",
              '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
              "query it will not work correctly if there are any alter table queries generated for ",
              "columns afterwards. To not break old migrations this function is left untouched for now",
              ", but it should not be used when writing new code and it is removed from documentation."
            ].join("")
          );
        }
        if (method === "table") method = "alterTable";
        if (method === "view") method = "alterView";
        this._sequence.push({
          method,
          args: toArray(arguments)
        });
        return this;
      };
    });
    SchemaBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(SchemaBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend SchemaBuilder with existing method ('${methodName}').`
        );
      }
      assign(SchemaBuilder.prototype, { [methodName]: fn });
    };
    augmentWithBuilderInterface(SchemaBuilder);
    addQueryContext(SchemaBuilder);
    module.exports = SchemaBuilder;
  }
});

// node_modules/knex/lib/schema/internal/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/knex/lib/schema/internal/helpers.js"(exports, module) {
    var tail = require_tail();
    var { isString } = require_is();
    function pushQuery(query) {
      if (!query) return;
      if (isString(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.bindingsHolder.bindings;
      }
      this.sequence.push(query);
      this.formatter = this.client.formatter(this._commonBuilder);
      this.bindings = [];
      this.formatter.bindings = this.bindings;
    }
    function pushAdditional(fn) {
      const child = new this.constructor(
        this.client,
        this.tableCompiler,
        this.columnBuilder
      );
      fn.call(child, tail(arguments));
      this.sequence.additional = (this.sequence.additional || []).concat(
        child.sequence
      );
    }
    function unshiftQuery(query) {
      if (!query) return;
      if (isString(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.bindingsHolder.bindings;
      }
      this.sequence.unshift(query);
      this.formatter = this.client.formatter(this._commonBuilder);
      this.bindings = [];
      this.formatter.bindings = this.bindings;
    }
    module.exports = {
      pushAdditional,
      pushQuery,
      unshiftQuery
    };
  }
});

// node_modules/knex/lib/schema/compiler.js
var require_compiler = __commonJS({
  "node_modules/knex/lib/schema/compiler.js"(exports, module) {
    var {
      pushQuery,
      pushAdditional,
      unshiftQuery
    } = require_helpers2();
    var SchemaCompiler = class {
      constructor(client, builder) {
        this.builder = builder;
        this._commonBuilder = this.builder;
        this.client = client;
        this.schema = builder._schema;
        this.bindings = [];
        this.bindingsHolder = this;
        this.formatter = client.formatter(builder);
        this.formatter.bindings = this.bindings;
        this.sequence = [];
      }
      createSchema() {
        throwOnlyPGError("createSchema");
      }
      createSchemaIfNotExists() {
        throwOnlyPGError("createSchemaIfNotExists");
      }
      dropSchema() {
        throwOnlyPGError("dropSchema");
      }
      dropSchemaIfExists() {
        throwOnlyPGError("dropSchemaIfExists");
      }
      dropTable(tableName) {
        this.pushQuery(
          this.dropTablePrefix + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      }
      dropTableIfExists(tableName) {
        this.pushQuery(
          this.dropTablePrefix + "if exists " + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      }
      dropView(viewName) {
        this._dropView(viewName, false, false);
      }
      dropViewIfExists(viewName) {
        this._dropView(viewName, true, false);
      }
      dropMaterializedView(viewName) {
        throw new Error("materialized views are not supported by this dialect.");
      }
      dropMaterializedViewIfExists(viewName) {
        throw new Error("materialized views are not supported by this dialect.");
      }
      renameView(from, to) {
        throw new Error(
          "rename view is not supported by this dialect (instead drop then create another view)."
        );
      }
      refreshMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      _dropView(viewName, ifExists, materialized) {
        this.pushQuery(
          (materialized ? this.dropMaterializedViewPrefix : this.dropViewPrefix) + (ifExists ? "if exists " : "") + this.formatter.wrap(prefixedTableName(this.schema, viewName))
        );
      }
      raw(sql, bindings) {
        this.sequence.push(this.client.raw(sql, bindings).toSQL());
      }
      toSQL() {
        const sequence = this.builder._sequence;
        for (let i3 = 0, l3 = sequence.length; i3 < l3; i3++) {
          const query = sequence[i3];
          this[query.method].apply(this, query.args);
        }
        return this.sequence;
      }
      async generateDdlCommands() {
        const generatedCommands = this.toSQL();
        return {
          pre: [],
          sql: Array.isArray(generatedCommands) ? generatedCommands : [generatedCommands],
          check: null,
          post: []
        };
      }
    };
    SchemaCompiler.prototype.dropTablePrefix = "drop table ";
    SchemaCompiler.prototype.dropViewPrefix = "drop view ";
    SchemaCompiler.prototype.dropMaterializedViewPrefix = "drop materialized view ";
    SchemaCompiler.prototype.alterViewPrefix = "alter view ";
    SchemaCompiler.prototype.alterTable = buildTable("alter");
    SchemaCompiler.prototype.createTable = buildTable("create");
    SchemaCompiler.prototype.createTableIfNotExists = buildTable("createIfNot");
    SchemaCompiler.prototype.createTableLike = buildTable("createLike");
    SchemaCompiler.prototype.createView = buildView("create");
    SchemaCompiler.prototype.createViewOrReplace = buildView("createOrReplace");
    SchemaCompiler.prototype.createMaterializedView = buildView(
      "createMaterializedView"
    );
    SchemaCompiler.prototype.alterView = buildView("alter");
    SchemaCompiler.prototype.pushQuery = pushQuery;
    SchemaCompiler.prototype.pushAdditional = pushAdditional;
    SchemaCompiler.prototype.unshiftQuery = unshiftQuery;
    function build(builder) {
      const queryContext = this.builder.queryContext();
      if (queryContext !== void 0 && builder.queryContext() === void 0) {
        builder.queryContext(queryContext);
      }
      builder.setSchema(this.schema);
      const sql = builder.toSQL();
      for (let i3 = 0, l3 = sql.length; i3 < l3; i3++) {
        this.sequence.push(sql[i3]);
      }
    }
    function buildTable(type) {
      if (type === "createLike") {
        return function(tableName, tableNameLike, fn) {
          const builder = this.client.tableBuilder(
            type,
            tableName,
            tableNameLike,
            fn
          );
          build.call(this, builder);
        };
      } else {
        return function(tableName, fn) {
          const builder = this.client.tableBuilder(type, tableName, null, fn);
          build.call(this, builder);
        };
      }
    }
    function buildView(type) {
      return function(viewName, fn) {
        const builder = this.client.viewBuilder(type, viewName, fn);
        build.call(this, builder);
      };
    }
    function prefixedTableName(prefix, table) {
      return prefix ? `${prefix}.${table}` : table;
    }
    function throwOnlyPGError(operationName) {
      throw new Error(
        `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`
      );
    }
    module.exports = SchemaCompiler;
  }
});

// node_modules/lodash/assignIn.js
var require_assignIn = __commonJS({
  "node_modules/lodash/assignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    module.exports = assignIn;
  }
});

// node_modules/lodash/extend.js
var require_extend = __commonJS({
  "node_modules/lodash/extend.js"(exports, module) {
    module.exports = require_assignIn();
  }
});

// node_modules/knex/lib/schema/tablebuilder.js
var require_tablebuilder = __commonJS({
  "node_modules/knex/lib/schema/tablebuilder.js"(exports, module) {
    var each = require_each();
    var extend = require_extend();
    var assign = require_assign();
    var toArray = require_toArray();
    var helpers = require_helpers();
    var { isString, isFunction, isObject } = require_is();
    var TableBuilder = class {
      constructor(client, method, tableName, tableNameLike, fn) {
        this.client = client;
        this._fn = fn;
        this._method = method;
        this._schemaName = void 0;
        this._tableName = tableName;
        this._tableNameLike = tableNameLike;
        this._statements = [];
        this._single = {};
        if (!tableNameLike && !isFunction(this._fn)) {
          throw new TypeError(
            "A callback function must be supplied to calls against `.createTable` and `.table`"
          );
        }
      }
      setSchema(schemaName) {
        this._schemaName = schemaName;
      }
      // Convert the current tableBuilder object "toSQL"
      // giving us additional methods if we're altering
      // rather than creating the table.
      toSQL() {
        if (this._method === "alter") {
          extend(this, AlterMethods);
        }
        if (this._fn) {
          this._fn.call(this, this);
        }
        return this.client.tableCompiler(this).toSQL();
      }
      // The "timestamps" call is really just sets the `created_at` and `updated_at` columns.
      timestamps(useTimestamps, defaultToNow, useCamelCase) {
        if (isObject(useTimestamps)) {
          ({ useTimestamps, defaultToNow, useCamelCase } = useTimestamps);
        }
        const method = useTimestamps === true ? "timestamp" : "datetime";
        const createdAt = this[method](useCamelCase ? "createdAt" : "created_at");
        const updatedAt = this[method](useCamelCase ? "updatedAt" : "updated_at");
        if (defaultToNow === true) {
          const now = this.client.raw("CURRENT_TIMESTAMP");
          createdAt.notNullable().defaultTo(now);
          updatedAt.notNullable().defaultTo(now);
        }
      }
      // Set the comment value for a table, they're only allowed to be called
      // once per table.
      comment(value) {
        if (typeof value !== "string") {
          throw new TypeError("Table comment must be string");
        }
        this._single.comment = value;
      }
      // Set a foreign key on the table, calling
      // `table.foreign('column_name').references('column').on('table').onDelete()...
      // Also called from the ColumnBuilder context when chaining.
      foreign(column, keyName) {
        const foreignData = { column, keyName };
        this._statements.push({
          grouping: "alterTable",
          method: "foreign",
          args: [foreignData]
        });
        let returnObj = {
          references(tableColumn) {
            let pieces;
            if (isString(tableColumn)) {
              pieces = tableColumn.split(".");
            }
            if (!pieces || pieces.length === 1) {
              foreignData.references = pieces ? pieces[0] : tableColumn;
              return {
                on(tableName) {
                  if (typeof tableName !== "string") {
                    throw new TypeError(
                      `Expected tableName to be a string, got: ${typeof tableName}`
                    );
                  }
                  foreignData.inTable = tableName;
                  return returnObj;
                },
                inTable() {
                  return this.on.apply(this, arguments);
                }
              };
            }
            foreignData.inTable = pieces[0];
            foreignData.references = pieces[1];
            return returnObj;
          },
          withKeyName(keyName2) {
            foreignData.keyName = keyName2;
            return returnObj;
          },
          onUpdate(statement) {
            foreignData.onUpdate = statement;
            return returnObj;
          },
          onDelete(statement) {
            foreignData.onDelete = statement;
            return returnObj;
          },
          deferrable: (type) => {
            const unSupported = [
              "mysql",
              "mssql",
              "redshift",
              "mysql2",
              "oracledb"
            ];
            if (unSupported.indexOf(this.client.dialect) !== -1) {
              throw new Error(`${this.client.dialect} does not support deferrable`);
            }
            foreignData.deferrable = type;
            return returnObj;
          },
          _columnBuilder(builder) {
            extend(builder, returnObj);
            returnObj = builder;
            return builder;
          }
        };
        return returnObj;
      }
      check(checkPredicate, bindings, constraintName) {
        this._statements.push({
          grouping: "checks",
          args: [checkPredicate, bindings, constraintName]
        });
        return this;
      }
    };
    [
      // Each of the index methods can be called individually, with the
      // column name to be used, e.g. table.unique('column').
      "index",
      "primary",
      "unique",
      // Key specific
      "dropPrimary",
      "dropUnique",
      "dropIndex",
      "dropForeign"
    ].forEach((method) => {
      TableBuilder.prototype[method] = function() {
        this._statements.push({
          grouping: "alterTable",
          method,
          args: toArray(arguments)
        });
        return this;
      };
    });
    var specialMethods = {
      mysql: ["engine", "charset", "collate"],
      postgresql: ["inherits"]
    };
    each(specialMethods, function(methods, dialect) {
      methods.forEach(function(method) {
        TableBuilder.prototype[method] = function(value) {
          if (this.client.dialect !== dialect) {
            throw new Error(
              `Knex only supports ${method} statement with ${dialect}.`
            );
          }
          if (this._method === "alter") {
            throw new Error(
              `Knex does not support altering the ${method} outside of create table, please use knex.raw statement.`
            );
          }
          this._single[method] = value;
        };
      });
    });
    helpers.addQueryContext(TableBuilder);
    var columnTypes = [
      // Numeric
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "bigint",
      "decimal",
      "float",
      "double",
      "real",
      "bit",
      "boolean",
      "serial",
      // Date / Time
      "date",
      "datetime",
      "timestamp",
      "time",
      "year",
      // Geometry
      "geometry",
      "geography",
      "point",
      // String
      "char",
      "varchar",
      "tinytext",
      "tinyText",
      "text",
      "mediumtext",
      "mediumText",
      "longtext",
      "longText",
      "binary",
      "varbinary",
      "tinyblob",
      "tinyBlob",
      "mediumblob",
      "mediumBlob",
      "blob",
      "longblob",
      "longBlob",
      "enum",
      "set",
      // Increments, Aliases, and Additional
      "bool",
      "dateTime",
      "increments",
      "bigincrements",
      "bigIncrements",
      "integer",
      "biginteger",
      "bigInteger",
      "string",
      "json",
      "jsonb",
      "uuid",
      "enu",
      "specificType"
    ];
    columnTypes.forEach((type) => {
      TableBuilder.prototype[type] = function() {
        const args = toArray(arguments);
        const builder = this.client.columnBuilder(this, type, args);
        this._statements.push({
          grouping: "columns",
          builder
        });
        return builder;
      };
    });
    var AlterMethods = {
      // Renames the current column `from` the current
      // TODO: this.column(from).rename(to)
      renameColumn(from, to) {
        this._statements.push({
          grouping: "alterTable",
          method: "renameColumn",
          args: [from, to]
        });
        return this;
      },
      dropTimestamps() {
        return this.dropColumns(
          arguments[0] === true ? ["createdAt", "updatedAt"] : ["created_at", "updated_at"]
        );
      },
      setNullable(column) {
        this._statements.push({
          grouping: "alterTable",
          method: "setNullable",
          args: [column]
        });
        return this;
      },
      check(checkPredicate, bindings, constraintName) {
        this._statements.push({
          grouping: "alterTable",
          method: "check",
          args: [checkPredicate, bindings, constraintName]
        });
      },
      dropChecks() {
        this._statements.push({
          grouping: "alterTable",
          method: "dropChecks",
          args: toArray(arguments)
        });
      },
      dropNullable(column) {
        this._statements.push({
          grouping: "alterTable",
          method: "dropNullable",
          args: [column]
        });
        return this;
      }
      // TODO: changeType
    };
    AlterMethods.dropColumn = AlterMethods.dropColumns = function() {
      this._statements.push({
        grouping: "alterTable",
        method: "dropColumn",
        args: toArray(arguments)
      });
      return this;
    };
    TableBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(TableBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend TableBuilder with existing method ('${methodName}').`
        );
      }
      assign(TableBuilder.prototype, { [methodName]: fn });
    };
    module.exports = TableBuilder;
  }
});

// node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/lodash/indexOf.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module.exports = indexOf;
  }
});

// node_modules/knex/lib/schema/tablecompiler.js
var require_tablecompiler = __commonJS({
  "node_modules/knex/lib/schema/tablecompiler.js"(exports, module) {
    var {
      pushAdditional,
      pushQuery,
      unshiftQuery
    } = require_helpers2();
    var helpers = require_helpers();
    var groupBy = require_groupBy();
    var indexOf = require_indexOf();
    var isEmpty = require_isEmpty();
    var tail = require_tail();
    var { normalizeArr } = require_helpers();
    var TableCompiler = class {
      constructor(client, tableBuilder) {
        this.client = client;
        this.tableBuilder = tableBuilder;
        this._commonBuilder = this.tableBuilder;
        this.method = tableBuilder._method;
        this.schemaNameRaw = tableBuilder._schemaName;
        this.tableNameRaw = tableBuilder._tableName;
        this.tableNameLikeRaw = tableBuilder._tableNameLike;
        this.single = tableBuilder._single;
        this.grouped = groupBy(tableBuilder._statements, "grouping");
        this.formatter = client.formatter(tableBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
        this._formatting = client.config && client.config.formatting;
        this.checksCount = 0;
      }
      // Convert the tableCompiler toSQL
      toSQL() {
        this[this.method]();
        return this.sequence;
      }
      // Column Compilation
      // -------
      // If this is a table "creation", we need to first run through all
      // of the columns to build them into a single string,
      // and then run through anything else and push it to the query sequence.
      create(ifNot, like) {
        const columnBuilders = this.getColumns();
        const columns = columnBuilders.map((col) => col.toSQL());
        const columnTypes = this.getColumnTypes(columns);
        if (this.createAlterTableMethods) {
          this.alterTableForCreate(columnTypes);
        }
        this.createQuery(columnTypes, ifNot, like);
        this.columnQueries(columns);
        delete this.single.comment;
        this.alterTable();
      }
      // Only create the table if it doesn't exist.
      createIfNot() {
        this.create(true);
      }
      createLike() {
        this.create(false, true);
      }
      createLikeIfNot() {
        this.create(true, true);
      }
      // If we're altering the table, we need to one-by-one
      // go through and handle each of the queries associated
      // with altering the table's schema.
      alter() {
        const addColBuilders = this.getColumns();
        const addColumns = addColBuilders.map((col) => col.toSQL());
        const alterColBuilders = this.getColumns("alter");
        const alterColumns = alterColBuilders.map((col) => col.toSQL());
        const addColumnTypes = this.getColumnTypes(addColumns);
        const alterColumnTypes = this.getColumnTypes(alterColumns);
        this.addColumns(addColumnTypes);
        this.alterColumns(alterColumnTypes, alterColBuilders);
        this.columnQueries(addColumns);
        this.columnQueries(alterColumns);
        this.alterTable();
      }
      foreign(foreignData) {
        if (foreignData.inTable && foreignData.references) {
          const keyName = foreignData.keyName ? this.formatter.wrap(foreignData.keyName) : this._indexCommand("foreign", this.tableNameRaw, foreignData.column);
          const column = this.formatter.columnize(foreignData.column);
          const references = this.formatter.columnize(foreignData.references);
          const inTable = this.formatter.wrap(foreignData.inTable);
          const onUpdate = foreignData.onUpdate ? (this.lowerCase ? " on update " : " ON UPDATE ") + foreignData.onUpdate : "";
          const onDelete = foreignData.onDelete ? (this.lowerCase ? " on delete " : " ON DELETE ") + foreignData.onDelete : "";
          const deferrable = foreignData.deferrable ? this.lowerCase ? ` deferrable initially ${foreignData.deferrable.toLowerCase()} ` : ` DEFERRABLE INITIALLY ${foreignData.deferrable.toUpperCase()} ` : "";
          if (this.lowerCase) {
            this.pushQuery(
              (!this.forCreate ? `alter table ${this.tableName()} add ` : "") + "constraint " + keyName + " foreign key (" + column + ") references " + inTable + " (" + references + ")" + onUpdate + onDelete + deferrable
            );
          } else {
            this.pushQuery(
              (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : "") + "CONSTRAINT " + keyName + " FOREIGN KEY (" + column + ") REFERENCES " + inTable + " (" + references + ")" + onUpdate + onDelete + deferrable
            );
          }
        }
      }
      // Get all of the column sql & bindings individually for building the table queries.
      getColumnTypes(columns) {
        return columns.reduce(
          function(memo, columnSQL) {
            const column = columnSQL[0];
            memo.sql.push(column.sql);
            memo.bindings.concat(column.bindings);
            return memo;
          },
          { sql: [], bindings: [] }
        );
      }
      // Adds all of the additional queries from the "column"
      columnQueries(columns) {
        const queries = columns.reduce(function(memo, columnSQL) {
          const column = tail(columnSQL);
          if (!isEmpty(column)) return memo.concat(column);
          return memo;
        }, []);
        for (const q3 of queries) {
          this.pushQuery(q3);
        }
      }
      // All of the columns to "add" for the query
      addColumns(columns, prefix) {
        prefix = prefix || this.addColumnsPrefix;
        if (columns.sql.length > 0) {
          const columnSql = columns.sql.map((column) => {
            return prefix + column;
          });
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + columnSql.join(", "),
            bindings: columns.bindings
          });
        }
      }
      alterColumns(columns, colBuilders) {
        if (columns.sql.length > 0) {
          this.addColumns(columns, this.alterColumnsPrefix, colBuilders);
        }
      }
      // Compile the columns as needed for the current create or alter table
      getColumns(method) {
        const columns = this.grouped.columns || [];
        method = method || "add";
        const queryContext = this.tableBuilder.queryContext();
        return columns.filter((column) => column.builder._method === method).map((column) => {
          if (queryContext !== void 0 && column.builder.queryContext() === void 0) {
            column.builder.queryContext(queryContext);
          }
          return this.client.columnCompiler(this, column.builder);
        });
      }
      tableName() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameRaw}` : this.tableNameRaw;
        return this.formatter.wrap(name);
      }
      tableNameLike() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameLikeRaw}` : this.tableNameLikeRaw;
        return this.formatter.wrap(name);
      }
      // Generate all of the alter column statements necessary for the query.
      alterTable() {
        const alterTable = this.grouped.alterTable || [];
        for (let i3 = 0, l3 = alterTable.length; i3 < l3; i3++) {
          const statement = alterTable[i3];
          if (this[statement.method]) {
            this[statement.method].apply(this, statement.args);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        for (const item in this.single) {
          if (typeof this[item] === "function") this[item](this.single[item]);
        }
      }
      alterTableForCreate(columnTypes) {
        this.forCreate = true;
        const savedSequence = this.sequence;
        const alterTable = this.grouped.alterTable || [];
        this.grouped.alterTable = [];
        for (let i3 = 0, l3 = alterTable.length; i3 < l3; i3++) {
          const statement = alterTable[i3];
          if (indexOf(this.createAlterTableMethods, statement.method) < 0) {
            this.grouped.alterTable.push(statement);
            continue;
          }
          if (this[statement.method]) {
            this.sequence = [];
            this[statement.method].apply(this, statement.args);
            columnTypes.sql.push(this.sequence[0].sql);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        this.sequence = savedSequence;
        this.forCreate = false;
      }
      // Drop the index on the current table.
      dropIndex(value) {
        this.pushQuery(`drop index${value}`);
      }
      dropUnique() {
        throw new Error("Method implemented in the dialect driver");
      }
      dropForeign() {
        throw new Error("Method implemented in the dialect driver");
      }
      dropColumn() {
        const columns = helpers.normalizeArr.apply(null, arguments);
        const drops = (Array.isArray(columns) ? columns : [columns]).map(
          (column) => {
            return this.dropColumnPrefix + this.formatter.wrap(column);
          }
        );
        this.pushQuery(
          (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + drops.join(", ")
        );
      }
      //Default implementation of setNullable. Overwrite on dialect-specific tablecompiler when needed
      //(See postgres/mssql for reference)
      _setNullableState(column, nullable) {
        const tableName = this.tableName();
        const columnName = this.formatter.columnize(column);
        const alterColumnPrefix = this.alterColumnsPrefix;
        return this.pushQuery({
          sql: "SELECT 1",
          output: () => {
            return this.client.queryBuilder().from(this.tableNameRaw).columnInfo(column).then((columnInfo) => {
              if (isEmpty(columnInfo)) {
                throw new Error(
                  `.setNullable: Column ${columnName} does not exist in table ${tableName}.`
                );
              }
              const nullableType2 = nullable ? "null" : "not null";
              const columnType = columnInfo.type + (columnInfo.maxLength ? `(${columnInfo.maxLength})` : "");
              const defaultValue = columnInfo.defaultValue !== null && columnInfo.defaultValue !== void 0 ? `default '${columnInfo.defaultValue}'` : "";
              const sql = `alter table ${tableName} ${alterColumnPrefix} ${columnName} ${columnType} ${nullableType2} ${defaultValue}`;
              return this.client.raw(sql);
            });
          }
        });
      }
      setNullable(column) {
        return this._setNullableState(column, true);
      }
      dropNullable(column) {
        return this._setNullableState(column, false);
      }
      dropChecks(checkConstraintNames) {
        if (checkConstraintNames === void 0) return "";
        checkConstraintNames = normalizeArr(checkConstraintNames);
        const tableName = this.tableName();
        const sql = `alter table ${tableName} ${checkConstraintNames.map((constraint) => `drop constraint ${constraint}`).join(", ")}`;
        this.pushQuery(sql);
      }
      check(checkPredicate, bindings, constraintName) {
        const tableName = this.tableName();
        let checkConstraint = constraintName;
        if (!checkConstraint) {
          this.checksCount++;
          checkConstraint = tableName + "_" + this.checksCount;
        }
        const sql = `alter table ${tableName} add constraint ${checkConstraint} check(${checkPredicate})`;
        this.pushQuery(sql);
      }
      _addChecks() {
        if (this.grouped.checks) {
          return ", " + this.grouped.checks.map((c3) => {
            return `${c3.args[2] ? "constraint " + c3.args[2] + " " : ""}check (${this.client.raw(c3.args[0], c3.args[1])})`;
          }).join(", ");
        }
        return "";
      }
      // If no name was specified for this index, we will create one using a basic
      // convention of the table name, followed by the columns, followed by an
      // index type, such as primary or index, which makes the index unique.
      _indexCommand(type, tableName, columns) {
        if (!Array.isArray(columns)) columns = columns ? [columns] : [];
        const table = tableName.replace(/\.|-/g, "_");
        const indexName = (table + "_" + columns.join("_") + "_" + type).toLowerCase();
        return this.formatter.wrap(indexName);
      }
      _getPrimaryKeys() {
        return (this.grouped.alterTable || []).filter((a3) => a3.method === "primary").flatMap((a3) => a3.args).flat();
      }
      _canBeAddPrimaryKey(options) {
        return options.primaryKey && this._getPrimaryKeys().length === 0;
      }
      _getIncrementsColumnNames() {
        return this.grouped.columns.filter((c3) => c3.builder._type === "increments").map((c3) => c3.builder._args[0]);
      }
      _getBigIncrementsColumnNames() {
        return this.grouped.columns.filter((c3) => c3.builder._type === "bigincrements").map((c3) => c3.builder._args[0]);
      }
    };
    TableCompiler.prototype.pushQuery = pushQuery;
    TableCompiler.prototype.pushAdditional = pushAdditional;
    TableCompiler.prototype.unshiftQuery = unshiftQuery;
    TableCompiler.prototype.lowerCase = true;
    TableCompiler.prototype.createAlterTableMethods = null;
    TableCompiler.prototype.addColumnsPrefix = "add column ";
    TableCompiler.prototype.alterColumnsPrefix = "alter column ";
    TableCompiler.prototype.modifyColumnPrefix = "modify column ";
    TableCompiler.prototype.dropColumnPrefix = "drop column ";
    module.exports = TableCompiler;
  }
});

// node_modules/knex/lib/schema/columnbuilder.js
var require_columnbuilder = __commonJS({
  "node_modules/knex/lib/schema/columnbuilder.js"(exports, module) {
    var extend = require_extend();
    var assign = require_assign();
    var toArray = require_toArray();
    var { addQueryContext } = require_helpers();
    var ColumnBuilder = class {
      constructor(client, tableBuilder, type, args) {
        this.client = client;
        this._method = "add";
        this._single = {};
        this._modifiers = {};
        this._statements = [];
        this._type = columnAlias[type] || type;
        this._args = args;
        this._tableBuilder = tableBuilder;
        if (tableBuilder._method === "alter") {
          extend(this, AlterMethods);
        }
      }
      // Specify that the current column "references" a column,
      // which may be tableName.column or just "column"
      references(value) {
        return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], void 0, this)._columnBuilder(this).references(value);
      }
    };
    var modifiers = [
      "default",
      "defaultsTo",
      "defaultTo",
      "unsigned",
      "nullable",
      "first",
      "after",
      "comment",
      "collate",
      "check",
      "checkPositive",
      "checkNegative",
      "checkIn",
      "checkNotIn",
      "checkBetween",
      "checkLength",
      "checkRegex"
    ];
    var aliasMethod = {
      default: "defaultTo",
      defaultsTo: "defaultTo"
    };
    modifiers.forEach(function(method) {
      const key = aliasMethod[method] || method;
      ColumnBuilder.prototype[method] = function() {
        this._modifiers[key] = toArray(arguments);
        return this;
      };
    });
    addQueryContext(ColumnBuilder);
    ColumnBuilder.prototype.notNull = ColumnBuilder.prototype.notNullable = function notNullable() {
      return this.nullable(false);
    };
    ["index", "primary", "unique"].forEach(function(method) {
      ColumnBuilder.prototype[method] = function() {
        if (this._type.toLowerCase().indexOf("increments") === -1) {
          this._tableBuilder[method].apply(
            this._tableBuilder,
            [this._args[0]].concat(toArray(arguments))
          );
        }
        return this;
      };
    });
    ColumnBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(ColumnBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend ColumnBuilder with existing method ('${methodName}').`
        );
      }
      assign(ColumnBuilder.prototype, { [methodName]: fn });
    };
    var AlterMethods = {};
    AlterMethods.drop = function() {
      this._single.drop = true;
      return this;
    };
    AlterMethods.alterType = function(type) {
      this._statements.push({
        grouping: "alterType",
        value: type
      });
      return this;
    };
    AlterMethods.alter = function({
      alterNullable = true,
      alterType = true
    } = {}) {
      this._method = "alter";
      this.alterNullable = alterNullable;
      this.alterType = alterType;
      return this;
    };
    var columnAlias = {
      float: "floating",
      enum: "enu",
      boolean: "bool",
      string: "varchar",
      bigint: "bigInteger"
    };
    module.exports = ColumnBuilder;
  }
});

// node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/lodash/head.js"(exports, module) {
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    module.exports = head;
  }
});

// node_modules/lodash/first.js
var require_first = __commonJS({
  "node_modules/lodash/first.js"(exports, module) {
    module.exports = require_head();
  }
});

// node_modules/knex/lib/schema/columncompiler.js
var require_columncompiler = __commonJS({
  "node_modules/knex/lib/schema/columncompiler.js"(exports, module) {
    var helpers = require_helpers2();
    var groupBy = require_groupBy();
    var first = require_first();
    var has = require_has();
    var tail = require_tail();
    var { toNumber } = require_helpers();
    var { formatDefault } = require_formatterUtils();
    var { operator: operator_ } = require_wrappingFormatter();
    var ColumnCompiler = class {
      constructor(client, tableCompiler, columnBuilder) {
        this.client = client;
        this.tableCompiler = tableCompiler;
        this.columnBuilder = columnBuilder;
        this._commonBuilder = this.columnBuilder;
        this.args = columnBuilder._args;
        this.type = columnBuilder._type.toLowerCase();
        this.grouped = groupBy(columnBuilder._statements, "grouping");
        this.modified = columnBuilder._modifiers;
        this.isIncrements = this.type.indexOf("increments") !== -1;
        this.formatter = client.formatter(columnBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
        this.modifiers = [];
        this.checksCount = 0;
      }
      _addCheckModifiers() {
        this.modifiers.push(
          "check",
          "checkPositive",
          "checkNegative",
          "checkIn",
          "checkNotIn",
          "checkBetween",
          "checkLength",
          "checkRegex"
        );
      }
      defaults(label) {
        if (Object.prototype.hasOwnProperty.call(this._defaultMap, label)) {
          return this._defaultMap[label].bind(this)();
        } else {
          throw new Error(
            `There is no default for the specified identifier ${label}`
          );
        }
      }
      // To convert to sql, we first go through and build the
      // column as it would be in the insert statement
      toSQL() {
        this.pushQuery(this.compileColumn());
        if (this.sequence.additional) {
          this.sequence = this.sequence.concat(this.sequence.additional);
        }
        return this.sequence;
      }
      // Compiles a column.
      compileColumn() {
        return this.formatter.wrap(this.getColumnName()) + " " + this.getColumnType() + this.getModifiers();
      }
      // Assumes the autoincrementing key is named `id` if not otherwise specified.
      getColumnName() {
        const value = first(this.args);
        return value || this.defaults("columnName");
      }
      getColumnType() {
        if (!this._columnType) {
          const type = this[this.type];
          this._columnType = typeof type === "function" ? type.apply(this, tail(this.args)) : type;
        }
        return this._columnType;
      }
      getModifiers() {
        const modifiers = [];
        for (let i3 = 0, l3 = this.modifiers.length; i3 < l3; i3++) {
          const modifier = this.modifiers[i3];
          if (!this.isIncrements || this.isIncrements && modifier === "comment") {
            if (has(this.modified, modifier)) {
              const val2 = this[modifier].apply(this, this.modified[modifier]);
              if (val2) modifiers.push(val2);
            }
          }
        }
        return modifiers.length > 0 ? ` ${modifiers.join(" ")}` : "";
      }
      // Types
      // ------
      varchar(length) {
        return `varchar(${toNumber(length, 255)})`;
      }
      floating(precision, scale) {
        return `float(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      decimal(precision, scale) {
        if (precision === null) {
          throw new Error(
            "Specifying no precision on decimal columns is not supported for that SQL dialect."
          );
        }
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      // Used to support custom types
      specifictype(type) {
        return type;
      }
      // Modifiers
      // -------
      nullable(nullable) {
        return nullable === false ? "not null" : "null";
      }
      notNullable() {
        return this.nullable(false);
      }
      defaultTo(value) {
        return `default ${formatDefault(value, this.type, this.client)}`;
      }
      increments(options = { primaryKey: true }) {
        return "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "") + " autoincrement";
      }
      bigincrements(options = { primaryKey: true }) {
        return this.increments(options);
      }
      _pushAlterCheckQuery(checkPredicate, constraintName) {
        let checkName = constraintName;
        if (!checkName) {
          this.checksCount++;
          checkName = this.tableCompiler.tableNameRaw + "_" + this.getColumnName() + "_" + this.checksCount;
        }
        this.pushAdditional(function() {
          this.pushQuery(
            `alter table ${this.tableCompiler.tableName()} add constraint ${checkName} check(${checkPredicate})`
          );
        });
      }
      _checkConstraintName(constraintName) {
        return constraintName ? `constraint ${constraintName} ` : "";
      }
      _check(checkPredicate, constraintName) {
        if (this.columnBuilder._method === "alter") {
          this._pushAlterCheckQuery(checkPredicate, constraintName);
          return "";
        }
        return `${this._checkConstraintName(
          constraintName
        )}check (${checkPredicate})`;
      }
      checkPositive(constraintName) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${operator_(
            ">",
            this.columnBuilder,
            this.bindingsHolder
          )} 0`,
          constraintName
        );
      }
      checkNegative(constraintName) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${operator_(
            "<",
            this.columnBuilder,
            this.bindingsHolder
          )} 0`,
          constraintName
        );
      }
      _checkIn(values, constraintName, not) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${not ? "not " : ""}in (${values.map((v6) => this.client._escapeBinding(v6)).join(",")})`,
          constraintName
        );
      }
      checkIn(values, constraintName) {
        return this._checkIn(values, constraintName);
      }
      checkNotIn(values, constraintName) {
        return this._checkIn(values, constraintName, true);
      }
      checkBetween(intervals, constraintName) {
        if (intervals.length === 2 && !Array.isArray(intervals[0]) && !Array.isArray(intervals[1])) {
          intervals = [intervals];
        }
        const intervalChecks = intervals.map((interval) => {
          return `${this.formatter.wrap(
            this.getColumnName()
          )} between ${this.client._escapeBinding(
            interval[0]
          )} and ${this.client._escapeBinding(interval[1])}`;
        }).join(" or ");
        return this._check(intervalChecks, constraintName);
      }
      checkLength(operator, length, constraintName) {
        return this._check(
          `length(${this.formatter.wrap(this.getColumnName())}) ${operator_(
            operator,
            this.columnBuilder,
            this.bindingsHolder
          )} ${toNumber(length)}`,
          constraintName
        );
      }
    };
    ColumnCompiler.prototype.binary = "blob";
    ColumnCompiler.prototype.bool = "boolean";
    ColumnCompiler.prototype.date = "date";
    ColumnCompiler.prototype.datetime = "datetime";
    ColumnCompiler.prototype.time = "time";
    ColumnCompiler.prototype.timestamp = "timestamp";
    ColumnCompiler.prototype.geometry = "geometry";
    ColumnCompiler.prototype.geography = "geography";
    ColumnCompiler.prototype.point = "point";
    ColumnCompiler.prototype.enu = "varchar";
    ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = "text";
    ColumnCompiler.prototype.uuid = ({
      useBinaryUuid = false,
      primaryKey = false
    } = {}) => useBinaryUuid ? "binary(16)" : "char(36)";
    ColumnCompiler.prototype.integer = ColumnCompiler.prototype.smallint = ColumnCompiler.prototype.mediumint = "integer";
    ColumnCompiler.prototype.biginteger = "bigint";
    ColumnCompiler.prototype.text = "text";
    ColumnCompiler.prototype.tinyint = "tinyint";
    ColumnCompiler.prototype.pushQuery = helpers.pushQuery;
    ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;
    ColumnCompiler.prototype.unshiftQuery = helpers.unshiftQuery;
    ColumnCompiler.prototype._defaultMap = {
      columnName: function() {
        if (!this.isIncrements) {
          throw new Error(
            `You did not specify a column name for the ${this.type} column.`
          );
        }
        return "id";
      }
    };
    module.exports = ColumnCompiler;
  }
});

// node_modules/knex/lib/ref.js
var require_ref = __commonJS({
  "node_modules/knex/lib/ref.js"(exports, module) {
    var Raw = require_raw();
    var Ref = class extends Raw {
      constructor(client, ref) {
        super(client);
        this.ref = ref;
        this._schema = null;
        this._alias = null;
      }
      withSchema(schema) {
        this._schema = schema;
        return this;
      }
      as(alias) {
        this._alias = alias;
        return this;
      }
      toSQL() {
        const string = this._schema ? `${this._schema}.${this.ref}` : this.ref;
        const formatter = this.client.formatter(this);
        const ref = formatter.columnize(string);
        const sql = this._alias ? `${ref} as ${formatter.wrap(this._alias)}` : ref;
        this.set(sql, []);
        return super.toSQL(...arguments);
      }
    };
    module.exports = Ref;
  }
});

// node_modules/knex/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/knex/lib/formatter.js"(exports, module) {
    var {
      columnize: columnize_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var Formatter = class {
      constructor(client, builder) {
        this.client = client;
        this.builder = builder;
        this.bindings = [];
      }
      // Accepts a string or array of columns to wrap as appropriate.
      columnize(target) {
        return columnize_(target, this.builder, this.client, this);
      }
      // Puts the appropriate wrapper around a value depending on the database
      // engine, unless it's a knex.raw value, in which case it's left alone.
      wrap(value, isParameter) {
        return wrap_(value, isParameter, this.builder, this.client, this);
      }
    };
    module.exports = Formatter;
  }
});

// node_modules/knex/lib/schema/viewbuilder.js
var require_viewbuilder = __commonJS({
  "node_modules/knex/lib/schema/viewbuilder.js"(exports, module) {
    var helpers = require_helpers();
    var extend = require_extend();
    var assign = require_assign();
    var ViewBuilder = class {
      constructor(client, method, viewName, fn) {
        this.client = client;
        this._method = method;
        this._schemaName = void 0;
        this._columns = void 0;
        this._fn = fn;
        this._viewName = viewName;
        this._statements = [];
        this._single = {};
      }
      setSchema(schemaName) {
        this._schemaName = schemaName;
      }
      columns(columns) {
        this._columns = columns;
      }
      as(selectQuery) {
        this._selectQuery = selectQuery;
      }
      checkOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      localCheckOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      cascadedCheckOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      toSQL() {
        if (this._method === "alter") {
          extend(this, AlterMethods);
        }
        this._fn.call(this, this);
        return this.client.viewCompiler(this).toSQL();
      }
    };
    var AlterMethods = {
      column(column) {
        const self2 = this;
        return {
          rename: function(newName) {
            self2._statements.push({
              grouping: "alterView",
              method: "renameColumn",
              args: [column, newName]
            });
            return this;
          },
          defaultTo: function(defaultValue) {
            self2._statements.push({
              grouping: "alterView",
              method: "defaultTo",
              args: [column, defaultValue]
            });
            return this;
          }
        };
      }
    };
    helpers.addQueryContext(ViewBuilder);
    ViewBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(ViewBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend ViewBuilder with existing method ('${methodName}').`
        );
      }
      assign(ViewBuilder.prototype, { [methodName]: fn });
    };
    module.exports = ViewBuilder;
  }
});

// node_modules/knex/lib/schema/viewcompiler.js
var require_viewcompiler = __commonJS({
  "node_modules/knex/lib/schema/viewcompiler.js"(exports, module) {
    var { pushQuery } = require_helpers2();
    var groupBy = require_groupBy();
    var { columnize: columnize_ } = require_wrappingFormatter();
    var ViewCompiler = class {
      constructor(client, viewBuilder) {
        this.client = client;
        this.viewBuilder = viewBuilder;
        this._commonBuilder = this.viewBuilder;
        this.method = viewBuilder._method;
        this.schemaNameRaw = viewBuilder._schemaName;
        this.viewNameRaw = viewBuilder._viewName;
        this.single = viewBuilder._single;
        this.selectQuery = viewBuilder._selectQuery;
        this.columns = viewBuilder._columns;
        this.grouped = groupBy(viewBuilder._statements, "grouping");
        this.formatter = client.formatter(viewBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
      }
      // Convert the tableCompiler toSQL
      toSQL() {
        this[this.method]();
        return this.sequence;
      }
      // Column Compilation
      // -------
      create() {
        this.createQuery(this.columns, this.selectQuery);
      }
      createOrReplace() {
        throw new Error("replace views is not supported by this dialect.");
      }
      createMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      createQuery(columns, selectQuery, materialized, replace) {
        const createStatement = "create " + (materialized ? "materialized " : "") + (replace ? "or replace " : "") + "view ";
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        let sql = createStatement + this.viewName() + columnList;
        sql += " as ";
        sql += selectQuery.toString();
        switch (this.single.checkOption) {
          case "default_option":
            sql += " with check option";
            break;
          case "local":
            sql += " with local check option";
            break;
          case "cascaded":
            sql += " with cascaded check option";
            break;
          default:
            break;
        }
        this.pushQuery({
          sql
        });
      }
      renameView(from, to) {
        throw new Error(
          "rename view is not supported by this dialect (instead drop, then create another view)."
        );
      }
      refreshMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      alter() {
        this.alterView();
      }
      alterView() {
        const alterView = this.grouped.alterView || [];
        for (let i3 = 0, l3 = alterView.length; i3 < l3; i3++) {
          const statement = alterView[i3];
          if (this[statement.method]) {
            this[statement.method].apply(this, statement.args);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        for (const item in this.single) {
          if (typeof this[item] === "function") this[item](this.single[item]);
        }
      }
      renameColumn(from, to) {
        throw new Error("rename column of views is not supported by this dialect.");
      }
      defaultTo(column, defaultValue) {
        throw new Error(
          "change default values of views is not supported by this dialect."
        );
      }
      viewName() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.viewNameRaw}` : this.viewNameRaw;
        return this.formatter.wrap(name);
      }
    };
    ViewCompiler.prototype.pushQuery = pushQuery;
    module.exports = ViewCompiler;
  }
});

// node_modules/knex/lib/client.js
var require_client = __commonJS({
  "node_modules/knex/lib/client.js"(exports, module) {
    var { Pool, TimeoutError } = require_tarn();
    var { EventEmitter } = __require("events");
    var { promisify } = __require("util");
    var { makeEscape } = require_string();
    var cloneDeep = require_cloneDeep();
    var defaults = require_defaults();
    var uniqueId = require_uniqueId();
    var Runner = require_runner();
    var Transaction = require_transaction();
    var {
      executeQuery,
      enrichQueryObject
    } = require_query_executioner();
    var QueryBuilder = require_querybuilder();
    var QueryCompiler = require_querycompiler();
    var SchemaBuilder = require_builder();
    var SchemaCompiler = require_compiler();
    var TableBuilder = require_tablebuilder();
    var TableCompiler = require_tablecompiler();
    var ColumnBuilder = require_columnbuilder();
    var ColumnCompiler = require_columncompiler();
    var { KnexTimeoutError } = require_timeout();
    var { outputQuery, unwrapRaw } = require_wrappingFormatter();
    var { compileCallback } = require_formatterUtils();
    var Raw = require_raw();
    var Ref = require_ref();
    var Formatter = require_formatter();
    var Logger = require_logger();
    var { POOL_CONFIG_OPTIONS } = require_constants3();
    var ViewBuilder = require_viewbuilder();
    var ViewCompiler = require_viewcompiler();
    var isPlainObject = require_isPlainObject();
    var { setHiddenProperty } = require_security();
    var debug = require_src()("knex:client");
    var Client = class extends EventEmitter {
      constructor(config = {}) {
        super();
        this.config = config;
        this.logger = new Logger(config);
        if (this.config.connection && this.config.connection.password) {
          setHiddenProperty(this.config.connection);
        }
        if (this.dialect && !this.config.client) {
          this.logger.warn(
            `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`
          );
        }
        const dbClient = this.config.client || this.dialect;
        if (!dbClient) {
          throw new Error(
            `knex: Required configuration option 'client' is missing.`
          );
        }
        if (config.version) {
          this.version = config.version;
        }
        if (config.connection && config.connection instanceof Function) {
          this.connectionConfigProvider = config.connection;
          this.connectionConfigExpirationChecker = () => true;
        } else {
          this.connectionSettings = cloneDeep(config.connection || {});
          if (config.connection && config.connection.password) {
            setHiddenProperty(this.connectionSettings, config.connection);
          }
          this.connectionConfigExpirationChecker = null;
        }
        if (this.driverName && config.connection) {
          this.initializeDriver();
          if (!config.pool || config.pool && config.pool.max !== 0) {
            this.initializePool(config);
          }
        }
        this.valueForUndefined = this.raw("DEFAULT");
        if (config.useNullAsDefault) {
          this.valueForUndefined = null;
        }
      }
      formatter(builder) {
        return new Formatter(this, builder);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      schemaBuilder() {
        return new SchemaBuilder(this);
      }
      schemaCompiler(builder) {
        return new SchemaCompiler(this, builder);
      }
      tableBuilder(type, tableName, tableNameLike, fn) {
        return new TableBuilder(this, type, tableName, tableNameLike, fn);
      }
      viewBuilder(type, viewBuilder, fn) {
        return new ViewBuilder(this, type, viewBuilder, fn);
      }
      tableCompiler(tableBuilder) {
        return new TableCompiler(this, tableBuilder);
      }
      viewCompiler(viewCompiler) {
        return new ViewCompiler(this, viewCompiler);
      }
      columnBuilder(tableBuilder, type, args) {
        return new ColumnBuilder(this, tableBuilder, type, args);
      }
      columnCompiler(tableBuilder, columnBuilder) {
        return new ColumnCompiler(this, tableBuilder, columnBuilder);
      }
      runner(builder) {
        return new Runner(this, builder);
      }
      transaction(container, config, outerTx) {
        return new Transaction(this, container, config, outerTx);
      }
      raw() {
        return new Raw(this).set(...arguments);
      }
      ref() {
        return new Ref(this, ...arguments);
      }
      query(connection, queryParam) {
        const queryObject = enrichQueryObject(connection, queryParam, this);
        return executeQuery(connection, queryObject, this);
      }
      stream(connection, queryParam, stream2, options) {
        const queryObject = enrichQueryObject(connection, queryParam, this);
        return this._stream(connection, queryObject, stream2, options);
      }
      prepBindings(bindings) {
        return bindings;
      }
      positionBindings(sql) {
        return sql;
      }
      postProcessResponse(resp, queryContext) {
        if (this.config.postProcessResponse) {
          return this.config.postProcessResponse(resp, queryContext);
        }
        return resp;
      }
      wrapIdentifier(value, queryContext) {
        return this.customWrapIdentifier(
          value,
          this.wrapIdentifierImpl,
          queryContext
        );
      }
      customWrapIdentifier(value, origImpl, queryContext) {
        if (this.config.wrapIdentifier) {
          return this.config.wrapIdentifier(value, origImpl, queryContext);
        }
        return origImpl(value);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `"${value.replace(/"/g, '""')}"` : "*";
      }
      initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e3) {
          const message = `Knex: run
$ npm install ${this.driverName} --save`;
          this.logger.error(`${message}
${e3.message}
${e3.stack}`);
          throw new Error(`${message}
${e3.message}`);
        }
      }
      poolDefaults() {
        return { min: 2, max: 10, propagateCreateError: true };
      }
      getPoolSettings(poolConfig) {
        poolConfig = defaults({}, poolConfig, this.poolDefaults());
        POOL_CONFIG_OPTIONS.forEach((option) => {
          if (option in poolConfig) {
            this.logger.warn(
              [
                `Pool config option "${option}" is no longer supported.`,
                `See https://github.com/Vincit/tarn.js for possible pool config options.`
              ].join(" ")
            );
          }
        });
        const DEFAULT_ACQUIRE_TIMEOUT = 6e4;
        const timeouts = [
          this.config.acquireConnectionTimeout,
          poolConfig.acquireTimeoutMillis
        ].filter((timeout) => timeout !== void 0);
        if (!timeouts.length) {
          timeouts.push(DEFAULT_ACQUIRE_TIMEOUT);
        }
        poolConfig.acquireTimeoutMillis = Math.min(...timeouts);
        const updatePoolConnectionSettingsFromProvider = async () => {
          if (!this.connectionConfigProvider) {
            return;
          }
          if (!this.connectionConfigExpirationChecker || !this.connectionConfigExpirationChecker()) {
            return;
          }
          const providerResult = await this.connectionConfigProvider();
          if (providerResult.expirationChecker) {
            this.connectionConfigExpirationChecker = providerResult.expirationChecker;
            delete providerResult.expirationChecker;
          } else {
            this.connectionConfigExpirationChecker = null;
          }
          this.connectionSettings = providerResult;
        };
        return Object.assign(poolConfig, {
          create: async () => {
            await updatePoolConnectionSettingsFromProvider();
            const connection = await this.acquireRawConnection();
            connection.__knexUid = uniqueId("__knexUid");
            if (poolConfig.afterCreate) {
              await promisify(poolConfig.afterCreate)(connection);
            }
            return connection;
          },
          destroy: (connection) => {
            if (connection !== void 0) {
              return this.destroyRawConnection(connection);
            }
          },
          validate: (connection) => {
            if (connection.__knex__disposed) {
              this.logger.warn(`Connection Error: ${connection.__knex__disposed}`);
              return false;
            }
            return this.validateConnection(connection);
          }
        });
      }
      initializePool(config = this.config) {
        if (this.pool) {
          this.logger.warn("The pool has already been initialized");
          return;
        }
        const tarnPoolConfig = {
          ...this.getPoolSettings(config.pool)
        };
        if (tarnPoolConfig.afterCreate) {
          delete tarnPoolConfig.afterCreate;
        }
        this.pool = new Pool(tarnPoolConfig);
      }
      validateConnection(connection) {
        return true;
      }
      // Acquire a connection from the pool.
      async acquireConnection() {
        if (!this.pool) {
          throw new Error("Unable to acquire a connection");
        }
        try {
          const connection = await this.pool.acquire().promise;
          debug("acquired connection from pool: %s", connection.__knexUid);
          if (connection.config) {
            if (connection.config.password) {
              setHiddenProperty(connection.config);
            }
            if (connection.config.authentication && connection.config.authentication.options && connection.config.authentication.options.password) {
              setHiddenProperty(connection.config.authentication.options);
            }
          }
          return connection;
        } catch (error) {
          let convertedError = error;
          if (error instanceof TimeoutError) {
            convertedError = new KnexTimeoutError(
              "Knex: Timeout acquiring a connection. The pool is probably full. Are you missing a .transacting(trx) call?"
            );
          }
          throw convertedError;
        }
      }
      // Releases a connection back to the connection pool,
      // returning a promise resolved when the connection is released.
      releaseConnection(connection) {
        debug("releasing connection to pool: %s", connection.__knexUid);
        const didRelease = this.pool.release(connection);
        if (!didRelease) {
          debug("pool refused connection: %s", connection.__knexUid);
        }
        return Promise.resolve();
      }
      // Destroy the current connection pool for the client.
      async destroy(callback) {
        try {
          if (this.pool && this.pool.destroy) {
            await this.pool.destroy();
          }
          this.pool = void 0;
          if (typeof callback === "function") {
            callback();
          }
        } catch (err) {
          if (typeof callback === "function") {
            return callback(err);
          }
          throw err;
        }
      }
      // Return the database being used by this client.
      database() {
        return this.connectionSettings.database;
      }
      toString() {
        return "[object KnexClient]";
      }
      assertCanCancelQuery() {
        if (!this.canCancelQuery) {
          throw new Error("Query cancelling not supported for this dialect");
        }
      }
      cancelQuery() {
        throw new Error("Query cancelling not supported for this dialect");
      }
      // Formatter part
      alias(first, second) {
        return first + " as " + second;
      }
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter(value, builder, bindingsHolder) {
        if (typeof value === "function") {
          return outputQuery(
            compileCallback(value, void 0, this, bindingsHolder),
            true,
            builder,
            this
          );
        }
        return unwrapRaw(value, true, builder, this, bindingsHolder) || "?";
      }
      // Turns a list of values into a list of ?'s, joining them with commas unless
      // a "joining" value is specified (e.g. ' and ')
      parameterize(values, notSetValue, builder, bindingsHolder) {
        if (typeof values === "function")
          return this.parameter(values, builder, bindingsHolder);
        values = Array.isArray(values) ? values : [values];
        let str = "", i3 = -1;
        while (++i3 < values.length) {
          if (i3 > 0) str += ", ";
          let value = values[i3];
          if (isPlainObject(value)) {
            value = JSON.stringify(value);
          }
          str += this.parameter(
            value === void 0 ? notSetValue : value,
            builder,
            bindingsHolder
          );
        }
        return str;
      }
      // Formats `values` into a parenthesized list of parameters for a `VALUES`
      // clause.
      //
      // [1, 2]                  -> '(?, ?)'
      // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
      // knex('table')           -> '(select * from "table")'
      // knex.raw('select ?', 1) -> '(select ?)'
      //
      values(values, builder, bindingsHolder) {
        if (Array.isArray(values)) {
          if (Array.isArray(values[0])) {
            return `(${values.map(
              (value) => `(${this.parameterize(
                value,
                void 0,
                builder,
                bindingsHolder
              )})`
            ).join(", ")})`;
          }
          return `(${this.parameterize(
            values,
            void 0,
            builder,
            bindingsHolder
          )})`;
        }
        if (values && values.isRawInstance) {
          return `(${this.parameter(values, builder, bindingsHolder)})`;
        }
        return this.parameter(values, builder, bindingsHolder);
      }
      processPassedConnection(connection) {
      }
      toPathForJson(jsonPath) {
        return jsonPath;
      }
    };
    Object.assign(Client.prototype, {
      _escapeBinding: makeEscape({
        escapeString(str) {
          return `'${str.replace(/'/g, "''")}'`;
        }
      }),
      canCancelQuery: false
    });
    module.exports = Client;
  }
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS({
  "node_modules/pg-connection-string/index.js"(exports, module) {
    "use strict";
    function parse4(str) {
      if (str.charAt(0) === "/") {
        const config2 = str.split(" ");
        return { host: config2[0], database: config2[1] };
      }
      const config = {};
      let result;
      let dummyHost = false;
      if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
        str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
      }
      try {
        result = new URL(str, "postgres://base");
      } catch (e3) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
      for (const entry of result.searchParams.entries()) {
        config[entry[0]] = entry[1];
      }
      config.user = config.user || decodeURIComponent(result.username);
      config.password = config.password || decodeURIComponent(result.password);
      if (result.protocol == "socket:") {
        config.host = decodeURI(result.pathname);
        config.database = result.searchParams.get("db");
        config.client_encoding = result.searchParams.get("encoding");
        return config;
      }
      const hostname = dummyHost ? "" : result.hostname;
      if (!config.host) {
        config.host = decodeURIComponent(hostname);
      } else if (hostname && /^%2f/i.test(hostname)) {
        result.pathname = hostname + result.pathname;
      }
      if (!config.port) {
        config.port = result.port;
      }
      const pathname = result.pathname.slice(1) || null;
      config.database = pathname ? decodeURI(pathname) : null;
      if (config.ssl === "true" || config.ssl === "1") {
        config.ssl = true;
      }
      if (config.ssl === "0") {
        config.ssl = false;
      }
      if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
        config.ssl = {};
      }
      const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
      if (config.sslcert) {
        config.ssl.cert = fs.readFileSync(config.sslcert).toString();
      }
      if (config.sslkey) {
        config.ssl.key = fs.readFileSync(config.sslkey).toString();
      }
      if (config.sslrootcert) {
        config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
      }
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
      return config;
    }
    module.exports = parse4;
    parse4.parse = parse4;
  }
});

// node_modules/knex/lib/knex-builder/internal/parse-connection.js
var require_parse_connection = __commonJS({
  "node_modules/knex/lib/knex-builder/internal/parse-connection.js"(exports, module) {
    var { parse: parse4 } = require_pg_connection_string();
    var parsePG = parse4;
    var isWindows = process && process.platform && process.platform === "win32";
    function tryParse(str) {
      try {
        return new URL(str);
      } catch (e3) {
        return null;
      }
    }
    module.exports = function parseConnectionString(str) {
      const parsed = tryParse(str);
      const isDriveLetter = isWindows && parsed && parsed.protocol.length === 2;
      if (!parsed || isDriveLetter) {
        return {
          client: "sqlite3",
          connection: {
            filename: str
          }
        };
      }
      let { protocol } = parsed;
      if (protocol.slice(-1) === ":") {
        protocol = protocol.slice(0, -1);
      }
      const isPG = ["postgresql", "postgres"].includes(protocol);
      return {
        client: protocol,
        connection: isPG ? parsePG(str) : connectionObject(parsed)
      };
    };
    function connectionObject(parsed) {
      const connection = {};
      let db = parsed.pathname;
      if (db[0] === "/") {
        db = db.slice(1);
      }
      connection.database = db;
      if (parsed.hostname) {
        if (parsed.protocol.indexOf("mssql") === 0) {
          connection.server = parsed.hostname;
        } else {
          connection.host = parsed.hostname;
        }
      }
      if (parsed.port) {
        connection.port = parsed.port;
      }
      if (parsed.username || parsed.password) {
        connection.user = decodeURIComponent(parsed.username);
      }
      if (parsed.password) {
        connection.password = decodeURIComponent(parsed.password);
      }
      if (parsed.searchParams) {
        for (const [key, value] of parsed.searchParams.entries()) {
          const isNestedConfigSupported = ["mysql:", "mariadb:", "mssql:"].includes(
            parsed.protocol
          );
          if (isNestedConfigSupported) {
            try {
              connection[key] = JSON.parse(value);
            } catch (err) {
              connection[key] = value;
            }
          } else {
            connection[key] = value;
          }
        }
      }
      return connection;
    }
  }
});

// node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js
var require_sqlite_transaction = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var Transaction_Sqlite = class extends Transaction {
      begin(conn) {
        if (this.isolationLevel) {
          this.client.logger.warn(
            "sqlite3 only supports serializable transactions, ignoring the isolation level param"
          );
        }
        if (this.readOnly) {
          this.client.logger.warn(
            "sqlite3 implicitly handles read vs write transactions"
          );
        }
        return this.query(conn, "BEGIN;");
      }
    };
    module.exports = Transaction_Sqlite;
  }
});

// node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js
var require_sqlite_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js"(exports, module) {
    var constant = require_constant();
    var each = require_each();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var noop = require_noop2();
    var { isString } = require_is();
    var {
      wrapString,
      columnize: columnize_
    } = require_wrappingFormatter();
    var emptyStr = constant("");
    var QueryCompiler_SQLite3 = class extends QueryCompiler {
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        this.forShare = emptyStr;
        this.forKeyShare = emptyStr;
        this.forUpdate = emptyStr;
        this.forNoKeyUpdate = emptyStr;
      }
      // SQLite requires us to build the multi-row insert as a listing of select with
      // unions joining them together. So we'll build out this list of columns and
      // then join them all together with select unions to complete the queries.
      insert() {
        const insertValues = this.single.insert || [];
        let sql = this.with() + `insert into ${this.tableName} `;
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          } else if (insertValues.length === 1 && insertValues[0] && isEmpty(insertValues[0])) {
            return {
              sql: sql + this._emptyInsertValue
            };
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql + this._emptyInsertValue
          };
        }
        const insertData = this._prepInsert(insertValues);
        if (isString(insertData)) {
          return {
            sql: sql + insertData
          };
        }
        if (insertData.columns.length === 0) {
          return {
            sql: ""
          };
        }
        sql += `(${this.formatter.columnize(insertData.columns)})`;
        if (this.client.valueForUndefined !== null) {
          insertData.values.forEach((bindings) => {
            each(bindings, (binding) => {
              if (binding === void 0)
                throw new TypeError(
                  "`sqlite` does not support inserting default values. Specify values explicitly or use the `useNullAsDefault` config flag. (see docs https://knexjs.org/guide/query-builder.html#insert)."
                );
            });
          });
        }
        if (insertData.values.length === 1) {
          const parameters = this.client.parameterize(
            insertData.values[0],
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          );
          sql += ` values (${parameters})`;
          const { onConflict: onConflict2, ignore: ignore2, merge: merge2 } = this.single;
          if (onConflict2 && ignore2) sql += this._ignore(onConflict2);
          else if (onConflict2 && merge2) {
            sql += this._merge(merge2.updates, onConflict2, insertValues);
            const wheres = this.where();
            if (wheres) sql += ` ${wheres}`;
          }
          const { returning: returning2 } = this.single;
          if (returning2) {
            sql += this._returning(returning2);
          }
          return {
            sql,
            returning: returning2
          };
        }
        const blocks = [];
        let i3 = -1;
        while (++i3 < insertData.values.length) {
          let i22 = -1;
          const block = blocks[i3] = [];
          let current = insertData.values[i3];
          current = current === void 0 ? this.client.valueForUndefined : current;
          while (++i22 < insertData.columns.length) {
            block.push(
              this.client.alias(
                this.client.parameter(
                  current[i22],
                  this.builder,
                  this.bindingsHolder
                ),
                this.formatter.wrap(insertData.columns[i22])
              )
            );
          }
          blocks[i3] = block.join(", ");
        }
        sql += " select " + blocks.join(" union all select ");
        const { onConflict, ignore, merge } = this.single;
        if (onConflict && ignore) sql += " where true" + this._ignore(onConflict);
        else if (onConflict && merge) {
          sql += " where true" + this._merge(merge.updates, onConflict, insertValues);
        }
        const { returning } = this.single;
        if (returning) sql += this._returning(returning);
        return {
          sql,
          returning
        };
      }
      // Compiles an `update` query, allowing for a return value.
      update() {
        const withSQL = this.with();
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        const { returning } = this.single;
        return {
          sql: withSQL + `update ${this.single.only ? "only " : ""}${this.tableName} set ${updateData.join(", ")}` + (wheres ? ` ${wheres}` : "") + this._returning(returning),
          returning
        };
      }
      _ignore(columns) {
        if (columns === true) {
          return " on conflict do nothing";
        }
        return ` on conflict ${this._onConflictClause(columns)} do nothing`;
      }
      _merge(updates, columns, insert) {
        let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;
        if (updates && Array.isArray(updates)) {
          sql += updates.map(
            (column) => wrapString(
              column.split(".").pop(),
              this.formatter.builder,
              this.client,
              this.formatter
            )
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql;
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          if (typeof updateData === "string") {
            sql += updateData;
          } else {
            sql += updateData.join(",");
          }
          return sql;
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          sql += insertData.columns.map(
            (column) => wrapString(column.split(".").pop(), this.builder, this.client)
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql;
        }
      }
      _returning(value) {
        return value ? ` returning ${this.formatter.columnize(value)}` : "";
      }
      // Compile a truncate table statement into SQL.
      truncate() {
        const { table } = this.single;
        return {
          sql: `delete from ${this.tableName}`,
          output() {
            return this.query({
              sql: `delete from sqlite_sequence where name = '${table}'`
            }).catch(noop);
          }
        };
      }
      // Compiles a `columnInfo` query
      columnInfo() {
        const column = this.single.columnInfo;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        return {
          sql: `PRAGMA table_info(\`${table}\`)`,
          output(resp) {
            const maxLengthRegex = /.*\((\d+)\)/;
            const out = reduce(
              resp,
              function(columns, val2) {
                let { type } = val2;
                let maxLength = type.match(maxLengthRegex);
                if (maxLength) {
                  maxLength = maxLength[1];
                }
                type = maxLength ? type.split("(")[0] : type;
                columns[val2.name] = {
                  type: type.toLowerCase(),
                  maxLength,
                  nullable: !val2.notnull,
                  defaultValue: val2.dflt_value
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit && !this.single.offset) return "";
        this.single.limit = noLimit ? -1 : this.single.limit;
        return `limit ${this._getValueOrParameterFromAttribute("limit")}`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract("json_extract", params);
      }
      jsonSet(params) {
        return this._jsonSet("json_set", params);
      }
      jsonInsert(params) {
        return this._jsonSet("json_insert", params);
      }
      jsonRemove(params) {
        const jsonCol = `json_remove(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_extract", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by SQLite"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error(
          "Json subset where clause not actually supported by SQLite"
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract", clause);
      }
    };
    module.exports = QueryCompiler_SQLite3;
  }
});

// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/lodash/_baseSome.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module.exports = baseSome;
  }
});

// node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/lodash/some.js"(exports, module) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = some;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js
var require_sqlite_compiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js"(exports, module) {
    var SchemaCompiler = require_compiler();
    var some = require_some();
    var SchemaCompiler_SQLite3 = class extends SchemaCompiler {
      constructor(client, builder) {
        super(client, builder);
      }
      // Compile the query to determine if a table exists.
      hasTable(tableName) {
        const sql = `select * from sqlite_master where type = 'table' and name = ${this.client.parameter(
          this.formatter.wrap(tableName).replace(/`/g, ""),
          this.builder,
          this.bindingsHolder
        )}`;
        this.pushQuery({ sql, output: (resp) => resp.length > 0 });
      }
      // Compile the query to determine if a column exists.
      hasColumn(tableName, column) {
        this.pushQuery({
          sql: `PRAGMA table_info(${this.formatter.wrap(tableName)})`,
          output(resp) {
            return some(resp, (col) => {
              return this.client.wrapIdentifier(col.name.toLowerCase()) === this.client.wrapIdentifier(column.toLowerCase());
            });
          }
        });
      }
      // Compile a rename table command.
      renameTable(from, to) {
        this.pushQuery(
          `alter table ${this.formatter.wrap(from)} rename to ${this.formatter.wrap(
            to
          )}`
        );
      }
      async generateDdlCommands() {
        const sequence = this.builder._sequence;
        for (let i3 = 0, l3 = sequence.length; i3 < l3; i3++) {
          const query = sequence[i3];
          this[query.method].apply(this, query.args);
        }
        const commandSources = this.sequence;
        if (commandSources.length === 1 && commandSources[0].statementsProducer) {
          return commandSources[0].statementsProducer();
        } else {
          const result = [];
          for (const commandSource of commandSources) {
            const command = commandSource.sql;
            if (Array.isArray(command)) {
              result.push(...command);
            } else {
              result.push(command);
            }
          }
          return { pre: [], sql: result, check: null, post: [] };
        }
      }
    };
    module.exports = SchemaCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js
var require_sqlite_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js"(exports, module) {
    var ColumnCompiler = require_columncompiler();
    var ColumnCompiler_SQLite3 = class extends ColumnCompiler {
      constructor() {
        super(...arguments);
        this.modifiers = ["nullable", "defaultTo"];
        this._addCheckModifiers();
      }
      // Types
      // -------
      enu(allowed) {
        return `text check (${this.formatter.wrap(
          this.args[0]
        )} in ('${allowed.join("', '")}'))`;
      }
      _pushAlterCheckQuery(checkPredicate, constraintName) {
        throw new Error(
          `Alter table with to add constraints is not permitted in SQLite`
        );
      }
      checkRegex(regexes, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} REGEXP ${this.client._escapeBinding(regexes)}`,
          constraintName
        );
      }
    };
    ColumnCompiler_SQLite3.prototype.json = "json";
    ColumnCompiler_SQLite3.prototype.jsonb = "json";
    ColumnCompiler_SQLite3.prototype.double = ColumnCompiler_SQLite3.prototype.decimal = ColumnCompiler_SQLite3.prototype.floating = "float";
    ColumnCompiler_SQLite3.prototype.timestamp = "datetime";
    ColumnCompiler_SQLite3.prototype.increments = ColumnCompiler_SQLite3.prototype.bigincrements = "integer not null primary key autoincrement";
    module.exports = ColumnCompiler_SQLite3;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = filter;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js
var require_sqlite_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js"(exports, module) {
    var filter = require_filter();
    var values = require_values();
    var identity = require_identity();
    var { isObject } = require_is();
    var TableCompiler = require_tablecompiler();
    var { formatDefault } = require_formatterUtils();
    var TableCompiler_SQLite3 = class extends TableCompiler {
      constructor() {
        super(...arguments);
      }
      // Create a new table.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        let sql = createStatement + this.tableName();
        if (like && this.tableNameLike()) {
          sql += " as select * from " + this.tableNameLike() + " where 0=1";
        } else {
          sql += " (" + columns.sql.join(", ");
          sql += this.foreignKeys() || "";
          sql += this.primaryKeys() || "";
          sql += this._addChecks();
          sql += ")";
        }
        this.pushQuery(sql);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          const compiler = this;
          const columnsInfo = colCompilers.map((col) => {
            const name = this.client.customWrapIdentifier(
              col.getColumnName(),
              identity,
              col.columnBuilder.queryContext()
            );
            const type = col.getColumnType();
            const defaultTo = col.modified["defaultTo"] ? formatDefault(col.modified["defaultTo"][0], col.type, this.client) : null;
            const notNull = col.modified["nullable"] && col.modified["nullable"][0] === false;
            return { name, type, defaultTo, notNull };
          });
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            statementsProducer(pragma, connection) {
              return compiler.client.ddl(compiler, pragma, connection).alterColumn(columnsInfo);
            }
          });
        } else {
          for (let i3 = 0, l3 = columns.sql.length; i3 < l3; i3++) {
            this.pushQuery({
              sql: `alter table ${this.tableName()} add column ${columns.sql[i3]}`,
              bindings: columns.bindings[i3]
            });
          }
        }
      }
      // Compile a drop unique key command.
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        const compiler = this;
        columns = Array.isArray(columns) ? columns : [columns];
        columns = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        indexName = this.client.customWrapIdentifier(indexName, identity);
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropForeign(columns, indexName);
          }
        });
      }
      // Compile a drop primary key command.
      dropPrimary(constraintName) {
        const compiler = this;
        constraintName = this.client.customWrapIdentifier(constraintName, identity);
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropPrimary(constraintName);
          }
        });
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      // Compile a unique key command.
      unique(columns, indexName) {
        let deferrable;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, predicate } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `sqlite3: unique index \`${indexName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
          );
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        columns = this.formatter.columnize(columns);
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create unique index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
        );
      }
      // Compile a plain index key command.
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        columns = this.formatter.columnize(columns);
        let predicate;
        if (isObject(options)) {
          ({ predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
        );
      }
      /**
       * Add a primary key to an existing table.
       *
       * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table
       *       creation in this method
       *
       * @param {string | string[]} columns - Column name(s) to assign as primary keys
       * @param {string} [constraintName] - Custom name for the PK constraint
       */
      primary(columns, constraintName) {
        const compiler = this;
        columns = Array.isArray(columns) ? columns : [columns];
        columns = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `sqlite3: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
          );
        }
        constraintName = this.client.customWrapIdentifier(constraintName, identity);
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            output(pragma) {
              return compiler.client.ddl(compiler, pragma, this.connection).primary(columns, constraintName);
            }
          });
        }
      }
      /**
       * Add a foreign key constraint to an existing table
       *
       * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do
       *       anything regarding table creation in this method
       *
       * @param {object} foreignInfo - Information about the current column foreign setup
       * @param {string | string[]} [foreignInfo.column] - Column in the current constraint
       * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint
       * @param {string | string[]} foreignInfo.references - What column it references in the other table
       * @param {string} foreignInfo.inTable - What table is referenced in this constraint
       * @param {string} [foreignInfo.onUpdate] - What to do on updates
       * @param {string} [foreignInfo.onDelete] - What to do on deletions
       */
      foreign(foreignInfo) {
        const compiler = this;
        if (this.method !== "create" && this.method !== "createIfNot") {
          foreignInfo.column = Array.isArray(foreignInfo.column) ? foreignInfo.column : [foreignInfo.column];
          foreignInfo.column = foreignInfo.column.map(
            (column) => this.client.customWrapIdentifier(column, identity)
          );
          foreignInfo.inTable = this.client.customWrapIdentifier(
            foreignInfo.inTable,
            identity
          );
          foreignInfo.references = Array.isArray(foreignInfo.references) ? foreignInfo.references : [foreignInfo.references];
          foreignInfo.references = foreignInfo.references.map(
            (column) => this.client.customWrapIdentifier(column, identity)
          );
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            statementsProducer(pragma, connection) {
              return compiler.client.ddl(compiler, pragma, connection).foreign(foreignInfo);
            }
          });
        }
      }
      primaryKeys() {
        const pks = filter(this.grouped.alterTable || [], { method: "primary" });
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          const needUniqueCols = this.grouped.columns.filter((t3) => t3.builder._type === "increments").length > 0;
          return `,${constraintName} ${needUniqueCols ? "unique" : "primary key"} (${this.formatter.columnize(columns)})`;
        }
      }
      foreignKeys() {
        let sql = "";
        const foreignKeys = filter(this.grouped.alterTable || [], {
          method: "foreign"
        });
        for (let i3 = 0, l3 = foreignKeys.length; i3 < l3; i3++) {
          const foreign = foreignKeys[i3].args[0];
          const column = this.formatter.columnize(foreign.column);
          const references = this.formatter.columnize(foreign.references);
          const foreignTable = this.formatter.wrap(foreign.inTable);
          let constraintName = foreign.keyName || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;
          if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;
          if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;
        }
        return sql;
      }
      createTableBlock() {
        return this.getColumns().concat().join(",");
      }
      renameColumn(from, to) {
        this.pushQuery({
          sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      _setNullableState(column, isNullable) {
        const compiler = this;
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          statementsProducer(pragma, connection) {
            return compiler.client.ddl(compiler, pragma, connection).setNullable(column, isNullable);
          }
        });
      }
      dropColumn() {
        const compiler = this;
        const columns = values(arguments);
        const columnsWrapped = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(columnsWrapped);
          }
        });
      }
    };
    module.exports = TableCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js
var require_sqlite_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js"(exports, module) {
    var ViewCompiler = require_viewcompiler();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var ViewCompiler_SQLite3 = class extends ViewCompiler {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        const columns = this.columns;
        const selectQuery = this.selectQuery.toString();
        const viewName = this.viewName();
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        const dropSql = `drop view if exists ${viewName}`;
        const createSql = `create view ${viewName}${columnList} as ${selectQuery}`;
        this.pushQuery({
          sql: dropSql
        });
        this.pushQuery({
          sql: createSql
        });
      }
    };
    module.exports = ViewCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js
var require_sqlite_ddl_operations = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js"(exports, module) {
    function copyData(sourceTable, targetTable, columns) {
      return `INSERT INTO "${targetTable}" SELECT ${columns === void 0 ? "*" : columns.map((column) => `"${column}"`).join(", ")} FROM "${sourceTable}";`;
    }
    function dropOriginal(tableName) {
      return `DROP TABLE "${tableName}"`;
    }
    function renameTable(tableName, alteredName) {
      return `ALTER TABLE "${tableName}" RENAME TO "${alteredName}"`;
    }
    function getTableSql(tableName) {
      return `SELECT type, sql FROM sqlite_master WHERE (type='table' OR (type='index' AND sql IS NOT NULL)) AND lower(tbl_name)='${tableName.toLowerCase()}'`;
    }
    function isForeignCheckEnabled() {
      return `PRAGMA foreign_keys`;
    }
    function setForeignCheck(enable) {
      return `PRAGMA foreign_keys = ${enable ? "ON" : "OFF"}`;
    }
    function executeForeignCheck() {
      return `PRAGMA foreign_key_check`;
    }
    module.exports = {
      copyData,
      dropOriginal,
      renameTable,
      getTableSql,
      isForeignCheckEnabled,
      setForeignCheck,
      executeForeignCheck
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js"(exports, module) {
    function tokenize(text, tokens) {
      const compiledRegex = new RegExp(
        Object.entries(tokens).map(([type, regex]) => `(?<${type}>${regex.source})`).join("|"),
        "yi"
      );
      let index = 0;
      const ast = [];
      while (index < text.length) {
        compiledRegex.lastIndex = index;
        const result = text.match(compiledRegex);
        if (result !== null) {
          const [type, text2] = Object.entries(result.groups).find(
            ([name, group]) => group !== void 0
          );
          index += text2.length;
          if (!type.startsWith("_")) {
            ast.push({ type, text: text2 });
          }
        } else {
          throw new Error(
            `No matching tokenizer rule found at: [${text.substring(index)}]`
          );
        }
      }
      return ast;
    }
    module.exports = {
      tokenize
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js
var require_parser_combinator = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js"(exports, module) {
    function s3(sequence, post = (v6) => v6) {
      return function({ index = 0, input }) {
        let position = index;
        const ast = [];
        for (const parser of sequence) {
          const result = parser({ index: position, input });
          if (result.success) {
            position = result.index;
            ast.push(result.ast);
          } else {
            return result;
          }
        }
        return { success: true, ast: post(ast), index: position, input };
      };
    }
    function a3(alternative, post = (v6) => v6) {
      return function({ index = 0, input }) {
        for (const parser of alternative) {
          const result = parser({ index, input });
          if (result.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    function m3(many, post = (v6) => v6) {
      return function({ index = 0, input }) {
        let result = {};
        let position = index;
        const ast = [];
        do {
          result = many({ index: position, input });
          if (result.success) {
            position = result.index;
            ast.push(result.ast);
          }
        } while (result.success);
        if (ast.length > 0) {
          return { success: true, ast: post(ast), index: position, input };
        } else {
          return { success: false, ast: null, index: position, input };
        }
      };
    }
    function o3(optional, post = (v6) => v6) {
      return function({ index = 0, input }) {
        const result = optional({ index, input });
        if (result.success) {
          return {
            success: true,
            ast: post(result.ast),
            index: result.index,
            input
          };
        } else {
          return { success: true, ast: post(null), index, input };
        }
      };
    }
    function l3(lookahead, post = (v6) => v6) {
      return function({ index = 0, input }) {
        const result = lookahead.do({ index, input });
        if (result.success) {
          const resultNext = lookahead.next({ index: result.index, input });
          if (resultNext.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    function n3(negative, post = (v6) => v6) {
      return function({ index = 0, input }) {
        const result = negative.do({ index, input });
        if (result.success) {
          const resultNot = negative.not({ index, input });
          if (!resultNot.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    function t3(token, post = (v6) => v6.text) {
      return function({ index = 0, input }) {
        const result = input[index];
        if (result !== void 0 && (token.type === void 0 || token.type === result.type) && (token.text === void 0 || token.text.toUpperCase() === result.text.toUpperCase())) {
          return {
            success: true,
            ast: post(result),
            index: index + 1,
            input
          };
        } else {
          return { success: false, ast: null, index, input };
        }
      };
    }
    var e3 = function({ index = 0, input }) {
      return { success: true, ast: null, index, input };
    };
    var f3 = function({ index = 0, input }) {
      return { success: index === input.length, ast: null, index, input };
    };
    module.exports = { s: s3, a: a3, m: m3, o: o3, l: l3, n: n3, t: t3, e: e3, f: f3 };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js
var require_parser = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js"(exports, module) {
    var { tokenize } = require_tokenizer();
    var { s: s3, a: a3, m: m3, o: o3, l: l3, n: n3, t: t3, e: e3, f: f3 } = require_parser_combinator();
    var TOKENS = {
      keyword: /(?:ABORT|ACTION|ADD|AFTER|ALL|ALTER|ALWAYS|ANALYZE|AND|AS|ASC|ATTACH|AUTOINCREMENT|BEFORE|BEGIN|BETWEEN|BY|CASCADE|CASE|CAST|CHECK|COLLATE|COLUMN|COMMIT|CONFLICT|CONSTRAINT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|DATABASE|DEFAULT|DEFERRED|DEFERRABLE|DELETE|DESC|DETACH|DISTINCT|DO|DROP|END|EACH|ELSE|ESCAPE|EXCEPT|EXCLUSIVE|EXCLUDE|EXISTS|EXPLAIN|FAIL|FILTER|FIRST|FOLLOWING|FOR|FOREIGN|FROM|FULL|GENERATED|GLOB|GROUP|GROUPS|HAVING|IF|IGNORE|IMMEDIATE|IN|INDEX|INDEXED|INITIALLY|INNER|INSERT|INSTEAD|INTERSECT|INTO|IS|ISNULL|JOIN|KEY|LAST|LEFT|LIKE|LIMIT|MATCH|MATERIALIZED|NATURAL|NO|NOT|NOTHING|NOTNULL|NULL|NULLS|OF|OFFSET|ON|OR|ORDER|OTHERS|OUTER|OVER|PARTITION|PLAN|PRAGMA|PRECEDING|PRIMARY|QUERY|RAISE|RANGE|RECURSIVE|REFERENCES|REGEXP|REINDEX|RELEASE|RENAME|REPLACE|RESTRICT|RETURNING|RIGHT|ROLLBACK|ROW|ROWS|SAVEPOINT|SELECT|SET|TABLE|TEMP|TEMPORARY|THEN|TIES|TO|TRANSACTION|TRIGGER|UNBOUNDED|UNION|UNIQUE|UPDATE|USING|VACUUM|VALUES|VIEW|VIRTUAL|WHEN|WHERE|WINDOW|WITH|WITHOUT)(?=\s+|-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\.)/,
      id: /"[^"]*(?:""[^"]*)*"|`[^`]*(?:``[^`]*)*`|\[[^[\]]*\]|[a-z_][a-z0-9_$]*/,
      string: /'[^']*(?:''[^']*)*'/,
      blob: /x'(?:[0-9a-f][0-9a-f])+'/,
      numeric: /(?:\d+(?:\.\d*)?|\.\d+)(?:e(?:\+|-)?\d+)?|0x[0-9a-f]+/,
      variable: /\?\d*|[@$:][a-z0-9_$]+/,
      operator: /-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\./,
      _ws: /\s+/
    };
    function parseCreateTable(sql) {
      const result = createTable({ input: tokenize(sql, TOKENS) });
      if (!result.success) {
        throw new Error(
          `Parsing CREATE TABLE failed at [${result.input.slice(result.index).map((t4) => t4.text).join(" ")}] of "${sql}"`
        );
      }
      return result.ast;
    }
    function parseCreateIndex(sql) {
      const result = createIndex({ input: tokenize(sql, TOKENS) });
      if (!result.success) {
        throw new Error(
          `Parsing CREATE INDEX failed at [${result.input.slice(result.index).map((t4) => t4.text).join(" ")}] of "${sql}"`
        );
      }
      return result.ast;
    }
    function createTable(ctx) {
      return s3(
        [
          t3({ text: "CREATE" }, (v6) => null),
          temporary,
          t3({ text: "TABLE" }, (v6) => null),
          exists,
          schema,
          table,
          t3({ text: "(" }, (v6) => null),
          columnDefinitionList,
          tableConstraintList,
          t3({ text: ")" }, (v6) => null),
          rowid,
          f3
        ],
        (v6) => Object.assign({}, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function temporary(ctx) {
      return a3([t3({ text: "TEMP" }), t3({ text: "TEMPORARY" }), e3], (v6) => ({
        temporary: v6 !== null
      }))(ctx);
    }
    function rowid(ctx) {
      return o3(s3([t3({ text: "WITHOUT" }), t3({ text: "ROWID" })]), (v6) => ({
        rowid: v6 !== null
      }))(ctx);
    }
    function columnDefinitionList(ctx) {
      return a3([
        s3([columnDefinition, t3({ text: "," }), columnDefinitionList], (v6) => ({
          columns: [v6[0]].concat(v6[2].columns)
        })),
        s3([columnDefinition], (v6) => ({ columns: [v6[0]] }))
      ])(ctx);
    }
    function columnDefinition(ctx) {
      return s3(
        [s3([identifier], (v6) => ({ name: v6[0] })), typeName, columnConstraintList],
        (v6) => Object.assign({}, ...v6)
      )(ctx);
    }
    function typeName(ctx) {
      return o3(
        s3(
          [
            m3(t3({ type: "id" })),
            a3([
              s3(
                [
                  t3({ text: "(" }),
                  signedNumber,
                  t3({ text: "," }),
                  signedNumber,
                  t3({ text: ")" })
                ],
                (v6) => `(${v6[1]}, ${v6[3]})`
              ),
              s3(
                [t3({ text: "(" }), signedNumber, t3({ text: ")" })],
                (v6) => `(${v6[1]})`
              ),
              e3
            ])
          ],
          (v6) => `${v6[0].join(" ")}${v6[1] || ""}`
        ),
        (v6) => ({ type: v6 })
      )(ctx);
    }
    function columnConstraintList(ctx) {
      return o3(m3(columnConstraint), (v6) => ({
        constraints: Object.assign(
          {
            primary: null,
            notnull: null,
            null: null,
            unique: null,
            check: null,
            default: null,
            collate: null,
            references: null,
            as: null
          },
          ...v6 || []
        )
      }))(ctx);
    }
    function columnConstraint(ctx) {
      return a3([
        primaryColumnConstraint,
        notnullColumnConstraint,
        nullColumnConstraint,
        uniqueColumnConstraint,
        checkColumnConstraint,
        defaultColumnConstraint,
        collateColumnConstraint,
        referencesColumnConstraint,
        asColumnConstraint
      ])(ctx);
    }
    function primaryColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "PRIMARY" }, (v6) => null),
          t3({ text: "KEY" }, (v6) => null),
          order,
          conflictClause,
          autoincrement
        ],
        (v6) => ({ primary: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function autoincrement(ctx) {
      return o3(t3({ text: "AUTOINCREMENT" }), (v6) => ({
        autoincrement: v6 !== null
      }))(ctx);
    }
    function notnullColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "NOT" }, (v6) => null),
          t3({ text: "NULL" }, (v6) => null),
          conflictClause
        ],
        (v6) => ({ notnull: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function nullColumnConstraint(ctx) {
      return s3(
        [constraintName, t3({ text: "NULL" }, (v6) => null), conflictClause],
        (v6) => ({ null: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function uniqueColumnConstraint(ctx) {
      return s3(
        [constraintName, t3({ text: "UNIQUE" }, (v6) => null), conflictClause],
        (v6) => ({ unique: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function checkColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "CHECK" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          s3([expression], (v6) => ({ expression: v6[0] })),
          t3({ text: ")" }, (v6) => null)
        ],
        (v6) => ({ check: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function defaultColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "DEFAULT" }, (v6) => null),
          a3([
            s3([t3({ text: "(" }), expression, t3({ text: ")" })], (v6) => ({
              value: v6[1],
              expression: true
            })),
            s3([literalValue], (v6) => ({ value: v6[0], expression: false })),
            s3([signedNumber], (v6) => ({ value: v6[0], expression: false }))
          ])
        ],
        (v6) => ({ default: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function collateColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "COLLATE" }, (v6) => null),
          t3({ type: "id" }, (v6) => ({ collation: v6.text }))
        ],
        (v6) => ({ collate: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function referencesColumnConstraint(ctx) {
      return s3(
        [constraintName, s3([foreignKeyClause], (v6) => v6[0].references)],
        (v6) => ({
          references: Object.assign({}, ...v6.filter((x3) => x3 !== null))
        })
      )(ctx);
    }
    function asColumnConstraint(ctx) {
      return s3(
        [
          constraintName,
          o3(s3([t3({ text: "GENERATED" }), t3({ text: "ALWAYS" })]), (v6) => ({
            generated: v6 !== null
          })),
          t3({ text: "AS" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          s3([expression], (v6) => ({ expression: v6[0] })),
          t3({ text: ")" }, (v6) => null),
          a3([t3({ text: "STORED" }), t3({ text: "VIRTUAL" }), e3], (v6) => ({
            mode: v6 ? v6.toUpperCase() : null
          }))
        ],
        (v6) => ({ as: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function tableConstraintList(ctx) {
      return o3(m3(s3([t3({ text: "," }), tableConstraint], (v6) => v6[1])), (v6) => ({
        constraints: v6 || []
      }))(ctx);
    }
    function tableConstraint(ctx) {
      return a3([
        primaryTableConstraint,
        uniqueTableConstraint,
        checkTableConstraint,
        foreignTableConstraint
      ])(ctx);
    }
    function primaryTableConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "PRIMARY" }, (v6) => null),
          t3({ text: "KEY" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          indexedColumnList,
          t3({ text: ")" }, (v6) => null),
          conflictClause
        ],
        (v6) => Object.assign({ type: "PRIMARY KEY" }, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function uniqueTableConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "UNIQUE" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          indexedColumnList,
          t3({ text: ")" }, (v6) => null),
          conflictClause
        ],
        (v6) => Object.assign({ type: "UNIQUE" }, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function conflictClause(ctx) {
      return o3(
        s3(
          [
            t3({ text: "ON" }),
            t3({ text: "CONFLICT" }),
            a3([
              t3({ text: "ROLLBACK" }),
              t3({ text: "ABORT" }),
              t3({ text: "FAIL" }),
              t3({ text: "IGNORE" }),
              t3({ text: "REPLACE" })
            ])
          ],
          (v6) => v6[2]
        ),
        (v6) => ({ conflict: v6 ? v6.toUpperCase() : null })
      )(ctx);
    }
    function checkTableConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "CHECK" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          s3([expression], (v6) => ({ expression: v6[0] })),
          t3({ text: ")" }, (v6) => null)
        ],
        (v6) => Object.assign({ type: "CHECK" }, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function foreignTableConstraint(ctx) {
      return s3(
        [
          constraintName,
          t3({ text: "FOREIGN" }, (v6) => null),
          t3({ text: "KEY" }, (v6) => null),
          t3({ text: "(" }, (v6) => null),
          columnNameList,
          t3({ text: ")" }, (v6) => null),
          foreignKeyClause
        ],
        (v6) => Object.assign({ type: "FOREIGN KEY" }, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function foreignKeyClause(ctx) {
      return s3(
        [
          t3({ text: "REFERENCES" }, (v6) => null),
          table,
          columnNameListOptional,
          o3(
            m3(a3([deleteReference, updateReference, matchReference])),
            (v6) => Object.assign({ delete: null, update: null, match: null }, ...v6 || [])
          ),
          deferrable
        ],
        (v6) => ({ references: Object.assign({}, ...v6.filter((x3) => x3 !== null)) })
      )(ctx);
    }
    function columnNameListOptional(ctx) {
      return o3(
        s3([t3({ text: "(" }), columnNameList, t3({ text: ")" })], (v6) => v6[1]),
        (v6) => ({ columns: v6 ? v6.columns : [] })
      )(ctx);
    }
    function columnNameList(ctx) {
      return s3(
        [
          o3(
            m3(s3([identifier, t3({ text: "," })], (v6) => v6[0])),
            (v6) => v6 !== null ? v6 : []
          ),
          identifier
        ],
        (v6) => ({ columns: v6[0].concat([v6[1]]) })
      )(ctx);
    }
    function deleteReference(ctx) {
      return s3([t3({ text: "ON" }), t3({ text: "DELETE" }), onAction], (v6) => ({
        delete: v6[2]
      }))(ctx);
    }
    function updateReference(ctx) {
      return s3([t3({ text: "ON" }), t3({ text: "UPDATE" }), onAction], (v6) => ({
        update: v6[2]
      }))(ctx);
    }
    function matchReference(ctx) {
      return s3(
        [t3({ text: "MATCH" }), a3([t3({ type: "keyword" }), t3({ type: "id" })])],
        (v6) => ({ match: v6[1] })
      )(ctx);
    }
    function deferrable(ctx) {
      return o3(
        s3([
          o3(t3({ text: "NOT" })),
          t3({ text: "DEFERRABLE" }),
          o3(
            s3(
              [
                t3({ text: "INITIALLY" }),
                a3([t3({ text: "DEFERRED" }), t3({ text: "IMMEDIATE" })])
              ],
              (v6) => v6[1].toUpperCase()
            )
          )
        ]),
        (v6) => ({ deferrable: v6 ? { not: v6[0] !== null, initially: v6[2] } : null })
      )(ctx);
    }
    function constraintName(ctx) {
      return o3(
        s3([t3({ text: "CONSTRAINT" }), identifier], (v6) => v6[1]),
        (v6) => ({ name: v6 })
      )(ctx);
    }
    function createIndex(ctx) {
      return s3(
        [
          t3({ text: "CREATE" }, (v6) => null),
          unique,
          t3({ text: "INDEX" }, (v6) => null),
          exists,
          schema,
          index,
          t3({ text: "ON" }, (v6) => null),
          table,
          t3({ text: "(" }, (v6) => null),
          indexedColumnList,
          t3({ text: ")" }, (v6) => null),
          where,
          f3
        ],
        (v6) => Object.assign({}, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function unique(ctx) {
      return o3(t3({ text: "UNIQUE" }), (v6) => ({ unique: v6 !== null }))(ctx);
    }
    function exists(ctx) {
      return o3(
        s3([t3({ text: "IF" }), t3({ text: "NOT" }), t3({ text: "EXISTS" })]),
        (v6) => ({ exists: v6 !== null })
      )(ctx);
    }
    function schema(ctx) {
      return o3(
        s3([identifier, t3({ text: "." })], (v6) => v6[0]),
        (v6) => ({ schema: v6 })
      )(ctx);
    }
    function index(ctx) {
      return s3([identifier], (v6) => ({ index: v6[0] }))(ctx);
    }
    function table(ctx) {
      return s3([identifier], (v6) => ({ table: v6[0] }))(ctx);
    }
    function where(ctx) {
      return o3(
        s3([t3({ text: "WHERE" }), expression], (v6) => v6[1]),
        (v6) => ({ where: v6 })
      )(ctx);
    }
    function indexedColumnList(ctx) {
      return a3([
        s3([indexedColumn, t3({ text: "," }), indexedColumnList], (v6) => ({
          columns: [v6[0]].concat(v6[2].columns)
        })),
        s3([indexedColumnExpression, t3({ text: "," }), indexedColumnList], (v6) => ({
          columns: [v6[0]].concat(v6[2].columns)
        })),
        l3({ do: indexedColumn, next: t3({ text: ")" }) }, (v6) => ({
          columns: [v6]
        })),
        l3({ do: indexedColumnExpression, next: t3({ text: ")" }) }, (v6) => ({
          columns: [v6]
        }))
      ])(ctx);
    }
    function indexedColumn(ctx) {
      return s3(
        [
          s3([identifier], (v6) => ({ name: v6[0], expression: false })),
          collation,
          order
        ],
        (v6) => Object.assign({}, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function indexedColumnExpression(ctx) {
      return s3(
        [
          s3([indexedExpression], (v6) => ({ name: v6[0], expression: true })),
          collation,
          order
        ],
        (v6) => Object.assign({}, ...v6.filter((x3) => x3 !== null))
      )(ctx);
    }
    function collation(ctx) {
      return o3(
        s3([t3({ text: "COLLATE" }), t3({ type: "id" })], (v6) => v6[1]),
        (v6) => ({ collation: v6 })
      )(ctx);
    }
    function order(ctx) {
      return a3([t3({ text: "ASC" }), t3({ text: "DESC" }), e3], (v6) => ({
        order: v6 ? v6.toUpperCase() : null
      }))(ctx);
    }
    function indexedExpression(ctx) {
      return m3(
        a3([
          n3({
            do: t3({ type: "keyword" }),
            not: a3([
              t3({ text: "COLLATE" }),
              t3({ text: "ASC" }),
              t3({ text: "DESC" })
            ])
          }),
          t3({ type: "id" }),
          t3({ type: "string" }),
          t3({ type: "blob" }),
          t3({ type: "numeric" }),
          t3({ type: "variable" }),
          n3({
            do: t3({ type: "operator" }),
            not: a3([t3({ text: "(" }), t3({ text: ")" }), t3({ text: "," })])
          }),
          s3([t3({ text: "(" }), o3(expression), t3({ text: ")" })], (v6) => v6[1] || [])
        ])
      )(ctx);
    }
    function expression(ctx) {
      return m3(
        a3([
          t3({ type: "keyword" }),
          t3({ type: "id" }),
          t3({ type: "string" }),
          t3({ type: "blob" }),
          t3({ type: "numeric" }),
          t3({ type: "variable" }),
          n3({
            do: t3({ type: "operator" }),
            not: a3([t3({ text: "(" }), t3({ text: ")" })])
          }),
          s3([t3({ text: "(" }), o3(expression), t3({ text: ")" })], (v6) => v6[1] || [])
        ])
      )(ctx);
    }
    function identifier(ctx) {
      return a3(
        [t3({ type: "id" }), t3({ type: "string" })],
        (v6) => /^["`['][^]*["`\]']$/.test(v6) ? v6.substring(1, v6.length - 1) : v6
      )(ctx);
    }
    function onAction(ctx) {
      return a3(
        [
          s3([t3({ text: "SET" }), t3({ text: "NULL" })], (v6) => `${v6[0]} ${v6[1]}`),
          s3([t3({ text: "SET" }), t3({ text: "DEFAULT" })], (v6) => `${v6[0]} ${v6[1]}`),
          t3({ text: "CASCADE" }),
          t3({ text: "RESTRICT" }),
          s3([t3({ text: "NO" }), t3({ text: "ACTION" })], (v6) => `${v6[0]} ${v6[1]}`)
        ],
        (v6) => v6.toUpperCase()
      )(ctx);
    }
    function literalValue(ctx) {
      return a3([
        t3({ type: "numeric" }),
        t3({ type: "string" }),
        t3({ type: "id" }),
        t3({ type: "blob" }),
        t3({ text: "NULL" }),
        t3({ text: "TRUE" }),
        t3({ text: "FALSE" }),
        t3({ text: "CURRENT_TIME" }),
        t3({ text: "CURRENT_DATE" }),
        t3({ text: "CURRENT_TIMESTAMP" })
      ])(ctx);
    }
    function signedNumber(ctx) {
      return s3(
        [a3([t3({ text: "+" }), t3({ text: "-" }), e3]), t3({ type: "numeric" })],
        (v6) => `${v6[0] || ""}${v6[1]}`
      )(ctx);
    }
    module.exports = {
      parseCreateTable,
      parseCreateIndex
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js
var require_compiler2 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js"(exports, module) {
    function compileCreateTable(ast, wrap = (v6) => v6) {
      return createTable(ast, wrap);
    }
    function compileCreateIndex(ast, wrap = (v6) => v6) {
      return createIndex(ast, wrap);
    }
    function createTable(ast, wrap) {
      return `CREATE${temporary(ast, wrap)} TABLE${exists(ast, wrap)} ${schema(
        ast,
        wrap
      )}${table(ast, wrap)} (${columnDefinitionList(
        ast,
        wrap
      )}${tableConstraintList(ast, wrap)})${rowid(ast, wrap)}`;
    }
    function temporary(ast, wrap) {
      return ast.temporary ? " TEMP" : "";
    }
    function rowid(ast, wrap) {
      return ast.rowid ? " WITHOUT ROWID" : "";
    }
    function columnDefinitionList(ast, wrap) {
      return ast.columns.map((column) => columnDefinition(column, wrap)).join(", ");
    }
    function columnDefinition(ast, wrap) {
      return `${identifier(ast.name, wrap)}${typeName(
        ast,
        wrap
      )}${columnConstraintList(ast.constraints, wrap)}`;
    }
    function typeName(ast, wrap) {
      return ast.type !== null ? ` ${ast.type}` : "";
    }
    function columnConstraintList(ast, wrap) {
      return `${primaryColumnConstraint(ast, wrap)}${notnullColumnConstraint(
        ast,
        wrap
      )}${nullColumnConstraint(ast, wrap)}${uniqueColumnConstraint(
        ast,
        wrap
      )}${checkColumnConstraint(ast, wrap)}${defaultColumnConstraint(
        ast,
        wrap
      )}${collateColumnConstraint(ast, wrap)}${referencesColumnConstraint(
        ast,
        wrap
      )}${asColumnConstraint(ast, wrap)}`;
    }
    function primaryColumnConstraint(ast, wrap) {
      return ast.primary !== null ? ` ${constraintName(ast.primary, wrap)}PRIMARY KEY${order(
        ast.primary,
        wrap
      )}${conflictClause(ast.primary, wrap)}${autoincrement(ast.primary, wrap)}` : "";
    }
    function autoincrement(ast, wrap) {
      return ast.autoincrement ? " AUTOINCREMENT" : "";
    }
    function notnullColumnConstraint(ast, wrap) {
      return ast.notnull !== null ? ` ${constraintName(ast.notnull, wrap)}NOT NULL${conflictClause(
        ast.notnull,
        wrap
      )}` : "";
    }
    function nullColumnConstraint(ast, wrap) {
      return ast.null !== null ? ` ${constraintName(ast.null, wrap)}NULL${conflictClause(ast.null, wrap)}` : "";
    }
    function uniqueColumnConstraint(ast, wrap) {
      return ast.unique !== null ? ` ${constraintName(ast.unique, wrap)}UNIQUE${conflictClause(
        ast.unique,
        wrap
      )}` : "";
    }
    function checkColumnConstraint(ast, wrap) {
      return ast.check !== null ? ` ${constraintName(ast.check, wrap)}CHECK (${expression(
        ast.check.expression,
        wrap
      )})` : "";
    }
    function defaultColumnConstraint(ast, wrap) {
      return ast.default !== null ? ` ${constraintName(ast.default, wrap)}DEFAULT ${!ast.default.expression ? ast.default.value : `(${expression(ast.default.value, wrap)})`}` : "";
    }
    function collateColumnConstraint(ast, wrap) {
      return ast.collate !== null ? ` ${constraintName(ast.collate, wrap)}COLLATE ${ast.collate.collation}` : "";
    }
    function referencesColumnConstraint(ast, wrap) {
      return ast.references !== null ? ` ${constraintName(ast.references, wrap)}${foreignKeyClause(
        ast.references,
        wrap
      )}` : "";
    }
    function asColumnConstraint(ast, wrap) {
      return ast.as !== null ? ` ${constraintName(ast.as, wrap)}${ast.as.generated ? "GENERATED ALWAYS " : ""}AS (${expression(ast.as.expression, wrap)})${ast.as.mode !== null ? ` ${ast.as.mode}` : ""}` : "";
    }
    function tableConstraintList(ast, wrap) {
      return ast.constraints.reduce(
        (constraintList, constraint) => `${constraintList}, ${tableConstraint(constraint, wrap)}`,
        ""
      );
    }
    function tableConstraint(ast, wrap) {
      switch (ast.type) {
        case "PRIMARY KEY":
          return primaryTableConstraint(ast, wrap);
        case "UNIQUE":
          return uniqueTableConstraint(ast, wrap);
        case "CHECK":
          return checkTableConstraint(ast, wrap);
        case "FOREIGN KEY":
          return foreignTableConstraint(ast, wrap);
      }
    }
    function primaryTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}PRIMARY KEY (${indexedColumnList(
        ast,
        wrap
      )})${conflictClause(ast, wrap)}`;
    }
    function uniqueTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}UNIQUE (${indexedColumnList(
        ast,
        wrap
      )})${conflictClause(ast, wrap)}`;
    }
    function conflictClause(ast, wrap) {
      return ast.conflict !== null ? ` ON CONFLICT ${ast.conflict}` : "";
    }
    function checkTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}CHECK (${expression(
        ast.expression,
        wrap
      )})`;
    }
    function foreignTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}FOREIGN KEY (${columnNameList(
        ast,
        wrap
      )}) ${foreignKeyClause(ast.references, wrap)}`;
    }
    function foreignKeyClause(ast, wrap) {
      return `REFERENCES ${table(ast, wrap)}${columnNameListOptional(
        ast,
        wrap
      )}${deleteUpdateMatchList(ast, wrap)}${deferrable(ast.deferrable, wrap)}`;
    }
    function columnNameListOptional(ast, wrap) {
      return ast.columns.length > 0 ? ` (${columnNameList(ast, wrap)})` : "";
    }
    function columnNameList(ast, wrap) {
      return ast.columns.map((column) => identifier(column, wrap)).join(", ");
    }
    function deleteUpdateMatchList(ast, wrap) {
      return `${deleteReference(ast, wrap)}${updateReference(
        ast,
        wrap
      )}${matchReference(ast, wrap)}`;
    }
    function deleteReference(ast, wrap) {
      return ast.delete !== null ? ` ON DELETE ${ast.delete}` : "";
    }
    function updateReference(ast, wrap) {
      return ast.update !== null ? ` ON UPDATE ${ast.update}` : "";
    }
    function matchReference(ast, wrap) {
      return ast.match !== null ? ` MATCH ${ast.match}` : "";
    }
    function deferrable(ast, wrap) {
      return ast !== null ? ` ${ast.not ? "NOT " : ""}DEFERRABLE${ast.initially !== null ? ` INITIALLY ${ast.initially}` : ""}` : "";
    }
    function constraintName(ast, wrap) {
      return ast.name !== null ? `CONSTRAINT ${identifier(ast.name, wrap)} ` : "";
    }
    function createIndex(ast, wrap) {
      return `CREATE${unique(ast, wrap)} INDEX${exists(ast, wrap)} ${schema(
        ast,
        wrap
      )}${index(ast, wrap)} on ${table(ast, wrap)} (${indexedColumnList(
        ast,
        wrap
      )})${where(ast, wrap)}`;
    }
    function unique(ast, wrap) {
      return ast.unique ? " UNIQUE" : "";
    }
    function exists(ast, wrap) {
      return ast.exists ? " IF NOT EXISTS" : "";
    }
    function schema(ast, wrap) {
      return ast.schema !== null ? `${identifier(ast.schema, wrap)}.` : "";
    }
    function index(ast, wrap) {
      return identifier(ast.index, wrap);
    }
    function table(ast, wrap) {
      return identifier(ast.table, wrap);
    }
    function where(ast, wrap) {
      return ast.where !== null ? ` where ${expression(ast.where)}` : "";
    }
    function indexedColumnList(ast, wrap) {
      return ast.columns.map(
        (column) => !column.expression ? indexedColumn(column, wrap) : indexedColumnExpression(column, wrap)
      ).join(", ");
    }
    function indexedColumn(ast, wrap) {
      return `${identifier(ast.name, wrap)}${collation(ast, wrap)}${order(
        ast,
        wrap
      )}`;
    }
    function indexedColumnExpression(ast, wrap) {
      return `${indexedExpression(ast.name, wrap)}${collation(ast, wrap)}${order(
        ast,
        wrap
      )}`;
    }
    function collation(ast, wrap) {
      return ast.collation !== null ? ` COLLATE ${ast.collation}` : "";
    }
    function order(ast, wrap) {
      return ast.order !== null ? ` ${ast.order}` : "";
    }
    function indexedExpression(ast, wrap) {
      return expression(ast, wrap);
    }
    function expression(ast, wrap) {
      return ast.reduce(
        (expr, e3) => Array.isArray(e3) ? `${expr}(${expression(e3)})` : !expr ? e3 : `${expr} ${e3}`,
        ""
      );
    }
    function identifier(ast, wrap) {
      return wrap(ast);
    }
    module.exports = {
      compileCreateTable,
      compileCreateIndex
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js
var require_utils3 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js"(exports, module) {
    function isEqualId(first, second) {
      return first.toLowerCase() === second.toLowerCase();
    }
    function includesId(list, id) {
      return list.some((item) => isEqualId(item, id));
    }
    module.exports = {
      isEqualId,
      includesId
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/ddl.js
var require_ddl = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/ddl.js"(exports, module) {
    var identity = require_identity();
    var { nanonum } = require_nanoid();
    var {
      copyData,
      dropOriginal,
      renameTable,
      getTableSql,
      isForeignCheckEnabled,
      setForeignCheck,
      executeForeignCheck
    } = require_sqlite_ddl_operations();
    var { parseCreateTable, parseCreateIndex } = require_parser();
    var {
      compileCreateTable,
      compileCreateIndex
    } = require_compiler2();
    var { isEqualId, includesId } = require_utils3();
    var SQLite3_DDL = class {
      constructor(client, tableCompiler, pragma, connection) {
        this.client = client;
        this.tableCompiler = tableCompiler;
        this.pragma = pragma;
        this.tableNameRaw = this.tableCompiler.tableNameRaw;
        this.alteredName = `_knex_temp_alter${nanonum(3)}`;
        this.connection = connection;
        this.formatter = (value) => this.client.customWrapIdentifier(value, identity);
        this.wrap = (value) => this.client.wrapIdentifierImpl(value);
      }
      tableName() {
        return this.formatter(this.tableNameRaw);
      }
      getTableSql() {
        const tableName = this.tableName();
        return this.client.transaction(
          async (trx) => {
            trx.disableProcessing();
            const result = await trx.raw(getTableSql(tableName));
            trx.enableProcessing();
            return {
              createTable: result.filter((create) => create.type === "table")[0].sql,
              createIndices: result.filter((create) => create.type === "index").map((create) => create.sql)
            };
          },
          { connection: this.connection }
        );
      }
      async isForeignCheckEnabled() {
        const result = await this.client.raw(isForeignCheckEnabled()).connection(this.connection);
        return result[0].foreign_keys === 1;
      }
      async setForeignCheck(enable) {
        await this.client.raw(setForeignCheck(enable)).connection(this.connection);
      }
      renameTable(trx) {
        return trx.raw(renameTable(this.alteredName, this.tableName()));
      }
      dropOriginal(trx) {
        return trx.raw(dropOriginal(this.tableName()));
      }
      copyData(trx, columns) {
        return trx.raw(copyData(this.tableName(), this.alteredName, columns));
      }
      async alterColumn(columns) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => {
          const newColumnInfo = columns.find((c3) => isEqualId(c3.name, column.name));
          if (newColumnInfo) {
            column.type = newColumnInfo.type;
            column.constraints.default = newColumnInfo.defaultTo !== null ? {
              name: null,
              value: newColumnInfo.defaultTo,
              expression: false
            } : null;
            column.constraints.notnull = newColumnInfo.notNull ? { name: null, conflict: null } : null;
            column.constraints.null = newColumnInfo.notNull ? null : column.constraints.null;
          }
          return column;
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async dropColumn(columns) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.filter(
          (parsedColumn) => parsedColumn.expression || !includesId(columns, parsedColumn.name)
        );
        if (parsedTable.columns.length === 0) {
          throw new Error("Unable to drop last column from table");
        }
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "PRIMARY KEY" || constraint.type === "UNIQUE") {
            return constraint.columns.every(
              (constraintColumn) => constraintColumn.expression || !includesId(columns, constraintColumn.name)
            );
          } else if (constraint.type === "FOREIGN KEY") {
            return constraint.columns.every(
              (constraintColumnName) => !includesId(columns, constraintColumnName)
            ) && (constraint.references.table !== parsedTable.table || constraint.references.columns.every(
              (referenceColumnName) => !includesId(columns, referenceColumnName)
            ));
          } else {
            return true;
          }
        });
        const newColumns = parsedTable.columns.map((column) => column.name);
        const newTable = compileCreateTable(parsedTable, this.wrap);
        const newIndices = [];
        for (const createIndex of createIndices) {
          const parsedIndex = parseCreateIndex(createIndex);
          parsedIndex.columns = parsedIndex.columns.filter(
            (parsedColumn) => parsedColumn.expression || !includesId(columns, parsedColumn.name)
          );
          if (parsedIndex.columns.length > 0) {
            newIndices.push(compileCreateIndex(parsedIndex, this.wrap));
          }
        }
        return this.alter(newTable, newIndices, newColumns);
      }
      async dropForeign(columns, foreignKeyName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        if (!foreignKeyName) {
          parsedTable.columns = parsedTable.columns.map((column) => ({
            ...column,
            references: includesId(columns, column.name) ? null : column.references
          }));
        }
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "FOREIGN KEY") {
            if (foreignKeyName) {
              return !constraint.name || !isEqualId(constraint.name, foreignKeyName);
            }
            return constraint.columns.every(
              (constraintColumnName) => !includesId(columns, constraintColumnName)
            );
          } else {
            return true;
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async dropPrimary(constraintName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => ({
          ...column,
          primary: null
        }));
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "PRIMARY KEY") {
            if (constraintName) {
              return !constraint.name || !isEqualId(constraint.name, constraintName);
            } else {
              return false;
            }
          } else {
            return true;
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async primary(columns, constraintName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => ({
          ...column,
          primary: null
        }));
        parsedTable.constraints = parsedTable.constraints.filter(
          (constraint) => constraint.type !== "PRIMARY KEY"
        );
        parsedTable.constraints.push({
          type: "PRIMARY KEY",
          name: constraintName || null,
          columns: columns.map((column) => ({
            name: column,
            expression: false,
            collation: null,
            order: null
          })),
          conflict: null
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async foreign(foreignInfo) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.constraints.push({
          type: "FOREIGN KEY",
          name: foreignInfo.keyName || null,
          columns: foreignInfo.column,
          references: {
            table: foreignInfo.inTable,
            columns: foreignInfo.references,
            delete: foreignInfo.onDelete || null,
            update: foreignInfo.onUpdate || null,
            match: null,
            deferrable: null
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async setNullable(column, isNullable) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        const parsedColumn = parsedTable.columns.find(
          (c3) => isEqualId(column, c3.name)
        );
        if (!parsedColumn) {
          throw new Error(
            `.setNullable: Column ${column} does not exist in table ${this.tableName()}.`
          );
        }
        parsedColumn.constraints.notnull = isNullable ? null : { name: null, conflict: null };
        parsedColumn.constraints.null = isNullable ? parsedColumn.constraints.null : null;
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async alter(newSql, createIndices, columns) {
        const wasForeignCheckEnabled = await this.isForeignCheckEnabled();
        if (wasForeignCheckEnabled) {
          await this.setForeignCheck(false);
        }
        try {
          await this.client.transaction(
            async (trx) => {
              await trx.raw(newSql);
              await this.copyData(trx, columns);
              await this.dropOriginal(trx);
              await this.renameTable(trx);
              for (const createIndex of createIndices) {
                await trx.raw(createIndex);
              }
              if (wasForeignCheckEnabled) {
                const foreignViolations = await trx.raw(executeForeignCheck());
                if (foreignViolations.length > 0) {
                  throw new Error("FOREIGN KEY constraint failed");
                }
              }
            },
            { connection: this.connection }
          );
        } finally {
          if (wasForeignCheckEnabled) {
            await this.setForeignCheck(true);
          }
        }
      }
      async generateAlterCommands(newSql, createIndices, columns) {
        const sql = [];
        const pre = [];
        const post = [];
        let check = null;
        sql.push(newSql);
        sql.push(copyData(this.tableName(), this.alteredName, columns));
        sql.push(dropOriginal(this.tableName()));
        sql.push(renameTable(this.alteredName, this.tableName()));
        for (const createIndex of createIndices) {
          sql.push(createIndex);
        }
        const isForeignCheckEnabled2 = await this.isForeignCheckEnabled();
        if (isForeignCheckEnabled2) {
          pre.push(setForeignCheck(false));
          post.push(setForeignCheck(true));
          check = executeForeignCheck();
        }
        return { pre, sql, check, post };
      }
    };
    module.exports = SQLite3_DDL;
  }
});

// node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js
var require_sqlite_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js"(exports, module) {
    var QueryBuilder = require_querybuilder();
    module.exports = class QueryBuilder_SQLite3 extends QueryBuilder {
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          true
        );
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          false
        );
      }
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/index.js
var require_sqlite3 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/index.js"(exports, module) {
    var defaults = require_defaults();
    var map2 = require_map();
    var { promisify } = __require("util");
    var Client = require_client();
    var Raw = require_raw();
    var Transaction = require_sqlite_transaction();
    var SqliteQueryCompiler = require_sqlite_querycompiler();
    var SchemaCompiler = require_sqlite_compiler();
    var ColumnCompiler = require_sqlite_columncompiler();
    var TableCompiler = require_sqlite_tablecompiler();
    var ViewCompiler = require_sqlite_viewcompiler();
    var SQLite3_DDL = require_ddl();
    var Formatter = require_formatter();
    var QueryBuilder = require_sqlite_querybuilder();
    var Client_SQLite3 = class extends Client {
      constructor(config) {
        super(config);
        if (config.connection && config.connection.filename === void 0) {
          this.logger.warn(
            "Could not find `connection.filename` in config. Please specify the database path and name to avoid errors. (see docs https://knexjs.org/guide/#configuration-options)"
          );
        }
        if (config.useNullAsDefault === void 0) {
          this.logger.warn(
            "sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert)."
          );
        }
      }
      _driver() {
        return __require("sqlite3");
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new SqliteQueryCompiler(this, builder, formatter);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      viewCompiler(builder, formatter) {
        return new ViewCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      ddl(compiler, pragma, connection) {
        return new SQLite3_DDL(this, compiler, pragma, connection);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `\`${value.replace(/`/g, "``")}\`` : "*";
      }
      // Get a raw connection from the database, returning a promise with the connection object.
      acquireRawConnection() {
        return new Promise((resolve, reject) => {
          let flags = this.driver.OPEN_READWRITE | this.driver.OPEN_CREATE;
          if (this.connectionSettings.flags) {
            if (!Array.isArray(this.connectionSettings.flags)) {
              throw new Error(`flags must be an array of strings`);
            }
            this.connectionSettings.flags.forEach((_flag) => {
              if (!_flag.startsWith("OPEN_") || !this.driver[_flag]) {
                throw new Error(`flag ${_flag} not supported by node-sqlite3`);
              }
              flags = flags | this.driver[_flag];
            });
          }
          const db = new this.driver.Database(
            this.connectionSettings.filename,
            flags,
            (err) => {
              if (err) {
                return reject(err);
              }
              resolve(db);
            }
          );
        });
      }
      // Used to explicitly close a connection, called internally by the pool when
      // a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        const close = promisify((cb) => connection.close(cb));
        return close();
      }
      // Runs the query on the specified connection, providing the bindings and any
      // other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        const { method } = obj;
        let callMethod;
        switch (method) {
          case "insert":
          case "update":
            callMethod = obj.returning ? "all" : "run";
            break;
          case "counter":
          case "del":
            callMethod = "run";
            break;
          default:
            callMethod = "all";
        }
        return new Promise(function(resolver, rejecter) {
          if (!connection || !connection[callMethod]) {
            return rejecter(
              new Error(`Error calling ${callMethod} on connection.`)
            );
          }
          connection[callMethod](obj.sql, obj.bindings, function(err, response) {
            if (err) return rejecter(err);
            obj.response = response;
            obj.context = this;
            return resolver(obj);
          });
        });
      }
      _stream(connection, obj, stream2) {
        if (!obj.sql) throw new Error("The query is empty");
        const client = this;
        return new Promise(function(resolver, rejecter) {
          stream2.on("error", rejecter);
          stream2.on("end", resolver);
          return client._query(connection, obj).then((obj2) => obj2.response).then((rows) => rows.forEach((row) => stream2.write(row))).catch(function(err) {
            stream2.emit("error", err);
          }).then(function() {
            stream2.end();
          });
        });
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const ctx = obj.context;
        const { response, returning } = obj;
        if (obj.output) return obj.output.call(runner, response);
        switch (obj.method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map2(response, obj.pluck);
          case "insert": {
            if (returning) {
              if (response) {
                return response;
              }
            }
            return [ctx.lastID];
          }
          case "update": {
            if (returning) {
              if (response) {
                return response;
              }
            }
            return ctx.changes;
          }
          case "del":
          case "counter":
            return ctx.changes;
          default: {
            return response;
          }
        }
      }
      poolDefaults() {
        return defaults({ min: 1, max: 1 }, super.poolDefaults());
      }
      formatter(builder) {
        return new Formatter(this, builder);
      }
      values(values, builder, formatter) {
        if (Array.isArray(values)) {
          if (Array.isArray(values[0])) {
            return `( values ${values.map(
              (value) => `(${this.parameterize(value, void 0, builder, formatter)})`
            ).join(", ")})`;
          }
          return `(${this.parameterize(values, void 0, builder, formatter)})`;
        }
        if (values instanceof Raw) {
          return `(${this.parameter(values, builder, formatter)})`;
        }
        return this.parameter(values, builder, formatter);
      }
    };
    Object.assign(Client_SQLite3.prototype, {
      dialect: "sqlite3",
      driverName: "sqlite3"
    });
    module.exports = Client_SQLite3;
  }
});

// node_modules/knex/lib/dialects/better-sqlite3/index.js
var require_better_sqlite3 = __commonJS({
  "node_modules/knex/lib/dialects/better-sqlite3/index.js"(exports, module) {
    var Client_SQLite3 = require_sqlite3();
    var Client_BetterSQLite3 = class extends Client_SQLite3 {
      _driver() {
        return __require("better-sqlite3");
      }
      // Get a raw connection from the database, returning a promise with the connection object.
      async acquireRawConnection() {
        const options = this.connectionSettings.options || {};
        return new this.driver(this.connectionSettings.filename, {
          nativeBinding: options.nativeBinding,
          readonly: !!options.readonly
        });
      }
      // Used to explicitly close a connection, called internally by the pool when
      // a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        return connection.close();
      }
      // Runs the query on the specified connection, providing the bindings and any
      // other necessary prep work.
      async _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        if (!connection) {
          throw new Error("No connection provided");
        }
        const statement = connection.prepare(obj.sql);
        const bindings = this._formatBindings(obj.bindings);
        if (statement.reader) {
          const response2 = await statement.all(bindings);
          obj.response = response2;
          return obj;
        }
        const response = await statement.run(bindings);
        obj.response = response;
        obj.context = {
          lastID: response.lastInsertRowid,
          changes: response.changes
        };
        return obj;
      }
      _formatBindings(bindings) {
        if (!bindings) {
          return [];
        }
        return bindings.map((binding) => {
          if (binding instanceof Date) {
            return binding.valueOf();
          }
          if (typeof binding === "boolean") {
            return Number(binding);
          }
          return binding;
        });
      }
    };
    Object.assign(Client_BetterSQLite3.prototype, {
      // The "dialect", for reference .
      driverName: "better-sqlite3"
    });
    module.exports = Client_BetterSQLite3;
  }
});

// node_modules/knex/lib/dialects/postgres/execution/pg-transaction.js
var require_pg_transaction = __commonJS({
  "node_modules/knex/lib/dialects/postgres/execution/pg-transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var Transaction_PG = class extends Transaction {
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `BEGIN TRANSACTION ${trxMode};`);
      }
    };
    module.exports = Transaction_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js
var require_pg_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js"(exports, module) {
    var identity = require_identity();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var {
      wrapString,
      columnize: columnize_,
      operator: operator_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var QueryCompiler_PG = class extends QueryCompiler {
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        this._defaultInsertValue = "default";
      }
      // Compiles a truncate query.
      truncate() {
        return `truncate ${this.tableName} restart identity`;
      }
      // is used if the an array with multiple empty values supplied
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let sql = super.insert();
        if (sql === "") return sql;
        const { returning, onConflict, ignore, merge, insert } = this.single;
        if (onConflict && ignore) sql += this._ignore(onConflict);
        if (onConflict && merge) {
          sql += this._merge(merge.updates, onConflict, insert);
          const wheres = this.where();
          if (wheres) sql += ` ${wheres}`;
        }
        if (returning) sql += this._returning(returning);
        return {
          sql,
          returning
        };
      }
      // Compiles an `update` query, allowing for a return value.
      update() {
        const withSQL = this.with();
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        const { returning, updateFrom } = this.single;
        return {
          sql: withSQL + `update ${this.single.only ? "only " : ""}${this.tableName} set ${updateData.join(", ")}` + this._updateFrom(updateFrom) + (wheres ? ` ${wheres}` : "") + this._returning(returning),
          returning
        };
      }
      using() {
        const usingTables = this.single.using;
        if (!usingTables) return;
        let sql = "using ";
        if (Array.isArray(usingTables)) {
          sql += usingTables.map((table) => {
            return this.formatter.wrap(table);
          }).join(",");
        } else {
          sql += this.formatter.wrap(usingTables);
        }
        return sql;
      }
      // Compiles an `delete` query, allowing for a return value.
      del() {
        const { tableName } = this;
        const withSQL = this.with();
        let wheres = this.where() || "";
        let using = this.using() || "";
        const joins = this.grouped.join;
        const tableJoins = [];
        if (Array.isArray(joins)) {
          for (const join of joins) {
            tableJoins.push(
              wrap_(
                this._joinTable(join),
                void 0,
                this.builder,
                this.client,
                this.bindingsHolder
              )
            );
            const joinWheres = [];
            for (const clause of join.clauses) {
              joinWheres.push(
                this.whereBasic({
                  column: clause.column,
                  operator: "=",
                  value: clause.value,
                  asColumn: true
                })
              );
            }
            if (joinWheres.length > 0) {
              wheres += (wheres ? " and " : "where ") + joinWheres.join(" and ");
            }
          }
          if (tableJoins.length > 0) {
            using += (using ? "," : "using ") + tableJoins.join(",");
          }
        }
        const sql = withSQL + `delete from ${this.single.only ? "only " : ""}${tableName}` + (using ? ` ${using}` : "") + (wheres ? ` ${wheres}` : "");
        const { returning } = this.single;
        return {
          sql: sql + this._returning(returning),
          returning
        };
      }
      aggregate(stmt) {
        return this._aggregate(stmt, { distinctParentheses: true });
      }
      _returning(value) {
        return value ? ` returning ${this.formatter.columnize(value)}` : "";
      }
      _updateFrom(name) {
        return name ? ` from ${this.formatter.wrap(name)}` : "";
      }
      _ignore(columns) {
        if (columns === true) {
          return " on conflict do nothing";
        }
        return ` on conflict ${this._onConflictClause(columns)} do nothing`;
      }
      _merge(updates, columns, insert) {
        let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;
        if (updates && Array.isArray(updates)) {
          sql += updates.map(
            (column) => wrapString(
              column.split(".").pop(),
              this.formatter.builder,
              this.client,
              this.formatter
            )
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql;
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          if (typeof updateData === "string") {
            sql += updateData;
          } else {
            sql += updateData.join(",");
          }
          return sql;
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          sql += insertData.columns.map(
            (column) => wrapString(column.split(".").pop(), this.builder, this.client)
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql;
        }
      }
      // Join array of table names and apply default schema.
      _tableNames(tables) {
        const schemaName = this.single.schema;
        const sql = [];
        for (let i3 = 0; i3 < tables.length; i3++) {
          let tableName = tables[i3];
          if (tableName) {
            if (schemaName) {
              tableName = `${schemaName}.${tableName}`;
            }
            sql.push(this.formatter.wrap(tableName));
          }
        }
        return sql.join(", ");
      }
      _lockingClause(lockMode) {
        const tables = this.single.lockTables || [];
        return lockMode + (tables.length ? " of " + this._tableNames(tables) : "");
      }
      _groupOrder(item, type) {
        return super._groupOrderNulls(item, type);
      }
      forUpdate() {
        return this._lockingClause("for update");
      }
      forShare() {
        return this._lockingClause("for share");
      }
      forNoKeyUpdate() {
        return this._lockingClause("for no key update");
      }
      forKeyShare() {
        return this._lockingClause("for key share");
      }
      skipLocked() {
        return "skip locked";
      }
      noWait() {
        return "nowait";
      }
      // Compiles a columnInfo query
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        const sql = "select * from information_schema.columns where table_name = ? and table_catalog = current_database()";
        const bindings = [table];
        return this._buildColumnInfoQuery(schema, sql, bindings, column);
      }
      _buildColumnInfoQuery(schema, sql, bindings, column) {
        if (schema) {
          sql += " and table_schema = ?";
          bindings.push(schema);
        } else {
          sql += " and table_schema = current_schema()";
        }
        return {
          sql,
          bindings,
          output(resp) {
            const out = reduce(
              resp.rows,
              function(columns, val2) {
                columns[val2.column_name] = {
                  type: val2.data_type,
                  maxLength: val2.character_maximum_length,
                  nullable: val2.is_nullable === "YES",
                  defaultValue: val2.column_default
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      distinctOn(value) {
        return "distinct on (" + this.formatter.columnize(value) + ") ";
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract("jsonb_path_query", params);
      }
      jsonSet(params) {
        return this._jsonSet(
          "jsonb_set",
          Object.assign({}, params, {
            path: this.client.toPathForJson(params.path)
          })
        );
      }
      jsonInsert(params) {
        return this._jsonSet(
          "jsonb_insert",
          Object.assign({}, params, {
            path: this.client.toPathForJson(params.path)
          })
        );
      }
      jsonRemove(params) {
        const jsonCol = `${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )} #- ${this.client.parameter(
          this.client.toPathForJson(params.path),
          this.builder,
          this.bindingsHolder
        )}`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        let castValue = "";
        if (!isNaN(statement.value) && parseInt(statement.value)) {
          castValue = "::int";
        } else if (!isNaN(statement.value) && parseFloat(statement.value)) {
          castValue = "::float";
        } else {
          castValue = " #>> '{}'";
        }
        return `jsonb_path_query_first(${this._columnClause(
          statement
        )}, ${this.client.parameter(
          statement.jsonPath,
          this.builder,
          this.bindingsHolder
        )})${castValue} ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      whereJsonSupersetOf(statement) {
        return this._not(
          statement,
          `${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )} @> ${this._jsonValueClause(statement)}`
        );
      }
      whereJsonSubsetOf(statement) {
        return this._not(
          statement,
          `${columnize_(
            statement.column,
            this.builder,
            this.client,
            this.bindingsHolder
          )} <@ ${this._jsonValueClause(statement)}`
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("jsonb_path_query_first", clause);
      }
    };
    module.exports = QueryCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/query/pg-querybuilder.js
var require_pg_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/postgres/query/pg-querybuilder.js"(exports, module) {
    var QueryBuilder = require_querybuilder();
    module.exports = class QueryBuilder_PostgreSQL extends QueryBuilder {
      updateFrom(name) {
        this._single.updateFrom = name;
        return this;
      }
      using(tables) {
        this._single.using = tables;
        return this;
      }
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          true
        );
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          false
        );
      }
    };
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-columncompiler.js
var require_pg_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-columncompiler.js"(exports, module) {
    var ColumnCompiler = require_columncompiler();
    var { isObject } = require_is();
    var { toNumber } = require_helpers();
    var commentEscapeRegex = /(?<!')'(?!')/g;
    var ColumnCompiler_PG = class extends ColumnCompiler {
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = ["nullable", "defaultTo", "comment"];
        this._addCheckModifiers();
      }
      // Types
      // ------
      bit(column) {
        return column.length !== false ? `bit(${column.length})` : "bit";
      }
      // Create the column definition for an enum type.
      // Using method "2" here: http://stackoverflow.com/a/10984951/525714
      enu(allowed, options) {
        options = options || {};
        const values = options.useNative && options.existingType ? void 0 : allowed.join("', '");
        if (options.useNative) {
          let enumName = "";
          const schemaName = options.schemaName || this.tableCompiler.schemaNameRaw;
          if (schemaName) {
            enumName += `"${schemaName}".`;
          }
          enumName += `"${options.enumName}"`;
          if (!options.existingType) {
            this.tableCompiler.unshiftQuery(
              `create type ${enumName} as enum ('${values}')`
            );
          }
          return enumName;
        }
        return `text check (${this.formatter.wrap(this.args[0])} in ('${values}'))`;
      }
      decimal(precision, scale) {
        if (precision === null) return "decimal";
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      json(jsonb) {
        if (jsonb) this.client.logger.deprecate("json(true)", "jsonb()");
        return jsonColumn(this.client, jsonb);
      }
      jsonb() {
        return jsonColumn(this.client, true);
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} ~ ${this.client._escapeBinding(regex)}`,
          constraintName
        );
      }
      datetime(withoutTz = false, precision) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz, precision } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        useTz = typeof useTz === "boolean" ? useTz : true;
        precision = precision !== void 0 && precision !== null ? "(" + precision + ")" : "";
        return `${useTz ? "timestamptz" : "timestamp"}${precision}`;
      }
      timestamp(withoutTz = false, precision) {
        return this.datetime(withoutTz, precision);
      }
      // Modifiers:
      // ------
      comment(comment) {
        const columnName = this.args[0] || this.defaults("columnName");
        const escapedComment = comment ? `'${comment.replace(commentEscapeRegex, "''")}'` : "NULL";
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(columnName) + ` is ${escapedComment}`
          );
        }, comment);
      }
      increments(options = { primaryKey: true }) {
        return "serial" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigserial" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      uuid(options = { primaryKey: false }) {
        return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
    };
    ColumnCompiler_PG.prototype.bigint = "bigint";
    ColumnCompiler_PG.prototype.binary = "bytea";
    ColumnCompiler_PG.prototype.bool = "boolean";
    ColumnCompiler_PG.prototype.double = "double precision";
    ColumnCompiler_PG.prototype.floating = "real";
    ColumnCompiler_PG.prototype.smallint = "smallint";
    ColumnCompiler_PG.prototype.tinyint = "smallint";
    function jsonColumn(client, jsonb) {
      if (!client.version || client.config.client === "cockroachdb" || client.config.jsonbSupport === true || parseFloat(client.version) >= 9.2) {
        return jsonb ? "jsonb" : "json";
      }
      return "text";
    }
    module.exports = ColumnCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-tablecompiler.js
var require_pg_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-tablecompiler.js"(exports, module) {
    var has = require_has();
    var TableCompiler = require_tablecompiler();
    var { isObject, isString } = require_is();
    var TableCompiler_PG = class extends TableCompiler {
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      // Compile a rename column command.
      renameColumn(from, to) {
        return this.pushQuery({
          sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      _setNullableState(column, isNullable) {
        const constraintAction = isNullable ? "drop not null" : "set not null";
        const sql = `alter table ${this.tableName()} alter column ${this.formatter.wrap(
          column
        )} ${constraintAction}`;
        return this.pushQuery({
          sql
        });
      }
      compileAdd(builder) {
        const table = this.formatter.wrap(builder);
        const columns = this.prefixArray("add column", this.getColumns(builder));
        return this.pushQuery({
          sql: `alter table ${table} ${columns.join(", ")}`
        });
      }
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const columnsSql = ` (${columns.sql.join(", ")}${this.primaryKeys() || ""}${this._addChecks()})`;
        let sql = createStatement + this.tableName() + (like && this.tableNameLike() ? " (like " + this.tableNameLike() + " including all" + (columns.sql.length ? ", " + columns.sql.join(", ") : "") + ")" : columnsSql);
        if (this.single.inherits)
          sql += ` inherits (${this.formatter.wrap(this.single.inherits)})`;
        this.pushQuery({
          sql,
          bindings: columns.bindings
        });
        const hasComment = has(this.single, "comment");
        if (hasComment) this.comment(this.single.comment);
      }
      primaryKeys() {
        const pks = (this.grouped.alterTable || []).filter(
          (k3) => k3.method === "primary"
        );
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          let deferrable;
          if (isObject(constraintName)) {
            ({ constraintName, deferrable } = constraintName);
          }
          deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
          constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
          return `, constraint ${constraintName} primary key (${this.formatter.columnize(
            columns
          )})${deferrable}`;
        }
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          for (const col of colCompilers) {
            this._addColumn(col);
          }
        } else {
          super.addColumns(columns, prefix);
        }
      }
      _addColumn(col) {
        const quotedTableName = this.tableName();
        const type = col.getColumnType();
        const colName = this.client.wrapIdentifier(
          col.getColumnName(),
          col.columnBuilder.queryContext()
        );
        const isEnum = col.type === "enu";
        this.pushQuery({
          sql: `alter table ${quotedTableName} alter column ${colName} drop default`,
          bindings: []
        });
        const alterNullable = col.columnBuilder.alterNullable;
        if (alterNullable) {
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} drop not null`,
            bindings: []
          });
        }
        const alterType = col.columnBuilder.alterType;
        if (alterType) {
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} type ${type} using (${colName}${isEnum ? "::text::" : "::"}${type})`,
            bindings: []
          });
        }
        const defaultTo = col.modified["defaultTo"];
        if (defaultTo) {
          const modifier = col.defaultTo.apply(col, defaultTo);
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} set ${modifier}`,
            bindings: []
          });
        }
        if (alterNullable) {
          const nullable = col.modified["nullable"];
          if (nullable && nullable[0] === false) {
            this.pushQuery({
              sql: `alter table ${quotedTableName} alter column ${colName} set not null`,
              bindings: []
            });
          }
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(
          `comment on table ${this.tableName()} is '${this.single.comment}'`
        );
      }
      // Indexes:
      // -------
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery(
            `alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(
              columns
            )})${deferrable}`
          );
        }
      }
      unique(columns, indexName) {
        let deferrable;
        let useConstraint = true;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, useConstraint, predicate } = indexName);
          if (useConstraint === void 0) {
            useConstraint = !!deferrable || !predicate;
          }
        }
        if (!useConstraint && deferrable && deferrable !== "not deferrable") {
          throw new Error("postgres cannot create deferrable index");
        }
        if (useConstraint && predicate) {
          throw new Error("postgres cannot create constraint with predicate");
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        if (useConstraint) {
          this.pushQuery(
            `alter table ${this.tableName()} add constraint ${indexName} unique (` + this.formatter.columnize(columns) + ")" + deferrable
          );
        } else {
          const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
          this.pushQuery(
            `create unique index ${indexName} on ${this.tableName()} (${this.formatter.columnize(
              columns
            )})${predicateQuery}`
          );
        }
      }
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        let predicate;
        let storageEngineIndexType;
        let indexType;
        if (isString(options)) {
          storageEngineIndexType = options;
        } else if (isObject(options)) {
          ({ indexType, storageEngineIndexType, predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create${typeof indexType === "string" && indexType.toLowerCase() === "unique" ? " unique" : ""} index ${indexName} on ${this.tableName()}${storageEngineIndexType && ` using ${storageEngineIndexType}` || ""} (` + this.formatter.columnize(columns) + `)${predicateQuery}`
        );
      }
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + "_pkey");
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${constraintName}`
        );
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        indexName = this.schemaNameRaw ? `${this.formatter.wrap(this.schemaNameRaw)}.${indexName}` : indexName;
        this.pushQuery(`drop index ${indexName}`);
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
    };
    module.exports = TableCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-viewcompiler.js
var require_pg_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-viewcompiler.js"(exports, module) {
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_PG = class extends ViewCompiler {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      renameColumn(from, to) {
        return this.pushQuery({
          sql: `alter view ${this.viewName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      defaultTo(column, defaultValue) {
        return this.pushQuery({
          sql: `alter view ${this.viewName()} alter ${this.formatter.wrap(
            column
          )} set default ${defaultValue}`
        });
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
      createMaterializedView() {
        this.createQuery(this.columns, this.selectQuery, true);
      }
    };
    module.exports = ViewCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-viewbuilder.js
var require_pg_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-viewbuilder.js"(exports, module) {
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_PG = class extends ViewBuilder {
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
      localCheckOption() {
        this._single.checkOption = "local";
      }
      cascadedCheckOption() {
        this._single.checkOption = "cascaded";
      }
    };
    module.exports = ViewBuilder_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js
var require_pg_compiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js"(exports, module) {
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_PG = class extends SchemaCompiler {
      constructor(client, builder) {
        super(client, builder);
      }
      // Check whether the current table
      hasTable(tableName) {
        let sql = "select * from information_schema.tables where table_name = ?";
        const bindings = [tableName];
        if (this.schema) {
          sql += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql += " and table_schema = current_schema()";
        }
        this.pushQuery({
          sql,
          bindings,
          output(resp) {
            return resp.rows.length > 0;
          }
        });
      }
      // Compile the query to determine if a column exists in a table.
      hasColumn(tableName, columnName) {
        let sql = "select * from information_schema.columns where table_name = ? and column_name = ?";
        const bindings = [tableName, columnName];
        if (this.schema) {
          sql += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql += " and table_schema = current_schema()";
        }
        this.pushQuery({
          sql,
          bindings,
          output(resp) {
            return resp.rows.length > 0;
          }
        });
      }
      qualifiedTableName(tableName) {
        const name = this.schema ? `${this.schema}.${tableName}` : tableName;
        return this.formatter.wrap(name);
      }
      // Compile a rename table command.
      renameTable(from, to) {
        this.pushQuery(
          `alter table ${this.qualifiedTableName(
            from
          )} rename to ${this.formatter.wrap(to)}`
        );
      }
      createSchema(schemaName) {
        this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);
      }
      createSchemaIfNotExists(schemaName) {
        this.pushQuery(
          `create schema if not exists ${this.formatter.wrap(schemaName)}`
        );
      }
      dropSchema(schemaName, cascade = false) {
        this.pushQuery(
          `drop schema ${this.formatter.wrap(schemaName)}${cascade ? " cascade" : ""}`
        );
      }
      dropSchemaIfExists(schemaName, cascade = false) {
        this.pushQuery(
          `drop schema if exists ${this.formatter.wrap(schemaName)}${cascade ? " cascade" : ""}`
        );
      }
      dropExtension(extensionName) {
        this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);
      }
      dropExtensionIfExists(extensionName) {
        this.pushQuery(
          `drop extension if exists ${this.formatter.wrap(extensionName)}`
        );
      }
      createExtension(extensionName) {
        this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);
      }
      createExtensionIfNotExists(extensionName) {
        this.pushQuery(
          `create extension if not exists ${this.formatter.wrap(extensionName)}`
        );
      }
      renameView(from, to) {
        this.pushQuery(
          this.alterViewPrefix + `${this.formatter.wrap(from)} rename to ${this.formatter.wrap(to)}`
        );
      }
      refreshMaterializedView(viewName, concurrently = false) {
        this.pushQuery({
          sql: `refresh materialized view${concurrently ? " concurrently" : ""} ${this.formatter.wrap(viewName)}`
        });
      }
      dropMaterializedView(viewName) {
        this._dropView(viewName, false, true);
      }
      dropMaterializedViewIfExists(viewName) {
        this._dropView(viewName, true, true);
      }
    };
    module.exports = SchemaCompiler_PG;
  }
});

// node_modules/pg/node_modules/postgres-array/index.js
var require_postgres_array = __commonJS({
  "node_modules/pg/node_modules/postgres-array/index.js"(exports) {
    "use strict";
    exports.parse = function(source, transform) {
      return new ArrayParser(source, transform).parse();
    };
    var ArrayParser = class _ArrayParser {
      constructor(source, transform) {
        this.source = source;
        this.transform = transform || identity;
        this.position = 0;
        this.entries = [];
        this.recorded = [];
        this.dimension = 0;
      }
      isEof() {
        return this.position >= this.source.length;
      }
      nextCharacter() {
        var character = this.source[this.position++];
        if (character === "\\") {
          return {
            value: this.source[this.position++],
            escaped: true
          };
        }
        return {
          value: character,
          escaped: false
        };
      }
      record(character) {
        this.recorded.push(character);
      }
      newEntry(includeEmpty) {
        var entry;
        if (this.recorded.length > 0 || includeEmpty) {
          entry = this.recorded.join("");
          if (entry === "NULL" && !includeEmpty) {
            entry = null;
          }
          if (entry !== null) entry = this.transform(entry);
          this.entries.push(entry);
          this.recorded = [];
        }
      }
      consumeDimensions() {
        if (this.source[0] === "[") {
          while (!this.isEof()) {
            var char = this.nextCharacter();
            if (char.value === "=") break;
          }
        }
      }
      parse(nested) {
        var character, parser, quote;
        this.consumeDimensions();
        while (!this.isEof()) {
          character = this.nextCharacter();
          if (character.value === "{" && !quote) {
            this.dimension++;
            if (this.dimension > 1) {
              parser = new _ArrayParser(this.source.substr(this.position - 1), this.transform);
              this.entries.push(parser.parse(true));
              this.position += parser.position - 2;
            }
          } else if (character.value === "}" && !quote) {
            this.dimension--;
            if (!this.dimension) {
              this.newEntry();
              if (nested) return this.entries;
            }
          } else if (character.value === '"' && !character.escaped) {
            if (quote) this.newEntry(true);
            quote = !quote;
          } else if (character.value === "," && !quote) {
            this.newEntry();
          } else {
            this.record(character.value);
          }
        }
        if (this.dimension !== 0) {
          throw new Error("array dimension not balanced");
        }
        return this.entries;
      }
    };
    function identity(value) {
      return value;
    }
  }
});

// node_modules/pg/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS({
  "node_modules/pg/node_modules/pg-types/lib/arrayParser.js"(exports, module) {
    var array = require_postgres_array();
    module.exports = {
      create: function(source, transform) {
        return {
          parse: function() {
            return array.parse(source, transform);
          }
        };
      }
    };
  }
});

// node_modules/pg/node_modules/postgres-date/index.js
var require_postgres_date = __commonJS({
  "node_modules/pg/node_modules/postgres-date/index.js"(exports, module) {
    "use strict";
    var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
    var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
    var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
    var INFINITY = /^-?infinity$/;
    module.exports = function parseDate(isoDate) {
      if (INFINITY.test(isoDate)) {
        return Number(isoDate.replace("i", "I"));
      }
      var matches = DATE_TIME.exec(isoDate);
      if (!matches) {
        return getDate(isoDate) || null;
      }
      var isBC = !!matches[8];
      var year = parseInt(matches[1], 10);
      if (isBC) {
        year = bcYearToNegativeYear(year);
      }
      var month = parseInt(matches[2], 10) - 1;
      var day = matches[3];
      var hour = parseInt(matches[4], 10);
      var minute = parseInt(matches[5], 10);
      var second = parseInt(matches[6], 10);
      var ms = matches[7];
      ms = ms ? 1e3 * parseFloat(ms) : 0;
      var date;
      var offset = timeZoneOffset(isoDate);
      if (offset != null) {
        date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
        if (is0To99(year)) {
          date.setUTCFullYear(year);
        }
        if (offset !== 0) {
          date.setTime(date.getTime() - offset);
        }
      } else {
        date = new Date(year, month, day, hour, minute, second, ms);
        if (is0To99(year)) {
          date.setFullYear(year);
        }
      }
      return date;
    };
    function getDate(isoDate) {
      var matches = DATE.exec(isoDate);
      if (!matches) {
        return;
      }
      var year = parseInt(matches[1], 10);
      var isBC = !!matches[4];
      if (isBC) {
        year = bcYearToNegativeYear(year);
      }
      var month = parseInt(matches[2], 10) - 1;
      var day = matches[3];
      var date = new Date(year, month, day);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
      return date;
    }
    function timeZoneOffset(isoDate) {
      if (isoDate.endsWith("+00")) {
        return 0;
      }
      var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
      if (!zone) return;
      var type = zone[1];
      if (type === "Z") {
        return 0;
      }
      var sign = type === "-" ? -1 : 1;
      var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
      return offset * sign * 1e3;
    }
    function bcYearToNegativeYear(year) {
      return -(year - 1);
    }
    function is0To99(num) {
      return num >= 0 && num < 100;
    }
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS({
  "node_modules/xtend/mutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/pg/node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS({
  "node_modules/pg/node_modules/postgres-interval/index.js"(exports, module) {
    "use strict";
    var extend = require_mutable();
    module.exports = PostgresInterval;
    function PostgresInterval(raw) {
      if (!(this instanceof PostgresInterval)) {
        return new PostgresInterval(raw);
      }
      extend(this, parse4(raw));
    }
    var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
    PostgresInterval.prototype.toPostgres = function() {
      var filtered = properties.filter(this.hasOwnProperty, this);
      if (this.milliseconds && filtered.indexOf("seconds") < 0) {
        filtered.push("seconds");
      }
      if (filtered.length === 0) return "0";
      return filtered.map(function(property) {
        var value = this[property] || 0;
        if (property === "seconds" && this.milliseconds) {
          value = (value + this.milliseconds / 1e3).toFixed(6).replace(/\.?0+$/, "");
        }
        return value + " " + property;
      }, this).join(" ");
    };
    var propertiesISOEquivalent = {
      years: "Y",
      months: "M",
      days: "D",
      hours: "H",
      minutes: "M",
      seconds: "S"
    };
    var dateProperties = ["years", "months", "days"];
    var timeProperties = ["hours", "minutes", "seconds"];
    PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
      var datePart = dateProperties.map(buildProperty, this).join("");
      var timePart = timeProperties.map(buildProperty, this).join("");
      return "P" + datePart + "T" + timePart;
      function buildProperty(property) {
        var value = this[property] || 0;
        if (property === "seconds" && this.milliseconds) {
          value = (value + this.milliseconds / 1e3).toFixed(6).replace(/0+$/, "");
        }
        return value + propertiesISOEquivalent[property];
      }
    };
    var NUMBER = "([+-]?\\d+)";
    var YEAR = NUMBER + "\\s+years?";
    var MONTH = NUMBER + "\\s+mons?";
    var DAY = NUMBER + "\\s+days?";
    var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
    var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
      return "(" + regexString + ")?";
    }).join("\\s*"));
    var positions = {
      years: 2,
      months: 4,
      days: 6,
      hours: 9,
      minutes: 10,
      seconds: 11,
      milliseconds: 12
    };
    var negatives = ["hours", "minutes", "seconds", "milliseconds"];
    function parseMilliseconds(fraction) {
      var microseconds = fraction + "000000".slice(fraction.length);
      return parseInt(microseconds, 10) / 1e3;
    }
    function parse4(interval) {
      if (!interval) return {};
      var matches = INTERVAL.exec(interval);
      var isNegative = matches[8] === "-";
      return Object.keys(positions).reduce(function(parsed, property) {
        var position = positions[property];
        var value = matches[position];
        if (!value) return parsed;
        value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
        if (!value) return parsed;
        if (isNegative && ~negatives.indexOf(property)) {
          value *= -1;
        }
        parsed[property] = value;
        return parsed;
      }, {});
    }
  }
});

// node_modules/pg/node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS({
  "node_modules/pg/node_modules/postgres-bytea/index.js"(exports, module) {
    "use strict";
    module.exports = function parseBytea(input) {
      if (/^\\x/.test(input)) {
        return new Buffer(input.substr(2), "hex");
      }
      var output = "";
      var i3 = 0;
      while (i3 < input.length) {
        if (input[i3] !== "\\") {
          output += input[i3];
          ++i3;
        } else {
          if (/[0-7]{3}/.test(input.substr(i3 + 1, 3))) {
            output += String.fromCharCode(parseInt(input.substr(i3 + 1, 3), 8));
            i3 += 4;
          } else {
            var backslashes = 1;
            while (i3 + backslashes < input.length && input[i3 + backslashes] === "\\") {
              backslashes++;
            }
            for (var k3 = 0; k3 < Math.floor(backslashes / 2); ++k3) {
              output += "\\";
            }
            i3 += Math.floor(backslashes / 2) * 2;
          }
        }
      }
      return new Buffer(output, "binary");
    };
  }
});

// node_modules/pg/node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS({
  "node_modules/pg/node_modules/pg-types/lib/textParsers.js"(exports, module) {
    var array = require_postgres_array();
    var arrayParser = require_arrayParser();
    var parseDate = require_postgres_date();
    var parseInterval = require_postgres_interval();
    var parseByteA = require_postgres_bytea();
    function allowNull(fn) {
      return function nullAllowed(value) {
        if (value === null) return value;
        return fn(value);
      };
    }
    function parseBool(value) {
      if (value === null) return value;
      return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
    }
    function parseBoolArray(value) {
      if (!value) return null;
      return array.parse(value, parseBool);
    }
    function parseBaseTenInt(string) {
      return parseInt(string, 10);
    }
    function parseIntegerArray(value) {
      if (!value) return null;
      return array.parse(value, allowNull(parseBaseTenInt));
    }
    function parseBigIntegerArray(value) {
      if (!value) return null;
      return array.parse(value, allowNull(function(entry) {
        return parseBigInteger(entry).trim();
      }));
    }
    var parsePointArray = function(value) {
      if (!value) {
        return null;
      }
      var p3 = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parsePoint(entry);
        }
        return entry;
      });
      return p3.parse();
    };
    var parseFloatArray = function(value) {
      if (!value) {
        return null;
      }
      var p3 = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseFloat(entry);
        }
        return entry;
      });
      return p3.parse();
    };
    var parseStringArray = function(value) {
      if (!value) {
        return null;
      }
      var p3 = arrayParser.create(value);
      return p3.parse();
    };
    var parseDateArray = function(value) {
      if (!value) {
        return null;
      }
      var p3 = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseDate(entry);
        }
        return entry;
      });
      return p3.parse();
    };
    var parseIntervalArray = function(value) {
      if (!value) {
        return null;
      }
      var p3 = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseInterval(entry);
        }
        return entry;
      });
      return p3.parse();
    };
    var parseByteAArray = function(value) {
      if (!value) {
        return null;
      }
      return array.parse(value, allowNull(parseByteA));
    };
    var parseInteger = function(value) {
      return parseInt(value, 10);
    };
    var parseBigInteger = function(value) {
      var valStr = String(value);
      if (/^\d+$/.test(valStr)) {
        return valStr;
      }
      return value;
    };
    var parseJsonArray = function(value) {
      if (!value) {
        return null;
      }
      return array.parse(value, allowNull(JSON.parse));
    };
    var parsePoint = function(value) {
      if (value[0] !== "(") {
        return null;
      }
      value = value.substring(1, value.length - 1).split(",");
      return {
        x: parseFloat(value[0]),
        y: parseFloat(value[1])
      };
    };
    var parseCircle = function(value) {
      if (value[0] !== "<" && value[1] !== "(") {
        return null;
      }
      var point = "(";
      var radius = "";
      var pointParsed = false;
      for (var i3 = 2; i3 < value.length - 1; i3++) {
        if (!pointParsed) {
          point += value[i3];
        }
        if (value[i3] === ")") {
          pointParsed = true;
          continue;
        } else if (!pointParsed) {
          continue;
        }
        if (value[i3] === ",") {
          continue;
        }
        radius += value[i3];
      }
      var result = parsePoint(point);
      result.radius = parseFloat(radius);
      return result;
    };
    var init = function(register) {
      register(20, parseBigInteger);
      register(21, parseInteger);
      register(23, parseInteger);
      register(26, parseInteger);
      register(700, parseFloat);
      register(701, parseFloat);
      register(16, parseBool);
      register(1082, parseDate);
      register(1114, parseDate);
      register(1184, parseDate);
      register(600, parsePoint);
      register(651, parseStringArray);
      register(718, parseCircle);
      register(1e3, parseBoolArray);
      register(1001, parseByteAArray);
      register(1005, parseIntegerArray);
      register(1007, parseIntegerArray);
      register(1028, parseIntegerArray);
      register(1016, parseBigIntegerArray);
      register(1017, parsePointArray);
      register(1021, parseFloatArray);
      register(1022, parseFloatArray);
      register(1231, parseFloatArray);
      register(1014, parseStringArray);
      register(1015, parseStringArray);
      register(1008, parseStringArray);
      register(1009, parseStringArray);
      register(1040, parseStringArray);
      register(1041, parseStringArray);
      register(1115, parseDateArray);
      register(1182, parseDateArray);
      register(1185, parseDateArray);
      register(1186, parseInterval);
      register(1187, parseIntervalArray);
      register(17, parseByteA);
      register(114, JSON.parse.bind(JSON));
      register(3802, JSON.parse.bind(JSON));
      register(199, parseJsonArray);
      register(3807, parseJsonArray);
      register(3907, parseStringArray);
      register(2951, parseStringArray);
      register(791, parseStringArray);
      register(1183, parseStringArray);
      register(1270, parseStringArray);
    };
    module.exports = {
      init
    };
  }
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS({
  "node_modules/pg-int8/index.js"(exports, module) {
    "use strict";
    var BASE = 1e6;
    function readInt8(buffer) {
      var high = buffer.readInt32BE(0);
      var low = buffer.readUInt32BE(4);
      var sign = "";
      if (high < 0) {
        high = ~high + (low === 0);
        low = ~low + 1 >>> 0;
        sign = "-";
      }
      var result = "";
      var carry;
      var t3;
      var digits;
      var pad;
      var l3;
      var i3;
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t3 = 4294967296 * carry + low;
        low = t3 / BASE >>> 0;
        digits = "" + (t3 - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l3 = 6 - digits.length;
        for (i3 = 0; i3 < l3; i3++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t3 = 4294967296 * carry + low;
        low = t3 / BASE >>> 0;
        digits = "" + (t3 - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l3 = 6 - digits.length;
        for (i3 = 0; i3 < l3; i3++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t3 = 4294967296 * carry + low;
        low = t3 / BASE >>> 0;
        digits = "" + (t3 - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l3 = 6 - digits.length;
        for (i3 = 0; i3 < l3; i3++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        t3 = 4294967296 * carry + low;
        digits = "" + t3 % BASE;
        return sign + digits + result;
      }
    }
    module.exports = readInt8;
  }
});

// node_modules/pg/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS({
  "node_modules/pg/node_modules/pg-types/lib/binaryParsers.js"(exports, module) {
    var parseInt64 = require_pg_int8();
    var parseBits = function(data, bits, offset, invert, callback) {
      offset = offset || 0;
      invert = invert || false;
      callback = callback || function(lastValue, newValue, bits2) {
        return lastValue * Math.pow(2, bits2) + newValue;
      };
      var offsetBytes = offset >> 3;
      var inv = function(value) {
        if (invert) {
          return ~value & 255;
        }
        return value;
      };
      var mask = 255;
      var firstBits = 8 - offset % 8;
      if (bits < firstBits) {
        mask = 255 << 8 - bits & 255;
        firstBits = bits;
      }
      if (offset) {
        mask = mask >> offset % 8;
      }
      var result = 0;
      if (offset % 8 + bits >= 8) {
        result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
      }
      var bytes = bits + offset >> 3;
      for (var i3 = offsetBytes + 1; i3 < bytes; i3++) {
        result = callback(result, inv(data[i3]), 8);
      }
      var lastBits = (bits + offset) % 8;
      if (lastBits > 0) {
        result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
      }
      return result;
    };
    var parseFloatFromBits = function(data, precisionBits, exponentBits) {
      var bias = Math.pow(2, exponentBits - 1) - 1;
      var sign = parseBits(data, 1);
      var exponent = parseBits(data, exponentBits, 1);
      if (exponent === 0) {
        return 0;
      }
      var precisionBitsCounter = 1;
      var parsePrecisionBits = function(lastValue, newValue, bits) {
        if (lastValue === 0) {
          lastValue = 1;
        }
        for (var i3 = 1; i3 <= bits; i3++) {
          precisionBitsCounter /= 2;
          if ((newValue & 1 << bits - i3) > 0) {
            lastValue += precisionBitsCounter;
          }
        }
        return lastValue;
      };
      var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
      if (exponent == Math.pow(2, exponentBits + 1) - 1) {
        if (mantissa === 0) {
          return sign === 0 ? Infinity : -Infinity;
        }
        return NaN;
      }
      return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
    };
    var parseInt16 = function(value) {
      if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 15, 1, true) + 1);
      }
      return parseBits(value, 15, 1);
    };
    var parseInt32 = function(value) {
      if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 31, 1, true) + 1);
      }
      return parseBits(value, 31, 1);
    };
    var parseFloat32 = function(value) {
      return parseFloatFromBits(value, 23, 8);
    };
    var parseFloat64 = function(value) {
      return parseFloatFromBits(value, 52, 11);
    };
    var parseNumeric = function(value) {
      var sign = parseBits(value, 16, 32);
      if (sign == 49152) {
        return NaN;
      }
      var weight = Math.pow(1e4, parseBits(value, 16, 16));
      var result = 0;
      var digits = [];
      var ndigits = parseBits(value, 16);
      for (var i3 = 0; i3 < ndigits; i3++) {
        result += parseBits(value, 16, 64 + 16 * i3) * weight;
        weight /= 1e4;
      }
      var scale = Math.pow(10, parseBits(value, 16, 48));
      return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
    };
    var parseDate = function(isUTC, value) {
      var sign = parseBits(value, 1);
      var rawValue = parseBits(value, 63, 1);
      var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1e3 + 9466848e5);
      if (!isUTC) {
        result.setTime(result.getTime() + result.getTimezoneOffset() * 6e4);
      }
      result.usec = rawValue % 1e3;
      result.getMicroSeconds = function() {
        return this.usec;
      };
      result.setMicroSeconds = function(value2) {
        this.usec = value2;
      };
      result.getUTCMicroSeconds = function() {
        return this.usec;
      };
      return result;
    };
    var parseArray = function(value) {
      var dim = parseBits(value, 32);
      var flags = parseBits(value, 32, 32);
      var elementType = parseBits(value, 32, 64);
      var offset = 96;
      var dims = [];
      for (var i3 = 0; i3 < dim; i3++) {
        dims[i3] = parseBits(value, 32, offset);
        offset += 32;
        offset += 32;
      }
      var parseElement = function(elementType2) {
        var length = parseBits(value, 32, offset);
        offset += 32;
        if (length == 4294967295) {
          return null;
        }
        var result;
        if (elementType2 == 23 || elementType2 == 20) {
          result = parseBits(value, length * 8, offset);
          offset += length * 8;
          return result;
        } else if (elementType2 == 25) {
          result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
          return result;
        } else {
          console.log("ERROR: ElementType not implemented: " + elementType2);
        }
      };
      var parse4 = function(dimension, elementType2) {
        var array = [];
        var i4;
        if (dimension.length > 1) {
          var count = dimension.shift();
          for (i4 = 0; i4 < count; i4++) {
            array[i4] = parse4(dimension, elementType2);
          }
          dimension.unshift(count);
        } else {
          for (i4 = 0; i4 < dimension[0]; i4++) {
            array[i4] = parseElement(elementType2);
          }
        }
        return array;
      };
      return parse4(dims, elementType);
    };
    var parseText = function(value) {
      return value.toString("utf8");
    };
    var parseBool = function(value) {
      if (value === null) return null;
      return parseBits(value, 8) > 0;
    };
    var init = function(register) {
      register(20, parseInt64);
      register(21, parseInt16);
      register(23, parseInt32);
      register(26, parseInt32);
      register(1700, parseNumeric);
      register(700, parseFloat32);
      register(701, parseFloat64);
      register(16, parseBool);
      register(1114, parseDate.bind(null, false));
      register(1184, parseDate.bind(null, true));
      register(1e3, parseArray);
      register(1007, parseArray);
      register(1016, parseArray);
      register(1008, parseArray);
      register(1009, parseArray);
      register(25, parseText);
    };
    module.exports = {
      init
    };
  }
});

// node_modules/pg/node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/pg/node_modules/pg-types/lib/builtins.js"(exports, module) {
    module.exports = {
      BOOL: 16,
      BYTEA: 17,
      CHAR: 18,
      INT8: 20,
      INT2: 21,
      INT4: 23,
      REGPROC: 24,
      TEXT: 25,
      OID: 26,
      TID: 27,
      XID: 28,
      CID: 29,
      JSON: 114,
      XML: 142,
      PG_NODE_TREE: 194,
      SMGR: 210,
      PATH: 602,
      POLYGON: 604,
      CIDR: 650,
      FLOAT4: 700,
      FLOAT8: 701,
      ABSTIME: 702,
      RELTIME: 703,
      TINTERVAL: 704,
      CIRCLE: 718,
      MACADDR8: 774,
      MONEY: 790,
      MACADDR: 829,
      INET: 869,
      ACLITEM: 1033,
      BPCHAR: 1042,
      VARCHAR: 1043,
      DATE: 1082,
      TIME: 1083,
      TIMESTAMP: 1114,
      TIMESTAMPTZ: 1184,
      INTERVAL: 1186,
      TIMETZ: 1266,
      BIT: 1560,
      VARBIT: 1562,
      NUMERIC: 1700,
      REFCURSOR: 1790,
      REGPROCEDURE: 2202,
      REGOPER: 2203,
      REGOPERATOR: 2204,
      REGCLASS: 2205,
      REGTYPE: 2206,
      UUID: 2950,
      TXID_SNAPSHOT: 2970,
      PG_LSN: 3220,
      PG_NDISTINCT: 3361,
      PG_DEPENDENCIES: 3402,
      TSVECTOR: 3614,
      TSQUERY: 3615,
      GTSVECTOR: 3642,
      REGCONFIG: 3734,
      REGDICTIONARY: 3769,
      JSONB: 3802,
      REGNAMESPACE: 4089,
      REGROLE: 4096
    };
  }
});

// node_modules/pg/node_modules/pg-types/index.js
var require_pg_types = __commonJS({
  "node_modules/pg/node_modules/pg-types/index.js"(exports) {
    var textParsers = require_textParsers();
    var binaryParsers = require_binaryParsers();
    var arrayParser = require_arrayParser();
    var builtinTypes = require_builtins();
    exports.getTypeParser = getTypeParser;
    exports.setTypeParser = setTypeParser;
    exports.arrayParser = arrayParser;
    exports.builtins = builtinTypes;
    var typeParsers = {
      text: {},
      binary: {}
    };
    function noParse(val2) {
      return String(val2);
    }
    function getTypeParser(oid, format) {
      format = format || "text";
      if (!typeParsers[format]) {
        return noParse;
      }
      return typeParsers[format][oid] || noParse;
    }
    function setTypeParser(oid, format, parseFn) {
      if (typeof format == "function") {
        parseFn = format;
        format = "text";
      }
      typeParsers[format][oid] = parseFn;
    }
    textParsers.init(function(oid, converter) {
      typeParsers.text[oid] = converter;
    });
    binaryParsers.init(function(oid, converter) {
      typeParsers.binary[oid] = converter;
    });
  }
});

// node_modules/pg/lib/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/pg/lib/defaults.js"(exports, module) {
    "use strict";
    module.exports = {
      // database host. defaults to localhost
      host: "localhost",
      // database user's name
      user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
      // name of database to connect
      database: void 0,
      // database user's password
      password: null,
      // a Postgres connection string to be used instead of setting individual connection items
      // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
      // in the defaults object.
      connectionString: void 0,
      // database port
      port: 5432,
      // number of rows to return at a time from a prepared statement's
      // portal. 0 will return all rows at once
      rows: 0,
      // binary result mode
      binary: false,
      // Connection pool options - see https://github.com/brianc/node-pg-pool
      // number of connections to use in connection pool
      // 0 will disable connection pooling
      max: 10,
      // max milliseconds a client can go unused before it is removed
      // from the pool and destroyed
      idleTimeoutMillis: 3e4,
      client_encoding: "",
      ssl: false,
      application_name: void 0,
      fallback_application_name: void 0,
      options: void 0,
      parseInputDatesAsUTC: false,
      // max milliseconds any query using this connection will execute for before timing out in error.
      // false=unlimited
      statement_timeout: false,
      // Abort any statement that waits longer than the specified duration in milliseconds while attempting to acquire a lock.
      // false=unlimited
      lock_timeout: false,
      // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds
      // false=unlimited
      idle_in_transaction_session_timeout: false,
      // max milliseconds to wait for query to complete (client side)
      query_timeout: false,
      connect_timeout: 0,
      keepalives: 1,
      keepalives_idle: 0
    };
    var pgTypes = require_pg_types();
    var parseBigInteger = pgTypes.getTypeParser(20, "text");
    var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
    module.exports.__defineSetter__("parseInt8", function(val2) {
      pgTypes.setTypeParser(20, "text", val2 ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
      pgTypes.setTypeParser(1016, "text", val2 ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
    });
  }
});

// node_modules/pg/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/pg/lib/utils.js"(exports, module) {
    "use strict";
    var defaults = require_defaults2();
    function escapeElement(elementRepresentation) {
      var escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      return '"' + escaped + '"';
    }
    function arrayString(val2) {
      var result = "{";
      for (var i3 = 0; i3 < val2.length; i3++) {
        if (i3 > 0) {
          result = result + ",";
        }
        if (val2[i3] === null || typeof val2[i3] === "undefined") {
          result = result + "NULL";
        } else if (Array.isArray(val2[i3])) {
          result = result + arrayString(val2[i3]);
        } else if (ArrayBuffer.isView(val2[i3])) {
          var item = val2[i3];
          if (!(item instanceof Buffer)) {
            var buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
            if (buf.length === item.byteLength) {
              item = buf;
            } else {
              item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
            }
          }
          result += "\\\\x" + item.toString("hex");
        } else {
          result += escapeElement(prepareValue(val2[i3]));
        }
      }
      result = result + "}";
      return result;
    }
    var prepareValue = function(val2, seen) {
      if (val2 == null) {
        return null;
      }
      if (typeof val2 === "object") {
        if (val2 instanceof Buffer) {
          return val2;
        }
        if (ArrayBuffer.isView(val2)) {
          var buf = Buffer.from(val2.buffer, val2.byteOffset, val2.byteLength);
          if (buf.length === val2.byteLength) {
            return buf;
          }
          return buf.slice(val2.byteOffset, val2.byteOffset + val2.byteLength);
        }
        if (val2 instanceof Date) {
          if (defaults.parseInputDatesAsUTC) {
            return dateToStringUTC(val2);
          } else {
            return dateToString(val2);
          }
        }
        if (Array.isArray(val2)) {
          return arrayString(val2);
        }
        return prepareObject(val2, seen);
      }
      return val2.toString();
    };
    function prepareObject(val2, seen) {
      if (val2 && typeof val2.toPostgres === "function") {
        seen = seen || [];
        if (seen.indexOf(val2) !== -1) {
          throw new Error('circular reference detected while preparing "' + val2 + '" for query');
        }
        seen.push(val2);
        return prepareValue(val2.toPostgres(prepareValue), seen);
      }
      return JSON.stringify(val2);
    }
    function dateToString(date) {
      var offset = -date.getTimezoneOffset();
      var year = date.getFullYear();
      var isBCYear = year < 1;
      if (isBCYear) year = Math.abs(year) + 1;
      var ret = String(year).padStart(4, "0") + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + String(date.getMilliseconds()).padStart(3, "0");
      if (offset < 0) {
        ret += "-";
        offset *= -1;
      } else {
        ret += "+";
      }
      ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
      if (isBCYear) ret += " BC";
      return ret;
    }
    function dateToStringUTC(date) {
      var year = date.getUTCFullYear();
      var isBCYear = year < 1;
      if (isBCYear) year = Math.abs(year) + 1;
      var ret = String(year).padStart(4, "0") + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0") + "T" + String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0") + ":" + String(date.getUTCSeconds()).padStart(2, "0") + "." + String(date.getUTCMilliseconds()).padStart(3, "0");
      ret += "+00:00";
      if (isBCYear) ret += " BC";
      return ret;
    }
    function normalizeQueryConfig(config, values, callback) {
      config = typeof config === "string" ? { text: config } : config;
      if (values) {
        if (typeof values === "function") {
          config.callback = values;
        } else {
          config.values = values;
        }
      }
      if (callback) {
        config.callback = callback;
      }
      return config;
    }
    var escapeIdentifier = function(str) {
      return '"' + str.replace(/"/g, '""') + '"';
    };
    var escapeLiteral = function(str) {
      var hasBackslash = false;
      var escaped = "'";
      for (var i3 = 0; i3 < str.length; i3++) {
        var c3 = str[i3];
        if (c3 === "'") {
          escaped += c3 + c3;
        } else if (c3 === "\\") {
          escaped += c3 + c3;
          hasBackslash = true;
        } else {
          escaped += c3;
        }
      }
      escaped += "'";
      if (hasBackslash === true) {
        escaped = " E" + escaped;
      }
      return escaped;
    };
    module.exports = {
      prepareValue: function prepareValueWrapper(value) {
        return prepareValue(value);
      },
      normalizeQueryConfig,
      escapeIdentifier,
      escapeLiteral
    };
  }
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS({
  "node_modules/pg/lib/crypto/utils-legacy.js"(exports, module) {
    "use strict";
    var nodeCrypto = __require("crypto");
    function md53(string) {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    }
    function postgresMd5PasswordHash(user, password, salt) {
      var inner = md53(password + user);
      var outer = md53(Buffer.concat([Buffer.from(inner), salt]));
      return "md5" + outer;
    }
    function sha2562(text) {
      return nodeCrypto.createHash("sha256").update(text).digest();
    }
    function hashByName(hashName, text) {
      hashName = hashName.replace(/(\D)-/, "$1");
      return nodeCrypto.createHash(hashName).update(text).digest();
    }
    function hmacSha256(key, msg) {
      return nodeCrypto.createHmac("sha256", key).update(msg).digest();
    }
    async function deriveKey(password, salt, iterations) {
      return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
    }
    module.exports = {
      postgresMd5PasswordHash,
      randomBytes: nodeCrypto.randomBytes,
      deriveKey,
      sha256: sha2562,
      hashByName,
      hmacSha256,
      md5: md53
    };
  }
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS({
  "node_modules/pg/lib/crypto/utils-webcrypto.js"(exports, module) {
    var nodeCrypto = __require("crypto");
    module.exports = {
      postgresMd5PasswordHash,
      randomBytes,
      deriveKey,
      sha256: sha2562,
      hashByName,
      hmacSha256,
      md5: md53
    };
    var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
    var subtleCrypto = webCrypto.subtle;
    var textEncoder = new TextEncoder();
    function randomBytes(length) {
      return webCrypto.getRandomValues(Buffer.alloc(length));
    }
    async function md53(string) {
      try {
        return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
      } catch (e3) {
        const data = typeof string === "string" ? textEncoder.encode(string) : string;
        const hash = await subtleCrypto.digest("MD5", data);
        return Array.from(new Uint8Array(hash)).map((b3) => b3.toString(16).padStart(2, "0")).join("");
      }
    }
    async function postgresMd5PasswordHash(user, password, salt) {
      var inner = await md53(password + user);
      var outer = await md53(Buffer.concat([Buffer.from(inner), salt]));
      return "md5" + outer;
    }
    async function sha2562(text) {
      return await subtleCrypto.digest("SHA-256", text);
    }
    async function hashByName(hashName, text) {
      return await subtleCrypto.digest(hashName, text);
    }
    async function hmacSha256(keyBuffer, msg) {
      const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
      return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
    }
    async function deriveKey(password, salt, iterations) {
      const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
      const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
      return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
    }
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils5 = __commonJS({
  "node_modules/pg/lib/crypto/utils.js"(exports, module) {
    "use strict";
    var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
    if (useLegacyCrypto) {
      module.exports = require_utils_legacy();
    } else {
      module.exports = require_utils_webcrypto();
    }
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS({
  "node_modules/pg/lib/crypto/cert-signatures.js"(exports, module) {
    function x509Error(msg, cert) {
      throw new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
    }
    function readASN1Length(data, index) {
      let length = data[index++];
      if (length < 128) return { length, index };
      const lengthBytes = length & 127;
      if (lengthBytes > 4) x509Error("bad length", data);
      length = 0;
      for (let i3 = 0; i3 < lengthBytes; i3++) {
        length = length << 8 | data[index++];
      }
      return { length, index };
    }
    function readASN1OID(data, index) {
      if (data[index++] !== 6) x509Error("non-OID data", data);
      const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
      index = indexAfterOIDLength;
      lastIndex = index + OIDLength;
      const byte1 = data[index++];
      let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
      while (index < lastIndex) {
        let value = 0;
        while (index < lastIndex) {
          const nextByte = data[index++];
          value = value << 7 | nextByte & 127;
          if (nextByte < 128) break;
        }
        oid += "." + value;
      }
      return { oid, index };
    }
    function expectASN1Seq(data, index) {
      if (data[index++] !== 48) x509Error("non-sequence data", data);
      return readASN1Length(data, index);
    }
    function signatureAlgorithmHashFromCertificate(data, index) {
      if (index === void 0) index = 0;
      index = expectASN1Seq(data, index).index;
      const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
      index = indexAfterCertInfoLength + certInfoLength;
      index = expectASN1Seq(data, index).index;
      const { oid, index: indexAfterOID } = readASN1OID(data, index);
      switch (oid) {
        // RSA
        case "1.2.840.113549.1.1.4":
          return "MD5";
        case "1.2.840.113549.1.1.5":
          return "SHA-1";
        case "1.2.840.113549.1.1.11":
          return "SHA-256";
        case "1.2.840.113549.1.1.12":
          return "SHA-384";
        case "1.2.840.113549.1.1.13":
          return "SHA-512";
        case "1.2.840.113549.1.1.14":
          return "SHA-224";
        case "1.2.840.113549.1.1.15":
          return "SHA512-224";
        case "1.2.840.113549.1.1.16":
          return "SHA512-256";
        // ECDSA
        case "1.2.840.10045.4.1":
          return "SHA-1";
        case "1.2.840.10045.4.3.1":
          return "SHA-224";
        case "1.2.840.10045.4.3.2":
          return "SHA-256";
        case "1.2.840.10045.4.3.3":
          return "SHA-384";
        case "1.2.840.10045.4.3.4":
          return "SHA-512";
        // RSASSA-PSS: hash is indicated separately
        case "1.2.840.113549.1.1.10":
          index = indexAfterOID;
          index = expectASN1Seq(data, index).index;
          if (data[index++] !== 160) x509Error("non-tag data", data);
          index = readASN1Length(data, index).index;
          index = expectASN1Seq(data, index).index;
          const { oid: hashOID } = readASN1OID(data, index);
          switch (hashOID) {
            // standalone hash OIDs
            case "1.2.840.113549.2.5":
              return "MD5";
            case "1.3.14.3.2.26":
              return "SHA-1";
            case "2.16.840.1.101.3.4.2.1":
              return "SHA-256";
            case "2.16.840.1.101.3.4.2.2":
              return "SHA-384";
            case "2.16.840.1.101.3.4.2.3":
              return "SHA-512";
          }
          x509Error("unknown hash OID " + hashOID, data);
        // Ed25519 -- see https: return//github.com/openssl/openssl/issues/15477
        case "1.3.101.110":
        case "1.3.101.112":
          return "SHA-512";
        // Ed448 -- still not in pg 17.2 (if supported, digest would be SHAKE256 x 64 bytes)
        case "1.3.101.111":
        case "1.3.101.113":
          x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
      }
      x509Error("unknown OID " + oid, data);
    }
    module.exports = { signatureAlgorithmHashFromCertificate };
  }
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS({
  "node_modules/pg/lib/crypto/sasl.js"(exports, module) {
    "use strict";
    var crypto10 = require_utils5();
    var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
    function startSession(mechanisms, stream2) {
      const candidates = ["SCRAM-SHA-256"];
      if (stream2) candidates.unshift("SCRAM-SHA-256-PLUS");
      const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
      if (!mechanism) {
        throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
      }
      if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream2.getPeerCertificate !== "function") {
        throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
      }
      const clientNonce = crypto10.randomBytes(18).toString("base64");
      const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream2 ? "y" : "n";
      return {
        mechanism,
        clientNonce,
        response: gs2Header + ",,n=*,r=" + clientNonce,
        message: "SASLInitialResponse"
      };
    }
    async function continueSession(session, password, serverData, stream2) {
      if (session.message !== "SASLInitialResponse") {
        throw new Error("SASL: Last message was not SASLInitialResponse");
      }
      if (typeof password !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
      }
      if (password === "") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
      }
      if (typeof serverData !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
      }
      const sv = parseServerFirstMessage(serverData);
      if (!sv.nonce.startsWith(session.clientNonce)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
      } else if (sv.nonce.length === session.clientNonce.length) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
      }
      var clientFirstMessageBare = "n=*,r=" + session.clientNonce;
      var serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
      let channelBinding = stream2 ? "eSws" : "biws";
      if (session.mechanism === "SCRAM-SHA-256-PLUS") {
        const peerCert = stream2.getPeerCertificate().raw;
        let hashName = signatureAlgorithmHashFromCertificate(peerCert);
        if (hashName === "MD5" || hashName === "SHA-1") hashName = "SHA-256";
        const certHash = await crypto10.hashByName(hashName, peerCert);
        const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
        channelBinding = bindingData.toString("base64");
      }
      var clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
      var authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
      var saltBytes = Buffer.from(sv.salt, "base64");
      var saltedPassword = await crypto10.deriveKey(password, saltBytes, sv.iteration);
      var clientKey = await crypto10.hmacSha256(saltedPassword, "Client Key");
      var storedKey = await crypto10.sha256(clientKey);
      var clientSignature = await crypto10.hmacSha256(storedKey, authMessage);
      var clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
      var serverKey = await crypto10.hmacSha256(saltedPassword, "Server Key");
      var serverSignatureBytes = await crypto10.hmacSha256(serverKey, authMessage);
      session.message = "SASLResponse";
      session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
      session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
    }
    function finalizeSession(session, serverData) {
      if (session.message !== "SASLResponse") {
        throw new Error("SASL: Last message was not SASLResponse");
      }
      if (typeof serverData !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
      }
      const { serverSignature } = parseServerFinalMessage(serverData);
      if (serverSignature !== session.serverSignature) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
      }
    }
    function isPrintableChars(text) {
      if (typeof text !== "string") {
        throw new TypeError("SASL: text must be a string");
      }
      return text.split("").map((_2, i3) => text.charCodeAt(i3)).every((c3) => c3 >= 33 && c3 <= 43 || c3 >= 45 && c3 <= 126);
    }
    function isBase64(text) {
      return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
    }
    function parseAttributePairs(text) {
      if (typeof text !== "string") {
        throw new TypeError("SASL: attribute pairs text must be a string");
      }
      return new Map(
        text.split(",").map((attrValue) => {
          if (!/^.=/.test(attrValue)) {
            throw new Error("SASL: Invalid attribute pair entry");
          }
          const name = attrValue[0];
          const value = attrValue.substring(2);
          return [name, value];
        })
      );
    }
    function parseServerFirstMessage(data) {
      const attrPairs = parseAttributePairs(data);
      const nonce = attrPairs.get("r");
      if (!nonce) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
      } else if (!isPrintableChars(nonce)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
      }
      const salt = attrPairs.get("s");
      if (!salt) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
      } else if (!isBase64(salt)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
      }
      const iterationText = attrPairs.get("i");
      if (!iterationText) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
      } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
      }
      const iteration = parseInt(iterationText, 10);
      return {
        nonce,
        salt,
        iteration
      };
    }
    function parseServerFinalMessage(serverData) {
      const attrPairs = parseAttributePairs(serverData);
      const serverSignature = attrPairs.get("v");
      if (!serverSignature) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
      } else if (!isBase64(serverSignature)) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
      }
      return {
        serverSignature
      };
    }
    function xorBuffers(a3, b3) {
      if (!Buffer.isBuffer(a3)) {
        throw new TypeError("first argument must be a Buffer");
      }
      if (!Buffer.isBuffer(b3)) {
        throw new TypeError("second argument must be a Buffer");
      }
      if (a3.length !== b3.length) {
        throw new Error("Buffer lengths must match");
      }
      if (a3.length === 0) {
        throw new Error("Buffers cannot be empty");
      }
      return Buffer.from(a3.map((_2, i3) => a3[i3] ^ b3[i3]));
    }
    module.exports = {
      startSession,
      continueSession,
      finalizeSession
    };
  }
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS({
  "node_modules/pg/lib/type-overrides.js"(exports, module) {
    "use strict";
    var types = require_pg_types();
    function TypeOverrides(userTypes) {
      this._types = userTypes || types;
      this.text = {};
      this.binary = {};
    }
    TypeOverrides.prototype.getOverrides = function(format) {
      switch (format) {
        case "text":
          return this.text;
        case "binary":
          return this.binary;
        default:
          return {};
      }
    };
    TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
      if (typeof format === "function") {
        parseFn = format;
        format = "text";
      }
      this.getOverrides(format)[oid] = parseFn;
    };
    TypeOverrides.prototype.getTypeParser = function(oid, format) {
      format = format || "text";
      return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
    };
    module.exports = TypeOverrides;
  }
});

// node_modules/pg/node_modules/pg-connection-string/index.js
var require_pg_connection_string2 = __commonJS({
  "node_modules/pg/node_modules/pg-connection-string/index.js"(exports, module) {
    "use strict";
    function parse4(str) {
      if (str.charAt(0) === "/") {
        const config2 = str.split(" ");
        return { host: config2[0], database: config2[1] };
      }
      const config = {};
      let result;
      let dummyHost = false;
      if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
        str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
      }
      try {
        result = new URL(str, "postgres://base");
      } catch (e3) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
      for (const entry of result.searchParams.entries()) {
        config[entry[0]] = entry[1];
      }
      config.user = config.user || decodeURIComponent(result.username);
      config.password = config.password || decodeURIComponent(result.password);
      if (result.protocol == "socket:") {
        config.host = decodeURI(result.pathname);
        config.database = result.searchParams.get("db");
        config.client_encoding = result.searchParams.get("encoding");
        return config;
      }
      const hostname = dummyHost ? "" : result.hostname;
      if (!config.host) {
        config.host = decodeURIComponent(hostname);
      } else if (hostname && /^%2f/i.test(hostname)) {
        result.pathname = hostname + result.pathname;
      }
      if (!config.port) {
        config.port = result.port;
      }
      const pathname = result.pathname.slice(1) || null;
      config.database = pathname ? decodeURI(pathname) : null;
      if (config.ssl === "true" || config.ssl === "1") {
        config.ssl = true;
      }
      if (config.ssl === "0") {
        config.ssl = false;
      }
      if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
        config.ssl = {};
      }
      const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
      if (config.sslcert) {
        config.ssl.cert = fs.readFileSync(config.sslcert).toString();
      }
      if (config.sslkey) {
        config.ssl.key = fs.readFileSync(config.sslkey).toString();
      }
      if (config.sslrootcert) {
        config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
      }
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
      return config;
    }
    module.exports = parse4;
    parse4.parse = parse4;
  }
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS({
  "node_modules/pg/lib/connection-parameters.js"(exports, module) {
    "use strict";
    var dns = __require("dns");
    var defaults = require_defaults2();
    var parse4 = require_pg_connection_string2().parse;
    var val2 = function(key, config, envVar) {
      if (envVar === void 0) {
        envVar = process.env["PG" + key.toUpperCase()];
      } else if (envVar === false) {
      } else {
        envVar = process.env[envVar];
      }
      return config[key] || envVar || defaults[key];
    };
    var readSSLConfigFromEnvironment = function() {
      switch (process.env.PGSSLMODE) {
        case "disable":
          return false;
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full":
          return true;
        case "no-verify":
          return { rejectUnauthorized: false };
      }
      return defaults.ssl;
    };
    var quoteParamValue = function(value) {
      return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    };
    var add = function(params, config, paramName) {
      var value = config[paramName];
      if (value !== void 0 && value !== null) {
        params.push(paramName + "=" + quoteParamValue(value));
      }
    };
    var ConnectionParameters = class {
      constructor(config) {
        config = typeof config === "string" ? parse4(config) : config || {};
        if (config.connectionString) {
          config = Object.assign({}, config, parse4(config.connectionString));
        }
        this.user = val2("user", config);
        this.database = val2("database", config);
        if (this.database === void 0) {
          this.database = this.user;
        }
        this.port = parseInt(val2("port", config), 10);
        this.host = val2("host", config);
        Object.defineProperty(this, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: val2("password", config)
        });
        this.binary = val2("binary", config);
        this.options = val2("options", config);
        this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
        if (typeof this.ssl === "string") {
          if (this.ssl === "true") {
            this.ssl = true;
          }
        }
        if (this.ssl === "no-verify") {
          this.ssl = { rejectUnauthorized: false };
        }
        if (this.ssl && this.ssl.key) {
          Object.defineProperty(this.ssl, "key", {
            enumerable: false
          });
        }
        this.client_encoding = val2("client_encoding", config);
        this.replication = val2("replication", config);
        this.isDomainSocket = !(this.host || "").indexOf("/");
        this.application_name = val2("application_name", config, "PGAPPNAME");
        this.fallback_application_name = val2("fallback_application_name", config, false);
        this.statement_timeout = val2("statement_timeout", config, false);
        this.lock_timeout = val2("lock_timeout", config, false);
        this.idle_in_transaction_session_timeout = val2("idle_in_transaction_session_timeout", config, false);
        this.query_timeout = val2("query_timeout", config, false);
        if (config.connectionTimeoutMillis === void 0) {
          this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
        } else {
          this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1e3);
        }
        if (config.keepAlive === false) {
          this.keepalives = 0;
        } else if (config.keepAlive === true) {
          this.keepalives = 1;
        }
        if (typeof config.keepAliveInitialDelayMillis === "number") {
          this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1e3);
        }
      }
      getLibpqConnectionString(cb) {
        var params = [];
        add(params, this, "user");
        add(params, this, "password");
        add(params, this, "port");
        add(params, this, "application_name");
        add(params, this, "fallback_application_name");
        add(params, this, "connect_timeout");
        add(params, this, "options");
        var ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
        add(params, ssl, "sslmode");
        add(params, ssl, "sslca");
        add(params, ssl, "sslkey");
        add(params, ssl, "sslcert");
        add(params, ssl, "sslrootcert");
        if (this.database) {
          params.push("dbname=" + quoteParamValue(this.database));
        }
        if (this.replication) {
          params.push("replication=" + quoteParamValue(this.replication));
        }
        if (this.host) {
          params.push("host=" + quoteParamValue(this.host));
        }
        if (this.isDomainSocket) {
          return cb(null, params.join(" "));
        }
        if (this.client_encoding) {
          params.push("client_encoding=" + quoteParamValue(this.client_encoding));
        }
        dns.lookup(this.host, function(err, address) {
          if (err) return cb(err, null);
          params.push("hostaddr=" + quoteParamValue(address));
          return cb(null, params.join(" "));
        });
      }
    };
    module.exports = ConnectionParameters;
  }
});

// node_modules/pg/lib/result.js
var require_result = __commonJS({
  "node_modules/pg/lib/result.js"(exports, module) {
    "use strict";
    var types = require_pg_types();
    var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
    var Result = class {
      constructor(rowMode, types2) {
        this.command = null;
        this.rowCount = null;
        this.oid = null;
        this.rows = [];
        this.fields = [];
        this._parsers = void 0;
        this._types = types2;
        this.RowCtor = null;
        this.rowAsArray = rowMode === "array";
        if (this.rowAsArray) {
          this.parseRow = this._parseRowAsArray;
        }
        this._prebuiltEmptyResultObject = null;
      }
      // adds a command complete message
      addCommandComplete(msg) {
        var match;
        if (msg.text) {
          match = matchRegexp.exec(msg.text);
        } else {
          match = matchRegexp.exec(msg.command);
        }
        if (match) {
          this.command = match[1];
          if (match[3]) {
            this.oid = parseInt(match[2], 10);
            this.rowCount = parseInt(match[3], 10);
          } else if (match[2]) {
            this.rowCount = parseInt(match[2], 10);
          }
        }
      }
      _parseRowAsArray(rowData) {
        var row = new Array(rowData.length);
        for (var i3 = 0, len = rowData.length; i3 < len; i3++) {
          var rawValue = rowData[i3];
          if (rawValue !== null) {
            row[i3] = this._parsers[i3](rawValue);
          } else {
            row[i3] = null;
          }
        }
        return row;
      }
      parseRow(rowData) {
        var row = { ...this._prebuiltEmptyResultObject };
        for (var i3 = 0, len = rowData.length; i3 < len; i3++) {
          var rawValue = rowData[i3];
          var field = this.fields[i3].name;
          if (rawValue !== null) {
            row[field] = this._parsers[i3](rawValue);
          } else {
            row[field] = null;
          }
        }
        return row;
      }
      addRow(row) {
        this.rows.push(row);
      }
      addFields(fieldDescriptions) {
        this.fields = fieldDescriptions;
        if (this.fields.length) {
          this._parsers = new Array(fieldDescriptions.length);
        }
        var row = {};
        for (var i3 = 0; i3 < fieldDescriptions.length; i3++) {
          var desc = fieldDescriptions[i3];
          row[desc.name] = null;
          if (this._types) {
            this._parsers[i3] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
          } else {
            this._parsers[i3] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
          }
        }
        this._prebuiltEmptyResultObject = { ...row };
      }
    };
    module.exports = Result;
  }
});

// node_modules/pg/lib/query.js
var require_query = __commonJS({
  "node_modules/pg/lib/query.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require("events");
    var Result = require_result();
    var utils = require_utils4();
    var Query = class extends EventEmitter {
      constructor(config, values, callback) {
        super();
        config = utils.normalizeQueryConfig(config, values, callback);
        this.text = config.text;
        this.values = config.values;
        this.rows = config.rows;
        this.types = config.types;
        this.name = config.name;
        this.queryMode = config.queryMode;
        this.binary = config.binary;
        this.portal = config.portal || "";
        this.callback = config.callback;
        this._rowMode = config.rowMode;
        if (process.domain && config.callback) {
          this.callback = process.domain.bind(config.callback);
        }
        this._result = new Result(this._rowMode, this.types);
        this._results = this._result;
        this._canceledDueToError = false;
      }
      requiresPreparation() {
        if (this.queryMode === "extended") {
          return true;
        }
        if (this.name) {
          return true;
        }
        if (this.rows) {
          return true;
        }
        if (!this.text) {
          return false;
        }
        if (!this.values) {
          return false;
        }
        return this.values.length > 0;
      }
      _checkForMultirow() {
        if (this._result.command) {
          if (!Array.isArray(this._results)) {
            this._results = [this._result];
          }
          this._result = new Result(this._rowMode, this._result._types);
          this._results.push(this._result);
        }
      }
      // associates row metadata from the supplied
      // message with this query object
      // metadata used when parsing row results
      handleRowDescription(msg) {
        this._checkForMultirow();
        this._result.addFields(msg.fields);
        this._accumulateRows = this.callback || !this.listeners("row").length;
      }
      handleDataRow(msg) {
        let row;
        if (this._canceledDueToError) {
          return;
        }
        try {
          row = this._result.parseRow(msg.fields);
        } catch (err) {
          this._canceledDueToError = err;
          return;
        }
        this.emit("row", row, this._result);
        if (this._accumulateRows) {
          this._result.addRow(row);
        }
      }
      handleCommandComplete(msg, connection) {
        this._checkForMultirow();
        this._result.addCommandComplete(msg);
        if (this.rows) {
          connection.sync();
        }
      }
      // if a named prepared statement is created with empty query text
      // the backend will send an emptyQuery message but *not* a command complete message
      // since we pipeline sync immediately after execute we don't need to do anything here
      // unless we have rows specified, in which case we did not pipeline the intial sync call
      handleEmptyQuery(connection) {
        if (this.rows) {
          connection.sync();
        }
      }
      handleError(err, connection) {
        if (this._canceledDueToError) {
          err = this._canceledDueToError;
          this._canceledDueToError = false;
        }
        if (this.callback) {
          return this.callback(err);
        }
        this.emit("error", err);
      }
      handleReadyForQuery(con) {
        if (this._canceledDueToError) {
          return this.handleError(this._canceledDueToError, con);
        }
        if (this.callback) {
          try {
            this.callback(null, this._results);
          } catch (err) {
            process.nextTick(() => {
              throw err;
            });
          }
        }
        this.emit("end", this._results);
      }
      submit(connection) {
        if (typeof this.text !== "string" && typeof this.name !== "string") {
          return new Error("A query must have either text or a name. Supplying neither is unsupported.");
        }
        const previous = connection.parsedStatements[this.name];
        if (this.text && previous && this.text !== previous) {
          return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
        }
        if (this.values && !Array.isArray(this.values)) {
          return new Error("Query values must be an array");
        }
        if (this.requiresPreparation()) {
          connection.stream.cork && connection.stream.cork();
          try {
            this.prepare(connection);
          } finally {
            connection.stream.uncork && connection.stream.uncork();
          }
        } else {
          connection.query(this.text);
        }
        return null;
      }
      hasBeenParsed(connection) {
        return this.name && connection.parsedStatements[this.name];
      }
      handlePortalSuspended(connection) {
        this._getRows(connection, this.rows);
      }
      _getRows(connection, rows) {
        connection.execute({
          portal: this.portal,
          rows
        });
        if (!rows) {
          connection.sync();
        } else {
          connection.flush();
        }
      }
      // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
      prepare(connection) {
        if (!this.hasBeenParsed(connection)) {
          connection.parse({
            text: this.text,
            name: this.name,
            types: this.types
          });
        }
        try {
          connection.bind({
            portal: this.portal,
            statement: this.name,
            values: this.values,
            binary: this.binary,
            valueMapper: utils.prepareValue
          });
        } catch (err) {
          this.handleError(err, connection);
          return;
        }
        connection.describe({
          type: "P",
          name: this.portal || ""
        });
        this._getRows(connection, this.rows);
      }
      handleCopyInResponse(connection) {
        connection.sendCopyFail("No source stream defined");
      }
      // eslint-disable-next-line no-unused-vars
      handleCopyData(msg, connection) {
      }
    };
    module.exports = Query;
  }
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS({
  "node_modules/pg-protocol/dist/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = void 0;
    exports.parseComplete = {
      name: "parseComplete",
      length: 5
    };
    exports.bindComplete = {
      name: "bindComplete",
      length: 5
    };
    exports.closeComplete = {
      name: "closeComplete",
      length: 5
    };
    exports.noData = {
      name: "noData",
      length: 5
    };
    exports.portalSuspended = {
      name: "portalSuspended",
      length: 5
    };
    exports.replicationStart = {
      name: "replicationStart",
      length: 4
    };
    exports.emptyQuery = {
      name: "emptyQuery",
      length: 4
    };
    exports.copyDone = {
      name: "copyDone",
      length: 4
    };
    var DatabaseError = class extends Error {
      constructor(message, length, name) {
        super(message);
        this.length = length;
        this.name = name;
      }
    };
    exports.DatabaseError = DatabaseError;
    var CopyDataMessage = class {
      constructor(length, chunk) {
        this.length = length;
        this.chunk = chunk;
        this.name = "copyData";
      }
    };
    exports.CopyDataMessage = CopyDataMessage;
    var CopyResponse = class {
      constructor(length, name, binary, columnCount) {
        this.length = length;
        this.name = name;
        this.binary = binary;
        this.columnTypes = new Array(columnCount);
      }
    };
    exports.CopyResponse = CopyResponse;
    var Field = class {
      constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
        this.name = name;
        this.tableID = tableID;
        this.columnID = columnID;
        this.dataTypeID = dataTypeID;
        this.dataTypeSize = dataTypeSize;
        this.dataTypeModifier = dataTypeModifier;
        this.format = format;
      }
    };
    exports.Field = Field;
    var RowDescriptionMessage = class {
      constructor(length, fieldCount) {
        this.length = length;
        this.fieldCount = fieldCount;
        this.name = "rowDescription";
        this.fields = new Array(this.fieldCount);
      }
    };
    exports.RowDescriptionMessage = RowDescriptionMessage;
    var ParameterDescriptionMessage = class {
      constructor(length, parameterCount) {
        this.length = length;
        this.parameterCount = parameterCount;
        this.name = "parameterDescription";
        this.dataTypeIDs = new Array(this.parameterCount);
      }
    };
    exports.ParameterDescriptionMessage = ParameterDescriptionMessage;
    var ParameterStatusMessage = class {
      constructor(length, parameterName, parameterValue) {
        this.length = length;
        this.parameterName = parameterName;
        this.parameterValue = parameterValue;
        this.name = "parameterStatus";
      }
    };
    exports.ParameterStatusMessage = ParameterStatusMessage;
    var AuthenticationMD5Password = class {
      constructor(length, salt) {
        this.length = length;
        this.salt = salt;
        this.name = "authenticationMD5Password";
      }
    };
    exports.AuthenticationMD5Password = AuthenticationMD5Password;
    var BackendKeyDataMessage = class {
      constructor(length, processID, secretKey) {
        this.length = length;
        this.processID = processID;
        this.secretKey = secretKey;
        this.name = "backendKeyData";
      }
    };
    exports.BackendKeyDataMessage = BackendKeyDataMessage;
    var NotificationResponseMessage = class {
      constructor(length, processId, channel, payload) {
        this.length = length;
        this.processId = processId;
        this.channel = channel;
        this.payload = payload;
        this.name = "notification";
      }
    };
    exports.NotificationResponseMessage = NotificationResponseMessage;
    var ReadyForQueryMessage = class {
      constructor(length, status) {
        this.length = length;
        this.status = status;
        this.name = "readyForQuery";
      }
    };
    exports.ReadyForQueryMessage = ReadyForQueryMessage;
    var CommandCompleteMessage = class {
      constructor(length, text) {
        this.length = length;
        this.text = text;
        this.name = "commandComplete";
      }
    };
    exports.CommandCompleteMessage = CommandCompleteMessage;
    var DataRowMessage = class {
      constructor(length, fields) {
        this.length = length;
        this.fields = fields;
        this.name = "dataRow";
        this.fieldCount = fields.length;
      }
    };
    exports.DataRowMessage = DataRowMessage;
    var NoticeMessage = class {
      constructor(length, message) {
        this.length = length;
        this.message = message;
        this.name = "notice";
      }
    };
    exports.NoticeMessage = NoticeMessage;
  }
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS({
  "node_modules/pg-protocol/dist/buffer-writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Writer = void 0;
    var Writer = class {
      constructor(size = 256) {
        this.size = size;
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(size);
      }
      ensure(size) {
        var remaining = this.buffer.length - this.offset;
        if (remaining < size) {
          var oldBuffer = this.buffer;
          var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
          this.buffer = Buffer.allocUnsafe(newSize);
          oldBuffer.copy(this.buffer);
        }
      }
      addInt32(num) {
        this.ensure(4);
        this.buffer[this.offset++] = num >>> 24 & 255;
        this.buffer[this.offset++] = num >>> 16 & 255;
        this.buffer[this.offset++] = num >>> 8 & 255;
        this.buffer[this.offset++] = num >>> 0 & 255;
        return this;
      }
      addInt16(num) {
        this.ensure(2);
        this.buffer[this.offset++] = num >>> 8 & 255;
        this.buffer[this.offset++] = num >>> 0 & 255;
        return this;
      }
      addCString(string) {
        if (!string) {
          this.ensure(1);
        } else {
          var len = Buffer.byteLength(string);
          this.ensure(len + 1);
          this.buffer.write(string, this.offset, "utf-8");
          this.offset += len;
        }
        this.buffer[this.offset++] = 0;
        return this;
      }
      addString(string = "") {
        var len = Buffer.byteLength(string);
        this.ensure(len);
        this.buffer.write(string, this.offset);
        this.offset += len;
        return this;
      }
      add(otherBuffer) {
        this.ensure(otherBuffer.length);
        otherBuffer.copy(this.buffer, this.offset);
        this.offset += otherBuffer.length;
        return this;
      }
      join(code) {
        if (code) {
          this.buffer[this.headerPosition] = code;
          const length = this.offset - (this.headerPosition + 1);
          this.buffer.writeInt32BE(length, this.headerPosition + 1);
        }
        return this.buffer.slice(code ? 0 : 5, this.offset);
      }
      flush(code) {
        var result = this.join(code);
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(this.size);
        return result;
      }
    };
    exports.Writer = Writer;
  }
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS({
  "node_modules/pg-protocol/dist/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialize = void 0;
    var buffer_writer_1 = require_buffer_writer();
    var writer = new buffer_writer_1.Writer();
    var startup = (opts) => {
      writer.addInt16(3).addInt16(0);
      for (const key of Object.keys(opts)) {
        writer.addCString(key).addCString(opts[key]);
      }
      writer.addCString("client_encoding").addCString("UTF8");
      var bodyBuffer = writer.addCString("").flush();
      var length = bodyBuffer.length + 4;
      return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
    };
    var requestSsl = () => {
      const response = Buffer.allocUnsafe(8);
      response.writeInt32BE(8, 0);
      response.writeInt32BE(80877103, 4);
      return response;
    };
    var password = (password2) => {
      return writer.addCString(password2).flush(
        112
        /* code.startup */
      );
    };
    var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
      writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
      return writer.flush(
        112
        /* code.startup */
      );
    };
    var sendSCRAMClientFinalMessage = function(additionalData) {
      return writer.addString(additionalData).flush(
        112
        /* code.startup */
      );
    };
    var query = (text) => {
      return writer.addCString(text).flush(
        81
        /* code.query */
      );
    };
    var emptyArray = [];
    var parse4 = (query2) => {
      const name = query2.name || "";
      if (name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", name, name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const types = query2.types || emptyArray;
      var len = types.length;
      var buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
      for (var i3 = 0; i3 < len; i3++) {
        buffer.addInt32(types[i3]);
      }
      return writer.flush(
        80
        /* code.parse */
      );
    };
    var paramWriter = new buffer_writer_1.Writer();
    var writeValues = function(values, valueMapper) {
      for (let i3 = 0; i3 < values.length; i3++) {
        const mappedVal = valueMapper ? valueMapper(values[i3], i3) : values[i3];
        if (mappedVal == null) {
          writer.addInt16(
            0
            /* ParamType.STRING */
          );
          paramWriter.addInt32(-1);
        } else if (mappedVal instanceof Buffer) {
          writer.addInt16(
            1
            /* ParamType.BINARY */
          );
          paramWriter.addInt32(mappedVal.length);
          paramWriter.add(mappedVal);
        } else {
          writer.addInt16(
            0
            /* ParamType.STRING */
          );
          paramWriter.addInt32(Buffer.byteLength(mappedVal));
          paramWriter.addString(mappedVal);
        }
      }
    };
    var bind = (config = {}) => {
      const portal = config.portal || "";
      const statement = config.statement || "";
      const binary = config.binary || false;
      const values = config.values || emptyArray;
      const len = values.length;
      writer.addCString(portal).addCString(statement);
      writer.addInt16(len);
      writeValues(values, config.valueMapper);
      writer.addInt16(len);
      writer.add(paramWriter.flush());
      writer.addInt16(
        binary ? 1 : 0
        /* ParamType.STRING */
      );
      return writer.flush(
        66
        /* code.bind */
      );
    };
    var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
    var execute = (config) => {
      if (!config || !config.portal && !config.rows) {
        return emptyExecute;
      }
      const portal = config.portal || "";
      const rows = config.rows || 0;
      const portalLength = Buffer.byteLength(portal);
      const len = 4 + portalLength + 1 + 4;
      const buff = Buffer.allocUnsafe(1 + len);
      buff[0] = 69;
      buff.writeInt32BE(len, 1);
      buff.write(portal, 5, "utf-8");
      buff[portalLength + 5] = 0;
      buff.writeUInt32BE(rows, buff.length - 4);
      return buff;
    };
    var cancel = (processID, secretKey) => {
      const buffer = Buffer.allocUnsafe(16);
      buffer.writeInt32BE(16, 0);
      buffer.writeInt16BE(1234, 4);
      buffer.writeInt16BE(5678, 6);
      buffer.writeInt32BE(processID, 8);
      buffer.writeInt32BE(secretKey, 12);
      return buffer;
    };
    var cstringMessage = (code, string) => {
      const stringLen = Buffer.byteLength(string);
      const len = 4 + stringLen + 1;
      const buffer = Buffer.allocUnsafe(1 + len);
      buffer[0] = code;
      buffer.writeInt32BE(len, 1);
      buffer.write(string, 5, "utf-8");
      buffer[len] = 0;
      return buffer;
    };
    var emptyDescribePortal = writer.addCString("P").flush(
      68
      /* code.describe */
    );
    var emptyDescribeStatement = writer.addCString("S").flush(
      68
      /* code.describe */
    );
    var describe = (msg) => {
      return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
    };
    var close = (msg) => {
      const text = `${msg.type}${msg.name || ""}`;
      return cstringMessage(67, text);
    };
    var copyData = (chunk) => {
      return writer.add(chunk).flush(
        100
        /* code.copyFromChunk */
      );
    };
    var copyFail = (message) => {
      return cstringMessage(102, message);
    };
    var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
    var flushBuffer = codeOnlyBuffer(
      72
      /* code.flush */
    );
    var syncBuffer = codeOnlyBuffer(
      83
      /* code.sync */
    );
    var endBuffer = codeOnlyBuffer(
      88
      /* code.end */
    );
    var copyDoneBuffer = codeOnlyBuffer(
      99
      /* code.copyDone */
    );
    var serialize2 = {
      startup,
      password,
      requestSsl,
      sendSASLInitialResponseMessage,
      sendSCRAMClientFinalMessage,
      query,
      parse: parse4,
      bind,
      execute,
      describe,
      close,
      flush: () => flushBuffer,
      sync: () => syncBuffer,
      end: () => endBuffer,
      copyData,
      copyDone: () => copyDoneBuffer,
      copyFail,
      cancel
    };
    exports.serialize = serialize2;
  }
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS({
  "node_modules/pg-protocol/dist/buffer-reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferReader = void 0;
    var emptyBuffer = Buffer.allocUnsafe(0);
    var BufferReader = class {
      constructor(offset = 0) {
        this.offset = offset;
        this.buffer = emptyBuffer;
        this.encoding = "utf-8";
      }
      setBuffer(offset, buffer) {
        this.offset = offset;
        this.buffer = buffer;
      }
      int16() {
        const result = this.buffer.readInt16BE(this.offset);
        this.offset += 2;
        return result;
      }
      byte() {
        const result = this.buffer[this.offset];
        this.offset++;
        return result;
      }
      int32() {
        const result = this.buffer.readInt32BE(this.offset);
        this.offset += 4;
        return result;
      }
      uint32() {
        const result = this.buffer.readUInt32BE(this.offset);
        this.offset += 4;
        return result;
      }
      string(length) {
        const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
        this.offset += length;
        return result;
      }
      cstring() {
        const start = this.offset;
        let end = start;
        while (this.buffer[end++] !== 0) {
        }
        this.offset = end;
        return this.buffer.toString(this.encoding, start, end - 1);
      }
      bytes(length) {
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
      }
    };
    exports.BufferReader = BufferReader;
  }
});

// node_modules/pg-protocol/dist/parser.js
var require_parser2 = __commonJS({
  "node_modules/pg-protocol/dist/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var messages_1 = require_messages();
    var buffer_reader_1 = require_buffer_reader();
    var CODE_LENGTH = 1;
    var LEN_LENGTH = 4;
    var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
    var emptyBuffer = Buffer.allocUnsafe(0);
    var Parser = class {
      constructor(opts) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
        this.reader = new buffer_reader_1.BufferReader();
        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === "binary") {
          throw new Error("Binary mode not supported yet");
        }
        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || "text";
      }
      parse(buffer, callback) {
        this.mergeBuffer(buffer);
        const bufferFullLength = this.bufferOffset + this.bufferLength;
        let offset = this.bufferOffset;
        while (offset + HEADER_LENGTH <= bufferFullLength) {
          const code = this.buffer[offset];
          const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
          const fullMessageLength = CODE_LENGTH + length;
          if (fullMessageLength + offset <= bufferFullLength) {
            const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
            callback(message);
            offset += fullMessageLength;
          } else {
            break;
          }
        }
        if (offset === bufferFullLength) {
          this.buffer = emptyBuffer;
          this.bufferLength = 0;
          this.bufferOffset = 0;
        } else {
          this.bufferLength = bufferFullLength - offset;
          this.bufferOffset = offset;
        }
      }
      mergeBuffer(buffer) {
        if (this.bufferLength > 0) {
          const newLength = this.bufferLength + buffer.byteLength;
          const newFullLength = newLength + this.bufferOffset;
          if (newFullLength > this.buffer.byteLength) {
            let newBuffer;
            if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
              newBuffer = this.buffer;
            } else {
              let newBufferLength = this.buffer.byteLength * 2;
              while (newLength >= newBufferLength) {
                newBufferLength *= 2;
              }
              newBuffer = Buffer.allocUnsafe(newBufferLength);
            }
            this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
            this.buffer = newBuffer;
            this.bufferOffset = 0;
          }
          buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
          this.bufferLength = newLength;
        } else {
          this.buffer = buffer;
          this.bufferOffset = 0;
          this.bufferLength = buffer.byteLength;
        }
      }
      handlePacket(offset, code, length, bytes) {
        switch (code) {
          case 50:
            return messages_1.bindComplete;
          case 49:
            return messages_1.parseComplete;
          case 51:
            return messages_1.closeComplete;
          case 110:
            return messages_1.noData;
          case 115:
            return messages_1.portalSuspended;
          case 99:
            return messages_1.copyDone;
          case 87:
            return messages_1.replicationStart;
          case 73:
            return messages_1.emptyQuery;
          case 68:
            return this.parseDataRowMessage(offset, length, bytes);
          case 67:
            return this.parseCommandCompleteMessage(offset, length, bytes);
          case 90:
            return this.parseReadyForQueryMessage(offset, length, bytes);
          case 65:
            return this.parseNotificationMessage(offset, length, bytes);
          case 82:
            return this.parseAuthenticationResponse(offset, length, bytes);
          case 83:
            return this.parseParameterStatusMessage(offset, length, bytes);
          case 75:
            return this.parseBackendKeyData(offset, length, bytes);
          case 69:
            return this.parseErrorMessage(offset, length, bytes, "error");
          case 78:
            return this.parseErrorMessage(offset, length, bytes, "notice");
          case 84:
            return this.parseRowDescriptionMessage(offset, length, bytes);
          case 116:
            return this.parseParameterDescriptionMessage(offset, length, bytes);
          case 71:
            return this.parseCopyInMessage(offset, length, bytes);
          case 72:
            return this.parseCopyOutMessage(offset, length, bytes);
          case 100:
            return this.parseCopyData(offset, length, bytes);
          default:
            return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
        }
      }
      parseReadyForQueryMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const status = this.reader.string(1);
        return new messages_1.ReadyForQueryMessage(length, status);
      }
      parseCommandCompleteMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const text = this.reader.cstring();
        return new messages_1.CommandCompleteMessage(length, text);
      }
      parseCopyData(offset, length, bytes) {
        const chunk = bytes.slice(offset, offset + (length - 4));
        return new messages_1.CopyDataMessage(length, chunk);
      }
      parseCopyInMessage(offset, length, bytes) {
        return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
      }
      parseCopyOutMessage(offset, length, bytes) {
        return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
      }
      parseCopyMessage(offset, length, bytes, messageName) {
        this.reader.setBuffer(offset, bytes);
        const isBinary = this.reader.byte() !== 0;
        const columnCount = this.reader.int16();
        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
        for (let i3 = 0; i3 < columnCount; i3++) {
          message.columnTypes[i3] = this.reader.int16();
        }
        return message;
      }
      parseNotificationMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const processId = this.reader.int32();
        const channel = this.reader.cstring();
        const payload = this.reader.cstring();
        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
      }
      parseRowDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const message = new messages_1.RowDescriptionMessage(length, fieldCount);
        for (let i3 = 0; i3 < fieldCount; i3++) {
          message.fields[i3] = this.parseField();
        }
        return message;
      }
      parseField() {
        const name = this.reader.cstring();
        const tableID = this.reader.uint32();
        const columnID = this.reader.int16();
        const dataTypeID = this.reader.uint32();
        const dataTypeSize = this.reader.int16();
        const dataTypeModifier = this.reader.int32();
        const mode = this.reader.int16() === 0 ? "text" : "binary";
        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
      }
      parseParameterDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const parameterCount = this.reader.int16();
        const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
        for (let i3 = 0; i3 < parameterCount; i3++) {
          message.dataTypeIDs[i3] = this.reader.int32();
        }
        return message;
      }
      parseDataRowMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const fields = new Array(fieldCount);
        for (let i3 = 0; i3 < fieldCount; i3++) {
          const len = this.reader.int32();
          fields[i3] = len === -1 ? null : this.reader.string(len);
        }
        return new messages_1.DataRowMessage(length, fields);
      }
      parseParameterStatusMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const name = this.reader.cstring();
        const value = this.reader.cstring();
        return new messages_1.ParameterStatusMessage(length, name, value);
      }
      parseBackendKeyData(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const processID = this.reader.int32();
        const secretKey = this.reader.int32();
        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
      }
      parseAuthenticationResponse(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const code = this.reader.int32();
        const message = {
          name: "authenticationOk",
          length
        };
        switch (code) {
          case 0:
            break;
          case 3:
            if (message.length === 8) {
              message.name = "authenticationCleartextPassword";
            }
            break;
          case 5:
            if (message.length === 12) {
              message.name = "authenticationMD5Password";
              const salt = this.reader.bytes(4);
              return new messages_1.AuthenticationMD5Password(length, salt);
            }
            break;
          case 10:
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
            break;
          case 11:
            message.name = "authenticationSASLContinue";
            message.data = this.reader.string(length - 8);
            break;
          case 12:
            message.name = "authenticationSASLFinal";
            message.data = this.reader.string(length - 8);
            break;
          default:
            throw new Error("Unknown authenticationOk message type " + code);
        }
        return message;
      }
      parseErrorMessage(offset, length, bytes, name) {
        this.reader.setBuffer(offset, bytes);
        const fields = {};
        let fieldType = this.reader.string(1);
        while (fieldType !== "\0") {
          fields[fieldType] = this.reader.cstring();
          fieldType = this.reader.string(1);
        }
        const messageValue = fields.M;
        const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
        message.severity = fields.S;
        message.code = fields.C;
        message.detail = fields.D;
        message.hint = fields.H;
        message.position = fields.P;
        message.internalPosition = fields.p;
        message.internalQuery = fields.q;
        message.where = fields.W;
        message.schema = fields.s;
        message.table = fields.t;
        message.column = fields.c;
        message.dataType = fields.d;
        message.constraint = fields.n;
        message.file = fields.F;
        message.line = fields.L;
        message.routine = fields.R;
        return message;
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/pg-protocol/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatabaseError = exports.serialize = exports.parse = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
      return messages_1.DatabaseError;
    } });
    var serializer_1 = require_serializer();
    Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
      return serializer_1.serialize;
    } });
    var parser_1 = require_parser2();
    function parse4(stream2, callback) {
      const parser = new parser_1.Parser();
      stream2.on("data", (buffer) => parser.parse(buffer, callback));
      return new Promise((resolve) => stream2.on("end", () => resolve()));
    }
    exports.parse = parse4;
  }
});

// node_modules/pg-cloudflare/dist/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty_default
});
var empty_default;
var init_empty = __esm({
  "node_modules/pg-cloudflare/dist/empty.js"() {
    empty_default = {};
  }
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS({
  "node_modules/pg/lib/stream.js"(exports, module) {
    var { getStream, getSecureStream } = getStreamFuncs();
    module.exports = {
      /**
       * Get a socket stream compatible with the current runtime environment.
       * @returns {Duplex}
       */
      getStream,
      /**
       * Get a TLS secured socket, compatible with the current environment,
       * using the socket and other settings given in `options`.
       * @returns {Duplex}
       */
      getSecureStream
    };
    function getNodejsStreamFuncs() {
      function getStream2(ssl) {
        const net = __require("net");
        return new net.Socket();
      }
      function getSecureStream2(options) {
        var tls = __require("tls");
        return tls.connect(options);
      }
      return {
        getStream: getStream2,
        getSecureStream: getSecureStream2
      };
    }
    function getCloudflareStreamFuncs() {
      function getStream2(ssl) {
        const { CloudflareSocket } = (init_empty(), __toCommonJS(empty_exports));
        return new CloudflareSocket(ssl);
      }
      function getSecureStream2(options) {
        options.socket.startTls(options);
        return options.socket;
      }
      return {
        getStream: getStream2,
        getSecureStream: getSecureStream2
      };
    }
    function isCloudflareRuntime() {
      if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
        return navigator.userAgent === "Cloudflare-Workers";
      }
      if (typeof Response === "function") {
        const resp = new Response(null, { cf: { thing: true } });
        if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
          return true;
        }
      }
      return false;
    }
    function getStreamFuncs() {
      if (isCloudflareRuntime()) {
        return getCloudflareStreamFuncs();
      }
      return getNodejsStreamFuncs();
    }
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS({
  "node_modules/pg/lib/connection.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var { parse: parse4, serialize: serialize2 } = require_dist2();
    var { getStream, getSecureStream } = require_stream();
    var flushBuffer = serialize2.flush();
    var syncBuffer = serialize2.sync();
    var endBuffer = serialize2.end();
    var Connection = class extends EventEmitter {
      constructor(config) {
        super();
        config = config || {};
        this.stream = config.stream || getStream(config.ssl);
        if (typeof this.stream === "function") {
          this.stream = this.stream(config);
        }
        this._keepAlive = config.keepAlive;
        this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
        this.lastBuffer = false;
        this.parsedStatements = {};
        this.ssl = config.ssl || false;
        this._ending = false;
        this._emitMessage = false;
        var self2 = this;
        this.on("newListener", function(eventName) {
          if (eventName === "message") {
            self2._emitMessage = true;
          }
        });
      }
      connect(port, host) {
        var self2 = this;
        this._connecting = true;
        this.stream.setNoDelay(true);
        this.stream.connect(port, host);
        this.stream.once("connect", function() {
          if (self2._keepAlive) {
            self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
          }
          self2.emit("connect");
        });
        const reportStreamError = function(error) {
          if (self2._ending && (error.code === "ECONNRESET" || error.code === "EPIPE")) {
            return;
          }
          self2.emit("error", error);
        };
        this.stream.on("error", reportStreamError);
        this.stream.on("close", function() {
          self2.emit("end");
        });
        if (!this.ssl) {
          return this.attachListeners(this.stream);
        }
        this.stream.once("data", function(buffer) {
          var responseCode = buffer.toString("utf8");
          switch (responseCode) {
            case "S":
              break;
            case "N":
              self2.stream.end();
              return self2.emit("error", new Error("The server does not support SSL connections"));
            default:
              self2.stream.end();
              return self2.emit("error", new Error("There was an error establishing an SSL connection"));
          }
          const options = {
            socket: self2.stream
          };
          if (self2.ssl !== true) {
            Object.assign(options, self2.ssl);
            if ("key" in self2.ssl) {
              options.key = self2.ssl.key;
            }
          }
          var net = __require("net");
          if (net.isIP && net.isIP(host) === 0) {
            options.servername = host;
          }
          try {
            self2.stream = getSecureStream(options);
          } catch (err) {
            return self2.emit("error", err);
          }
          self2.attachListeners(self2.stream);
          self2.stream.on("error", reportStreamError);
          self2.emit("sslconnect");
        });
      }
      attachListeners(stream2) {
        parse4(stream2, (msg) => {
          var eventName = msg.name === "error" ? "errorMessage" : msg.name;
          if (this._emitMessage) {
            this.emit("message", msg);
          }
          this.emit(eventName, msg);
        });
      }
      requestSsl() {
        this.stream.write(serialize2.requestSsl());
      }
      startup(config) {
        this.stream.write(serialize2.startup(config));
      }
      cancel(processID, secretKey) {
        this._send(serialize2.cancel(processID, secretKey));
      }
      password(password) {
        this._send(serialize2.password(password));
      }
      sendSASLInitialResponseMessage(mechanism, initialResponse) {
        this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
      }
      sendSCRAMClientFinalMessage(additionalData) {
        this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
      }
      _send(buffer) {
        if (!this.stream.writable) {
          return false;
        }
        return this.stream.write(buffer);
      }
      query(text) {
        this._send(serialize2.query(text));
      }
      // send parse message
      parse(query) {
        this._send(serialize2.parse(query));
      }
      // send bind message
      bind(config) {
        this._send(serialize2.bind(config));
      }
      // send execute message
      execute(config) {
        this._send(serialize2.execute(config));
      }
      flush() {
        if (this.stream.writable) {
          this.stream.write(flushBuffer);
        }
      }
      sync() {
        this._ending = true;
        this._send(syncBuffer);
      }
      ref() {
        this.stream.ref();
      }
      unref() {
        this.stream.unref();
      }
      end() {
        this._ending = true;
        if (!this._connecting || !this.stream.writable) {
          this.stream.end();
          return;
        }
        return this.stream.write(endBuffer, () => {
          this.stream.end();
        });
      }
      close(msg) {
        this._send(serialize2.close(msg));
      }
      describe(msg) {
        this._send(serialize2.describe(msg));
      }
      sendCopyFromChunk(chunk) {
        this._send(serialize2.copyData(chunk));
      }
      endCopyFrom() {
        this._send(serialize2.copyDone());
      }
      sendCopyFail(msg) {
        this._send(serialize2.copyFail(msg));
      }
    };
    module.exports = Connection;
  }
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS({
  "node_modules/pgpass/lib/helper.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var Stream = __require("stream").Stream;
    var split = require_split2();
    var util2 = __require("util");
    var defaultPort = 5432;
    var isWin = process.platform === "win32";
    var warnStream = process.stderr;
    var S_IRWXG = 56;
    var S_IRWXO = 7;
    var S_IFMT = 61440;
    var S_IFREG = 32768;
    function isRegFile(mode) {
      return (mode & S_IFMT) == S_IFREG;
    }
    var fieldNames = ["host", "port", "database", "user", "password"];
    var nrOfFields = fieldNames.length;
    var passKey = fieldNames[nrOfFields - 1];
    function warn() {
      var isWritable = warnStream instanceof Stream && true === warnStream.writable;
      if (isWritable) {
        var args = Array.prototype.slice.call(arguments).concat("\n");
        warnStream.write(util2.format.apply(util2, args));
      }
    }
    Object.defineProperty(module.exports, "isWin", {
      get: function() {
        return isWin;
      },
      set: function(val2) {
        isWin = val2;
      }
    });
    module.exports.warnTo = function(stream2) {
      var old = warnStream;
      warnStream = stream2;
      return old;
    };
    module.exports.getFileName = function(rawEnv) {
      var env = rawEnv || process.env;
      var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
      return file;
    };
    module.exports.usePgPass = function(stats, fname) {
      if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
        return false;
      }
      if (isWin) {
        return true;
      }
      fname = fname || "<unkn>";
      if (!isRegFile(stats.mode)) {
        warn('WARNING: password file "%s" is not a plain file', fname);
        return false;
      }
      if (stats.mode & (S_IRWXG | S_IRWXO)) {
        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
        return false;
      }
      return true;
    };
    var matcher = module.exports.match = function(connInfo, entry) {
      return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
        if (idx == 1) {
          if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
            return prev && true;
          }
        }
        return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
      }, true);
    };
    module.exports.getPassword = function(connInfo, stream2, cb) {
      var pass;
      var lineStream = stream2.pipe(split());
      function onLine(line) {
        var entry = parseLine(line);
        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
          pass = entry[passKey];
          lineStream.end();
        }
      }
      var onEnd = function() {
        stream2.destroy();
        cb(pass);
      };
      var onErr = function(err) {
        stream2.destroy();
        warn("WARNING: error on reading file: %s", err);
        cb(void 0);
      };
      stream2.on("error", onErr);
      lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
    };
    var parseLine = module.exports.parseLine = function(line) {
      if (line.length < 11 || line.match(/^\s+#/)) {
        return null;
      }
      var curChar = "";
      var prevChar = "";
      var fieldIdx = 0;
      var startIdx = 0;
      var endIdx = 0;
      var obj = {};
      var isLastField = false;
      var addToObj = function(idx, i0, i1) {
        var field = line.substring(i0, i1);
        if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
          field = field.replace(/\\([:\\])/g, "$1");
        }
        obj[fieldNames[idx]] = field;
      };
      for (var i3 = 0; i3 < line.length - 1; i3 += 1) {
        curChar = line.charAt(i3 + 1);
        prevChar = line.charAt(i3);
        isLastField = fieldIdx == nrOfFields - 1;
        if (isLastField) {
          addToObj(fieldIdx, startIdx);
          break;
        }
        if (i3 >= 0 && curChar == ":" && prevChar !== "\\") {
          addToObj(fieldIdx, startIdx, i3 + 1);
          startIdx = i3 + 2;
          fieldIdx += 1;
        }
      }
      obj = Object.keys(obj).length === nrOfFields ? obj : null;
      return obj;
    };
    var isValidEntry = module.exports.isValidEntry = function(entry) {
      var rules = {
        // host
        0: function(x3) {
          return x3.length > 0;
        },
        // port
        1: function(x3) {
          if (x3 === "*") {
            return true;
          }
          x3 = Number(x3);
          return isFinite(x3) && x3 > 0 && x3 < 9007199254740992 && Math.floor(x3) === x3;
        },
        // database
        2: function(x3) {
          return x3.length > 0;
        },
        // username
        3: function(x3) {
          return x3.length > 0;
        },
        // password
        4: function(x3) {
          return x3.length > 0;
        }
      };
      for (var idx = 0; idx < fieldNames.length; idx += 1) {
        var rule = rules[idx];
        var value = entry[fieldNames[idx]] || "";
        var res = rule(value);
        if (!res) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS({
  "node_modules/pgpass/lib/index.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    var helper = require_helper();
    module.exports = function(connInfo, cb) {
      var file = helper.getFileName();
      fs.stat(file, function(err, stat) {
        if (err || !helper.usePgPass(stat, file)) {
          return cb(void 0);
        }
        var st = fs.createReadStream(file);
        helper.getPassword(connInfo, st, cb);
      });
    };
    module.exports.warnTo = helper.warnTo;
  }
});

// node_modules/pg/lib/client.js
var require_client2 = __commonJS({
  "node_modules/pg/lib/client.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var utils = require_utils4();
    var sasl = require_sasl();
    var TypeOverrides = require_type_overrides();
    var ConnectionParameters = require_connection_parameters();
    var Query = require_query();
    var defaults = require_defaults2();
    var Connection = require_connection();
    var crypto10 = require_utils5();
    var Client = class extends EventEmitter {
      constructor(config) {
        super();
        this.connectionParameters = new ConnectionParameters(config);
        this.user = this.connectionParameters.user;
        this.database = this.connectionParameters.database;
        this.port = this.connectionParameters.port;
        this.host = this.connectionParameters.host;
        Object.defineProperty(this, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: this.connectionParameters.password
        });
        this.replication = this.connectionParameters.replication;
        var c3 = config || {};
        this._Promise = c3.Promise || global.Promise;
        this._types = new TypeOverrides(c3.types);
        this._ending = false;
        this._ended = false;
        this._connecting = false;
        this._connected = false;
        this._connectionError = false;
        this._queryable = true;
        this.enableChannelBinding = Boolean(c3.enableChannelBinding);
        this.connection = c3.connection || new Connection({
          stream: c3.stream,
          ssl: this.connectionParameters.ssl,
          keepAlive: c3.keepAlive || false,
          keepAliveInitialDelayMillis: c3.keepAliveInitialDelayMillis || 0,
          encoding: this.connectionParameters.client_encoding || "utf8"
        });
        this.queryQueue = [];
        this.binary = c3.binary || defaults.binary;
        this.processID = null;
        this.secretKey = null;
        this.ssl = this.connectionParameters.ssl || false;
        if (this.ssl && this.ssl.key) {
          Object.defineProperty(this.ssl, "key", {
            enumerable: false
          });
        }
        this._connectionTimeoutMillis = c3.connectionTimeoutMillis || 0;
      }
      _errorAllQueries(err) {
        const enqueueError = (query) => {
          process.nextTick(() => {
            query.handleError(err, this.connection);
          });
        };
        if (this.activeQuery) {
          enqueueError(this.activeQuery);
          this.activeQuery = null;
        }
        this.queryQueue.forEach(enqueueError);
        this.queryQueue.length = 0;
      }
      _connect(callback) {
        var self2 = this;
        var con = this.connection;
        this._connectionCallback = callback;
        if (this._connecting || this._connected) {
          const err = new Error("Client has already been connected. You cannot reuse a client.");
          process.nextTick(() => {
            callback(err);
          });
          return;
        }
        this._connecting = true;
        if (this._connectionTimeoutMillis > 0) {
          this.connectionTimeoutHandle = setTimeout(() => {
            con._ending = true;
            con.stream.destroy(new Error("timeout expired"));
          }, this._connectionTimeoutMillis);
          if (this.connectionTimeoutHandle.unref) {
            this.connectionTimeoutHandle.unref();
          }
        }
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          if (self2.ssl) {
            con.requestSsl();
          } else {
            con.startup(self2.getStartupConf());
          }
        });
        con.on("sslconnect", function() {
          con.startup(self2.getStartupConf());
        });
        this._attachListeners(con);
        con.once("end", () => {
          const error = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
          clearTimeout(this.connectionTimeoutHandle);
          this._errorAllQueries(error);
          this._ended = true;
          if (!this._ending) {
            if (this._connecting && !this._connectionError) {
              if (this._connectionCallback) {
                this._connectionCallback(error);
              } else {
                this._handleErrorEvent(error);
              }
            } else if (!this._connectionError) {
              this._handleErrorEvent(error);
            }
          }
          process.nextTick(() => {
            this.emit("end");
          });
        });
      }
      connect(callback) {
        if (callback) {
          this._connect(callback);
          return;
        }
        return new this._Promise((resolve, reject) => {
          this._connect((error) => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        });
      }
      _attachListeners(con) {
        con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
        con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
        con.on("authenticationSASL", this._handleAuthSASL.bind(this));
        con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
        con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
        con.on("backendKeyData", this._handleBackendKeyData.bind(this));
        con.on("error", this._handleErrorEvent.bind(this));
        con.on("errorMessage", this._handleErrorMessage.bind(this));
        con.on("readyForQuery", this._handleReadyForQuery.bind(this));
        con.on("notice", this._handleNotice.bind(this));
        con.on("rowDescription", this._handleRowDescription.bind(this));
        con.on("dataRow", this._handleDataRow.bind(this));
        con.on("portalSuspended", this._handlePortalSuspended.bind(this));
        con.on("emptyQuery", this._handleEmptyQuery.bind(this));
        con.on("commandComplete", this._handleCommandComplete.bind(this));
        con.on("parseComplete", this._handleParseComplete.bind(this));
        con.on("copyInResponse", this._handleCopyInResponse.bind(this));
        con.on("copyData", this._handleCopyData.bind(this));
        con.on("notification", this._handleNotification.bind(this));
      }
      // TODO(bmc): deprecate pgpass "built in" integration since this.password can be a function
      // it can be supplied by the user if required - this is a breaking change!
      _checkPgPass(cb) {
        const con = this.connection;
        if (typeof this.password === "function") {
          this._Promise.resolve().then(() => this.password()).then((pass) => {
            if (pass !== void 0) {
              if (typeof pass !== "string") {
                con.emit("error", new TypeError("Password must be a string"));
                return;
              }
              this.connectionParameters.password = this.password = pass;
            } else {
              this.connectionParameters.password = this.password = null;
            }
            cb();
          }).catch((err) => {
            con.emit("error", err);
          });
        } else if (this.password !== null) {
          cb();
        } else {
          try {
            const pgPass = require_lib();
            pgPass(this.connectionParameters, (pass) => {
              if (void 0 !== pass) {
                this.connectionParameters.password = this.password = pass;
              }
              cb();
            });
          } catch (e3) {
            this.emit("error", e3);
          }
        }
      }
      _handleAuthCleartextPassword(msg) {
        this._checkPgPass(() => {
          this.connection.password(this.password);
        });
      }
      _handleAuthMD5Password(msg) {
        this._checkPgPass(async () => {
          try {
            const hashedPassword = await crypto10.postgresMd5PasswordHash(this.user, this.password, msg.salt);
            this.connection.password(hashedPassword);
          } catch (e3) {
            this.emit("error", e3);
          }
        });
      }
      _handleAuthSASL(msg) {
        this._checkPgPass(() => {
          try {
            this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
            this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
          } catch (err) {
            this.connection.emit("error", err);
          }
        });
      }
      async _handleAuthSASLContinue(msg) {
        try {
          await sasl.continueSession(
            this.saslSession,
            this.password,
            msg.data,
            this.enableChannelBinding && this.connection.stream
          );
          this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      }
      _handleAuthSASLFinal(msg) {
        try {
          sasl.finalizeSession(this.saslSession, msg.data);
          this.saslSession = null;
        } catch (err) {
          this.connection.emit("error", err);
        }
      }
      _handleBackendKeyData(msg) {
        this.processID = msg.processID;
        this.secretKey = msg.secretKey;
      }
      _handleReadyForQuery(msg) {
        if (this._connecting) {
          this._connecting = false;
          this._connected = true;
          clearTimeout(this.connectionTimeoutHandle);
          if (this._connectionCallback) {
            this._connectionCallback(null, this);
            this._connectionCallback = null;
          }
          this.emit("connect");
        }
        const { activeQuery } = this;
        this.activeQuery = null;
        this.readyForQuery = true;
        if (activeQuery) {
          activeQuery.handleReadyForQuery(this.connection);
        }
        this._pulseQueryQueue();
      }
      // if we receieve an error event or error message
      // during the connection process we handle it here
      _handleErrorWhileConnecting(err) {
        if (this._connectionError) {
          return;
        }
        this._connectionError = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          return this._connectionCallback(err);
        }
        this.emit("error", err);
      }
      // if we're connected and we receive an error event from the connection
      // this means the socket is dead - do a hard abort of all queries and emit
      // the socket error on the client as well
      _handleErrorEvent(err) {
        if (this._connecting) {
          return this._handleErrorWhileConnecting(err);
        }
        this._queryable = false;
        this._errorAllQueries(err);
        this.emit("error", err);
      }
      // handle error messages from the postgres backend
      _handleErrorMessage(msg) {
        if (this._connecting) {
          return this._handleErrorWhileConnecting(msg);
        }
        const activeQuery = this.activeQuery;
        if (!activeQuery) {
          this._handleErrorEvent(msg);
          return;
        }
        this.activeQuery = null;
        activeQuery.handleError(msg, this.connection);
      }
      _handleRowDescription(msg) {
        this.activeQuery.handleRowDescription(msg);
      }
      _handleDataRow(msg) {
        this.activeQuery.handleDataRow(msg);
      }
      _handlePortalSuspended(msg) {
        this.activeQuery.handlePortalSuspended(this.connection);
      }
      _handleEmptyQuery(msg) {
        this.activeQuery.handleEmptyQuery(this.connection);
      }
      _handleCommandComplete(msg) {
        if (this.activeQuery == null) {
          const error = new Error("Received unexpected commandComplete message from backend.");
          this._handleErrorEvent(error);
          return;
        }
        this.activeQuery.handleCommandComplete(msg, this.connection);
      }
      _handleParseComplete() {
        if (this.activeQuery == null) {
          const error = new Error("Received unexpected parseComplete message from backend.");
          this._handleErrorEvent(error);
          return;
        }
        if (this.activeQuery.name) {
          this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
        }
      }
      _handleCopyInResponse(msg) {
        this.activeQuery.handleCopyInResponse(this.connection);
      }
      _handleCopyData(msg) {
        this.activeQuery.handleCopyData(msg, this.connection);
      }
      _handleNotification(msg) {
        this.emit("notification", msg);
      }
      _handleNotice(msg) {
        this.emit("notice", msg);
      }
      getStartupConf() {
        var params = this.connectionParameters;
        var data = {
          user: params.user,
          database: params.database
        };
        var appName = params.application_name || params.fallback_application_name;
        if (appName) {
          data.application_name = appName;
        }
        if (params.replication) {
          data.replication = "" + params.replication;
        }
        if (params.statement_timeout) {
          data.statement_timeout = String(parseInt(params.statement_timeout, 10));
        }
        if (params.lock_timeout) {
          data.lock_timeout = String(parseInt(params.lock_timeout, 10));
        }
        if (params.idle_in_transaction_session_timeout) {
          data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
        }
        if (params.options) {
          data.options = params.options;
        }
        return data;
      }
      cancel(client, query) {
        if (client.activeQuery === query) {
          var con = this.connection;
          if (this.host && this.host.indexOf("/") === 0) {
            con.connect(this.host + "/.s.PGSQL." + this.port);
          } else {
            con.connect(this.port, this.host);
          }
          con.on("connect", function() {
            con.cancel(client.processID, client.secretKey);
          });
        } else if (client.queryQueue.indexOf(query) !== -1) {
          client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
        }
      }
      setTypeParser(oid, format, parseFn) {
        return this._types.setTypeParser(oid, format, parseFn);
      }
      getTypeParser(oid, format) {
        return this._types.getTypeParser(oid, format);
      }
      // escapeIdentifier and escapeLiteral moved to utility functions & exported
      // on PG
      // re-exported here for backwards compatibility
      escapeIdentifier(str) {
        return utils.escapeIdentifier(str);
      }
      escapeLiteral(str) {
        return utils.escapeLiteral(str);
      }
      _pulseQueryQueue() {
        if (this.readyForQuery === true) {
          this.activeQuery = this.queryQueue.shift();
          if (this.activeQuery) {
            this.readyForQuery = false;
            this.hasExecuted = true;
            const queryError = this.activeQuery.submit(this.connection);
            if (queryError) {
              process.nextTick(() => {
                this.activeQuery.handleError(queryError, this.connection);
                this.readyForQuery = true;
                this._pulseQueryQueue();
              });
            }
          } else if (this.hasExecuted) {
            this.activeQuery = null;
            this.emit("drain");
          }
        }
      }
      query(config, values, callback) {
        var query;
        var result;
        var readTimeout;
        var readTimeoutTimer;
        var queryCallback;
        if (config === null || config === void 0) {
          throw new TypeError("Client was passed a null or undefined query");
        } else if (typeof config.submit === "function") {
          readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
          result = query = config;
          if (typeof values === "function") {
            query.callback = query.callback || values;
          }
        } else {
          readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
          query = new Query(config, values, callback);
          if (!query.callback) {
            result = new this._Promise((resolve, reject) => {
              query.callback = (err, res) => err ? reject(err) : resolve(res);
            }).catch((err) => {
              Error.captureStackTrace(err);
              throw err;
            });
          }
        }
        if (readTimeout) {
          queryCallback = query.callback;
          readTimeoutTimer = setTimeout(() => {
            var error = new Error("Query read timeout");
            process.nextTick(() => {
              query.handleError(error, this.connection);
            });
            queryCallback(error);
            query.callback = () => {
            };
            var index = this.queryQueue.indexOf(query);
            if (index > -1) {
              this.queryQueue.splice(index, 1);
            }
            this._pulseQueryQueue();
          }, readTimeout);
          query.callback = (err, res) => {
            clearTimeout(readTimeoutTimer);
            queryCallback(err, res);
          };
        }
        if (this.binary && !query.binary) {
          query.binary = true;
        }
        if (query._result && !query._result._types) {
          query._result._types = this._types;
        }
        if (!this._queryable) {
          process.nextTick(() => {
            query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
          });
          return result;
        }
        if (this._ending) {
          process.nextTick(() => {
            query.handleError(new Error("Client was closed and is not queryable"), this.connection);
          });
          return result;
        }
        this.queryQueue.push(query);
        this._pulseQueryQueue();
        return result;
      }
      ref() {
        this.connection.ref();
      }
      unref() {
        this.connection.unref();
      }
      end(cb) {
        this._ending = true;
        if (!this.connection._connecting || this._ended) {
          if (cb) {
            cb();
          } else {
            return this._Promise.resolve();
          }
        }
        if (this.activeQuery || !this._queryable) {
          this.connection.stream.destroy();
        } else {
          this.connection.end();
        }
        if (cb) {
          this.connection.once("end", cb);
        } else {
          return new this._Promise((resolve) => {
            this.connection.once("end", resolve);
          });
        }
      }
    };
    Client.Query = Query;
    module.exports = Client;
  }
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS({
  "node_modules/pg-pool/index.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var NOOP = function() {
    };
    var removeWhere = (list, predicate) => {
      const i3 = list.findIndex(predicate);
      return i3 === -1 ? void 0 : list.splice(i3, 1)[0];
    };
    var IdleItem = class {
      constructor(client, idleListener, timeoutId) {
        this.client = client;
        this.idleListener = idleListener;
        this.timeoutId = timeoutId;
      }
    };
    var PendingItem = class {
      constructor(callback) {
        this.callback = callback;
      }
    };
    function throwOnDoubleRelease() {
      throw new Error("Release called on client which has already been released to the pool.");
    }
    function promisify(Promise2, callback) {
      if (callback) {
        return { callback, result: void 0 };
      }
      let rej;
      let res;
      const cb = function(err, client) {
        err ? rej(err) : res(client);
      };
      const result = new Promise2(function(resolve, reject) {
        res = resolve;
        rej = reject;
      }).catch((err) => {
        Error.captureStackTrace(err);
        throw err;
      });
      return { callback: cb, result };
    }
    function makeIdleListener(pool, client) {
      return function idleListener(err) {
        err.client = client;
        client.removeListener("error", idleListener);
        client.on("error", () => {
          pool.log("additional client error after disconnection due to error", err);
        });
        pool._remove(client);
        pool.emit("error", err, client);
      };
    }
    var Pool = class extends EventEmitter {
      constructor(options, Client) {
        super();
        this.options = Object.assign({}, options);
        if (options != null && "password" in options) {
          Object.defineProperty(this.options, "password", {
            configurable: true,
            enumerable: false,
            writable: true,
            value: options.password
          });
        }
        if (options != null && options.ssl && options.ssl.key) {
          Object.defineProperty(this.options.ssl, "key", {
            enumerable: false
          });
        }
        this.options.max = this.options.max || this.options.poolSize || 10;
        this.options.maxUses = this.options.maxUses || Infinity;
        this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
        this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
        this.log = this.options.log || function() {
        };
        this.Client = this.options.Client || Client || require_lib2().Client;
        this.Promise = this.options.Promise || global.Promise;
        if (typeof this.options.idleTimeoutMillis === "undefined") {
          this.options.idleTimeoutMillis = 1e4;
        }
        this._clients = [];
        this._idle = [];
        this._expired = /* @__PURE__ */ new WeakSet();
        this._pendingQueue = [];
        this._endCallback = void 0;
        this.ending = false;
        this.ended = false;
      }
      _isFull() {
        return this._clients.length >= this.options.max;
      }
      _pulseQueue() {
        this.log("pulse queue");
        if (this.ended) {
          this.log("pulse queue ended");
          return;
        }
        if (this.ending) {
          this.log("pulse queue on ending");
          if (this._idle.length) {
            this._idle.slice().map((item) => {
              this._remove(item.client);
            });
          }
          if (!this._clients.length) {
            this.ended = true;
            this._endCallback();
          }
          return;
        }
        if (!this._pendingQueue.length) {
          this.log("no queued requests");
          return;
        }
        if (!this._idle.length && this._isFull()) {
          return;
        }
        const pendingItem = this._pendingQueue.shift();
        if (this._idle.length) {
          const idleItem = this._idle.pop();
          clearTimeout(idleItem.timeoutId);
          const client = idleItem.client;
          client.ref && client.ref();
          const idleListener = idleItem.idleListener;
          return this._acquireClient(client, pendingItem, idleListener, false);
        }
        if (!this._isFull()) {
          return this.newClient(pendingItem);
        }
        throw new Error("unexpected condition");
      }
      _remove(client) {
        const removed = removeWhere(this._idle, (item) => item.client === client);
        if (removed !== void 0) {
          clearTimeout(removed.timeoutId);
        }
        this._clients = this._clients.filter((c3) => c3 !== client);
        client.end();
        this.emit("remove", client);
      }
      connect(cb) {
        if (this.ending) {
          const err = new Error("Cannot use a pool after calling end on the pool");
          return cb ? cb(err) : this.Promise.reject(err);
        }
        const response = promisify(this.Promise, cb);
        const result = response.result;
        if (this._isFull() || this._idle.length) {
          if (this._idle.length) {
            process.nextTick(() => this._pulseQueue());
          }
          if (!this.options.connectionTimeoutMillis) {
            this._pendingQueue.push(new PendingItem(response.callback));
            return result;
          }
          const queueCallback = (err, res, done) => {
            clearTimeout(tid);
            response.callback(err, res, done);
          };
          const pendingItem = new PendingItem(queueCallback);
          const tid = setTimeout(() => {
            removeWhere(this._pendingQueue, (i3) => i3.callback === queueCallback);
            pendingItem.timedOut = true;
            response.callback(new Error("timeout exceeded when trying to connect"));
          }, this.options.connectionTimeoutMillis);
          if (tid.unref) {
            tid.unref();
          }
          this._pendingQueue.push(pendingItem);
          return result;
        }
        this.newClient(new PendingItem(response.callback));
        return result;
      }
      newClient(pendingItem) {
        const client = new this.Client(this.options);
        this._clients.push(client);
        const idleListener = makeIdleListener(this, client);
        this.log("checking client timeout");
        let tid;
        let timeoutHit = false;
        if (this.options.connectionTimeoutMillis) {
          tid = setTimeout(() => {
            this.log("ending client due to timeout");
            timeoutHit = true;
            client.connection ? client.connection.stream.destroy() : client.end();
          }, this.options.connectionTimeoutMillis);
        }
        this.log("connecting new client");
        client.connect((err) => {
          if (tid) {
            clearTimeout(tid);
          }
          client.on("error", idleListener);
          if (err) {
            this.log("client failed to connect", err);
            this._clients = this._clients.filter((c3) => c3 !== client);
            if (timeoutHit) {
              err = new Error("Connection terminated due to connection timeout", { cause: err });
            }
            this._pulseQueue();
            if (!pendingItem.timedOut) {
              pendingItem.callback(err, void 0, NOOP);
            }
          } else {
            this.log("new client connected");
            if (this.options.maxLifetimeSeconds !== 0) {
              const maxLifetimeTimeout = setTimeout(() => {
                this.log("ending client due to expired lifetime");
                this._expired.add(client);
                const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
                if (idleIndex !== -1) {
                  this._acquireClient(
                    client,
                    new PendingItem((err2, client2, clientRelease) => clientRelease()),
                    idleListener,
                    false
                  );
                }
              }, this.options.maxLifetimeSeconds * 1e3);
              maxLifetimeTimeout.unref();
              client.once("end", () => clearTimeout(maxLifetimeTimeout));
            }
            return this._acquireClient(client, pendingItem, idleListener, true);
          }
        });
      }
      // acquire a client for a pending work item
      _acquireClient(client, pendingItem, idleListener, isNew) {
        if (isNew) {
          this.emit("connect", client);
        }
        this.emit("acquire", client);
        client.release = this._releaseOnce(client, idleListener);
        client.removeListener("error", idleListener);
        if (!pendingItem.timedOut) {
          if (isNew && this.options.verify) {
            this.options.verify(client, (err) => {
              if (err) {
                client.release(err);
                return pendingItem.callback(err, void 0, NOOP);
              }
              pendingItem.callback(void 0, client, client.release);
            });
          } else {
            pendingItem.callback(void 0, client, client.release);
          }
        } else {
          if (isNew && this.options.verify) {
            this.options.verify(client, client.release);
          } else {
            client.release();
          }
        }
      }
      // returns a function that wraps _release and throws if called more than once
      _releaseOnce(client, idleListener) {
        let released = false;
        return (err) => {
          if (released) {
            throwOnDoubleRelease();
          }
          released = true;
          this._release(client, idleListener, err);
        };
      }
      // release a client back to the poll, include an error
      // to remove it from the pool
      _release(client, idleListener, err) {
        client.on("error", idleListener);
        client._poolUseCount = (client._poolUseCount || 0) + 1;
        this.emit("release", err, client);
        if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
          if (client._poolUseCount >= this.options.maxUses) {
            this.log("remove expended client");
          }
          this._remove(client);
          this._pulseQueue();
          return;
        }
        const isExpired = this._expired.has(client);
        if (isExpired) {
          this.log("remove expired client");
          this._expired.delete(client);
          this._remove(client);
          this._pulseQueue();
          return;
        }
        let tid;
        if (this.options.idleTimeoutMillis) {
          tid = setTimeout(() => {
            this.log("remove idle client");
            this._remove(client);
          }, this.options.idleTimeoutMillis);
          if (this.options.allowExitOnIdle) {
            tid.unref();
          }
        }
        if (this.options.allowExitOnIdle) {
          client.unref();
        }
        this._idle.push(new IdleItem(client, idleListener, tid));
        this._pulseQueue();
      }
      query(text, values, cb) {
        if (typeof text === "function") {
          const response2 = promisify(this.Promise, text);
          setImmediate(function() {
            return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
          });
          return response2.result;
        }
        if (typeof values === "function") {
          cb = values;
          values = void 0;
        }
        const response = promisify(this.Promise, cb);
        cb = response.callback;
        this.connect((err, client) => {
          if (err) {
            return cb(err);
          }
          let clientReleased = false;
          const onError = (err2) => {
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            cb(err2);
          };
          client.once("error", onError);
          this.log("dispatching query");
          try {
            client.query(text, values, (err2, res) => {
              this.log("query dispatched");
              client.removeListener("error", onError);
              if (clientReleased) {
                return;
              }
              clientReleased = true;
              client.release(err2);
              if (err2) {
                return cb(err2);
              }
              return cb(void 0, res);
            });
          } catch (err2) {
            client.release(err2);
            return cb(err2);
          }
        });
        return response.result;
      }
      end(cb) {
        this.log("ending");
        if (this.ending) {
          const err = new Error("Called end on pool more than once");
          return cb ? cb(err) : this.Promise.reject(err);
        }
        this.ending = true;
        const promised = promisify(this.Promise, cb);
        this._endCallback = promised.callback;
        this._pulseQueue();
        return promised.result;
      }
      get waitingCount() {
        return this._pendingQueue.length;
      }
      get idleCount() {
        return this._idle.length;
      }
      get expiredCount() {
        return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
      }
      get totalCount() {
        return this._clients.length;
      }
    };
    module.exports = Pool;
  }
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS({
  "node_modules/pg/lib/native/query.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var util2 = __require("util");
    var utils = require_utils4();
    var NativeQuery = module.exports = function(config, values, callback) {
      EventEmitter.call(this);
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.callback = config.callback;
      this.state = "new";
      this._arrayMode = config.rowMode === "array";
      this._emitRowEvents = false;
      this.on(
        "newListener",
        function(event) {
          if (event === "row") this._emitRowEvents = true;
        }.bind(this)
      );
    };
    util2.inherits(NativeQuery, EventEmitter);
    var errorFieldMap = {
      /* eslint-disable quote-props */
      sqlState: "code",
      statementPosition: "position",
      messagePrimary: "message",
      context: "where",
      schemaName: "schema",
      tableName: "table",
      columnName: "column",
      dataTypeName: "dataType",
      constraintName: "constraint",
      sourceFile: "file",
      sourceLine: "line",
      sourceFunction: "routine"
    };
    NativeQuery.prototype.handleError = function(err) {
      var fields = this.native.pq.resultErrorFields();
      if (fields) {
        for (var key in fields) {
          var normalizedFieldName = errorFieldMap[key] || key;
          err[normalizedFieldName] = fields[key];
        }
      }
      if (this.callback) {
        this.callback(err);
      } else {
        this.emit("error", err);
      }
      this.state = "error";
    };
    NativeQuery.prototype.then = function(onSuccess, onFailure) {
      return this._getPromise().then(onSuccess, onFailure);
    };
    NativeQuery.prototype.catch = function(callback) {
      return this._getPromise().catch(callback);
    };
    NativeQuery.prototype._getPromise = function() {
      if (this._promise) return this._promise;
      this._promise = new Promise(
        function(resolve, reject) {
          this._once("end", resolve);
          this._once("error", reject);
        }.bind(this)
      );
      return this._promise;
    };
    NativeQuery.prototype.submit = function(client) {
      this.state = "running";
      var self2 = this;
      this.native = client.native;
      client.native.arrayMode = this._arrayMode;
      var after = function(err, rows, results) {
        client.native.arrayMode = false;
        setImmediate(function() {
          self2.emit("_done");
        });
        if (err) {
          return self2.handleError(err);
        }
        if (self2._emitRowEvents) {
          if (results.length > 1) {
            rows.forEach((rowOfRows, i3) => {
              rowOfRows.forEach((row) => {
                self2.emit("row", row, results[i3]);
              });
            });
          } else {
            rows.forEach(function(row) {
              self2.emit("row", row, results);
            });
          }
        }
        self2.state = "end";
        self2.emit("end", results);
        if (self2.callback) {
          self2.callback(null, results);
        }
      };
      if (process.domain) {
        after = process.domain.bind(after);
      }
      if (this.name) {
        if (this.name.length > 63) {
          console.error("Warning! Postgres only supports 63 characters for query names.");
          console.error("You supplied %s (%s)", this.name, this.name.length);
          console.error("This can cause conflicts and silent errors executing queries");
        }
        var values = (this.values || []).map(utils.prepareValue);
        if (client.namedQueries[this.name]) {
          if (this.text && client.namedQueries[this.name] !== this.text) {
            const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
            return after(err);
          }
          return client.native.execute(this.name, values, after);
        }
        return client.native.prepare(this.name, this.text, values.length, function(err) {
          if (err) return after(err);
          client.namedQueries[self2.name] = self2.text;
          return self2.native.execute(self2.name, values, after);
        });
      } else if (this.values) {
        if (!Array.isArray(this.values)) {
          const err = new Error("Query values must be an array");
          return after(err);
        }
        var vals = this.values.map(utils.prepareValue);
        client.native.query(this.text, vals, after);
      } else if (this.queryMode === "extended") {
        client.native.query(this.text, [], after);
      } else {
        client.native.query(this.text, after);
      }
    };
  }
});

// node_modules/pg/lib/native/client.js
var require_client3 = __commonJS({
  "node_modules/pg/lib/native/client.js"(exports, module) {
    "use strict";
    var Native;
    try {
      Native = __require("pg-native");
    } catch (e3) {
      throw e3;
    }
    var TypeOverrides = require_type_overrides();
    var EventEmitter = __require("events").EventEmitter;
    var util2 = __require("util");
    var ConnectionParameters = require_connection_parameters();
    var NativeQuery = require_query2();
    var Client = module.exports = function(config) {
      EventEmitter.call(this);
      config = config || {};
      this._Promise = config.Promise || global.Promise;
      this._types = new TypeOverrides(config.types);
      this.native = new Native({
        types: this._types
      });
      this._queryQueue = [];
      this._ending = false;
      this._connecting = false;
      this._connected = false;
      this._queryable = true;
      var cp = this.connectionParameters = new ConnectionParameters(config);
      if (config.nativeConnectionString) cp.nativeConnectionString = config.nativeConnectionString;
      this.user = cp.user;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: cp.password
      });
      this.database = cp.database;
      this.host = cp.host;
      this.port = cp.port;
      this.namedQueries = {};
    };
    Client.Query = NativeQuery;
    util2.inherits(Client, EventEmitter);
    Client.prototype._errorAllQueries = function(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.native = this.native;
          query.handleError(err);
        });
      };
      if (this._hasActiveQuery()) {
        enqueueError(this._activeQuery);
        this._activeQuery = null;
      }
      this._queryQueue.forEach(enqueueError);
      this._queryQueue.length = 0;
    };
    Client.prototype._connect = function(cb) {
      var self2 = this;
      if (this._connecting) {
        process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
        return;
      }
      this._connecting = true;
      this.connectionParameters.getLibpqConnectionString(function(err, conString) {
        if (self2.connectionParameters.nativeConnectionString) conString = self2.connectionParameters.nativeConnectionString;
        if (err) return cb(err);
        self2.native.connect(conString, function(err2) {
          if (err2) {
            self2.native.end();
            return cb(err2);
          }
          self2._connected = true;
          self2.native.on("error", function(err3) {
            self2._queryable = false;
            self2._errorAllQueries(err3);
            self2.emit("error", err3);
          });
          self2.native.on("notification", function(msg) {
            self2.emit("notification", {
              channel: msg.relname,
              payload: msg.extra
            });
          });
          self2.emit("connect");
          self2._pulseQueryQueue(true);
          cb();
        });
      });
    };
    Client.prototype.connect = function(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error) => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    };
    Client.prototype.query = function(config, values, callback) {
      var query;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;
      if (config === null || config === void 0) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          config.callback = values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new NativeQuery(config, values, callback);
        if (!query.callback) {
          let resolveOut, rejectOut;
          result = new this._Promise((resolve, reject) => {
            resolveOut = resolve;
            rejectOut = reject;
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
          query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          var error = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error, this.connection);
          });
          queryCallback(error);
          query.callback = () => {
          };
          var index = this._queryQueue.indexOf(query);
          if (index > -1) {
            this._queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (!this._queryable) {
        query.native = this.native;
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"));
        });
        return result;
      }
      if (this._ending) {
        query.native = this.native;
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"));
        });
        return result;
      }
      this._queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    };
    Client.prototype.end = function(cb) {
      var self2 = this;
      this._ending = true;
      if (!this._connected) {
        this.once("connect", this.end.bind(this, cb));
      }
      var result;
      if (!cb) {
        result = new this._Promise(function(resolve, reject) {
          cb = (err) => err ? reject(err) : resolve();
        });
      }
      this.native.end(function() {
        self2._errorAllQueries(new Error("Connection terminated"));
        process.nextTick(() => {
          self2.emit("end");
          if (cb) cb();
        });
      });
      return result;
    };
    Client.prototype._hasActiveQuery = function() {
      return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
    };
    Client.prototype._pulseQueryQueue = function(initialConnection) {
      if (!this._connected) {
        return;
      }
      if (this._hasActiveQuery()) {
        return;
      }
      var query = this._queryQueue.shift();
      if (!query) {
        if (!initialConnection) {
          this.emit("drain");
        }
        return;
      }
      this._activeQuery = query;
      query.submit(this);
      var self2 = this;
      query.once("_done", function() {
        self2._pulseQueryQueue();
      });
    };
    Client.prototype.cancel = function(query) {
      if (this._activeQuery === query) {
        this.native.cancel(function() {
        });
      } else if (this._queryQueue.indexOf(query) !== -1) {
        this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
      }
    };
    Client.prototype.ref = function() {
    };
    Client.prototype.unref = function() {
    };
    Client.prototype.setTypeParser = function(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    };
    Client.prototype.getTypeParser = function(oid, format) {
      return this._types.getTypeParser(oid, format);
    };
  }
});

// node_modules/pg/lib/native/index.js
var require_native = __commonJS({
  "node_modules/pg/lib/native/index.js"(exports, module) {
    "use strict";
    module.exports = require_client3();
  }
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/pg/lib/index.js"(exports, module) {
    "use strict";
    var Client = require_client2();
    var defaults = require_defaults2();
    var Connection = require_connection();
    var Pool = require_pg_pool();
    var { DatabaseError } = require_dist2();
    var { escapeIdentifier, escapeLiteral } = require_utils4();
    var poolFactory = (Client2) => {
      return class BoundPool extends Pool {
        constructor(options) {
          super(options, Client2);
        }
      };
    };
    var PG = function(clientConstructor) {
      this.defaults = defaults;
      this.Client = clientConstructor;
      this.Query = this.Client.Query;
      this.Pool = poolFactory(this.Client);
      this._pools = [];
      this.Connection = Connection;
      this.types = require_pg_types();
      this.DatabaseError = DatabaseError;
      this.escapeIdentifier = escapeIdentifier;
      this.escapeLiteral = escapeLiteral;
    };
    if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
      module.exports = new PG(require_native());
    } else {
      module.exports = new PG(Client);
      Object.defineProperty(module.exports, "native", {
        configurable: true,
        enumerable: false,
        get() {
          var native = null;
          try {
            native = new PG(require_native());
          } catch (err) {
            if (err.code !== "MODULE_NOT_FOUND") {
              throw err;
            }
          }
          Object.defineProperty(module.exports, "native", {
            value: native
          });
          return native;
        }
      });
    }
  }
});

// node_modules/knex/lib/dialects/postgres/index.js
var require_postgres = __commonJS({
  "node_modules/knex/lib/dialects/postgres/index.js"(exports, module) {
    var extend = require_extend();
    var map2 = require_map();
    var { promisify } = __require("util");
    var Client = require_client();
    var Transaction = require_pg_transaction();
    var QueryCompiler = require_pg_querycompiler();
    var QueryBuilder = require_pg_querybuilder();
    var ColumnCompiler = require_pg_columncompiler();
    var TableCompiler = require_pg_tablecompiler();
    var ViewCompiler = require_pg_viewcompiler();
    var ViewBuilder = require_pg_viewbuilder();
    var SchemaCompiler = require_pg_compiler();
    var { makeEscape } = require_string();
    var { isString } = require_is();
    var Client_PG = class extends Client {
      constructor(config) {
        super(config);
        if (config.returning) {
          this.defaultReturning = config.returning;
        }
        if (config.searchPath) {
          this.searchPath = config.searchPath;
        }
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      _driver() {
        return require_lib2();
      }
      wrapIdentifierImpl(value) {
        if (value === "*") return value;
        let arrayAccessor = "";
        const arrayAccessorMatch = value.match(/(.*?)(\[[0-9]+\])/);
        if (arrayAccessorMatch) {
          value = arrayAccessorMatch[1];
          arrayAccessor = arrayAccessorMatch[2];
        }
        return `"${value.replace(/"/g, '""')}"${arrayAccessor}`;
      }
      _acquireOnlyConnection() {
        const connection = new this.driver.Client(this.connectionSettings);
        connection.on("error", (err) => {
          connection.__knex__disposed = err;
        });
        connection.on("end", (err) => {
          connection.__knex__disposed = err || "Connection ended unexpectedly";
        });
        return connection.connect().then(() => connection);
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        const client = this;
        return this._acquireOnlyConnection().then(function(connection) {
          if (!client.version) {
            return client.checkVersion(connection).then(function(version3) {
              client.version = version3;
              return connection;
            });
          }
          return connection;
        }).then(async function setSearchPath(connection) {
          await client.setSchemaSearchPath(connection);
          return connection;
        });
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        const end = promisify((cb) => connection.end(cb));
        return end();
      }
      // In PostgreSQL, we need to do a version check to do some feature
      // checking on the database.
      checkVersion(connection) {
        return new Promise((resolve, reject) => {
          connection.query("select version();", (err, resp) => {
            if (err) return reject(err);
            resolve(this._parseVersion(resp.rows[0].version));
          });
        });
      }
      _parseVersion(versionString) {
        return /^PostgreSQL (.*?)( |$)/.exec(versionString)[1];
      }
      // Position the bindings for the query. The escape sequence for question mark
      // is \? (e.g. knex.raw("\\?") since javascript requires '\' to be escaped too...)
      positionBindings(sql) {
        let questionCount = 0;
        return sql.replace(/(\\*)(\?)/g, function(match, escapes) {
          if (escapes.length % 2) {
            return "?";
          } else {
            questionCount++;
            return `$${questionCount}`;
          }
        });
      }
      setSchemaSearchPath(connection, searchPath) {
        let path = searchPath || this.searchPath;
        if (!path) return Promise.resolve(true);
        if (!Array.isArray(path) && !isString(path)) {
          throw new TypeError(
            `knex: Expected searchPath to be Array/String, got: ${typeof path}`
          );
        }
        if (isString(path)) {
          if (path.includes(",")) {
            const parts = path.split(",");
            const arraySyntax = `[${parts.map((searchPath2) => `'${searchPath2}'`).join(", ")}]`;
            this.logger.warn(
              `Detected comma in searchPath "${path}".If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`
            );
          }
          path = [path];
        }
        path = path.map((schemaName) => `"${schemaName}"`).join(",");
        return new Promise(function(resolver, rejecter) {
          connection.query(`set search_path to ${path}`, function(err) {
            if (err) return rejecter(err);
            resolver(true);
          });
        });
      }
      _stream(connection, obj, stream2, options) {
        if (!obj.sql) throw new Error("The query is empty");
        const PGQueryStream = process.browser ? void 0 : __require("pg-query-stream");
        const sql = obj.sql;
        return new Promise(function(resolver, rejecter) {
          const queryStream = connection.query(
            new PGQueryStream(sql, obj.bindings, options),
            (err) => {
              rejecter(err);
            }
          );
          queryStream.on("error", function(error) {
            rejecter(error);
            stream2.emit("error", error);
          });
          stream2.on("end", resolver);
          queryStream.pipe(stream2);
        });
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        let queryConfig = {
          text: obj.sql,
          values: obj.bindings || []
        };
        if (obj.options) {
          queryConfig = extend(queryConfig, obj.options);
        }
        return new Promise(function(resolver, rejecter) {
          connection.query(queryConfig, function(err, response) {
            if (err) return rejecter(err);
            obj.response = response;
            resolver(obj);
          });
        });
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const resp = obj.response;
        if (obj.output) return obj.output.call(runner, resp);
        if (obj.method === "raw") return resp;
        const { returning } = obj;
        if (resp.command === "SELECT") {
          if (obj.method === "first") return resp.rows[0];
          if (obj.method === "pluck") return map2(resp.rows, obj.pluck);
          return resp.rows;
        }
        if (returning) {
          const returns = [];
          for (let i3 = 0, l3 = resp.rows.length; i3 < l3; i3++) {
            const row = resp.rows[i3];
            returns[i3] = row;
          }
          return returns;
        }
        if (resp.command === "UPDATE" || resp.command === "DELETE") {
          return resp.rowCount;
        }
        return resp;
      }
      async cancelQuery(connectionToKill) {
        const conn = await this.acquireRawConnection();
        try {
          return await this._wrappedCancelQueryCall(conn, connectionToKill);
        } finally {
          await this.destroyRawConnection(conn).catch((err) => {
            this.logger.warn(`Connection Error: ${err}`);
          });
        }
      }
      _wrappedCancelQueryCall(conn, connectionToKill) {
        return this._query(conn, {
          sql: "SELECT pg_cancel_backend($1);",
          bindings: [connectionToKill.processID],
          options: {}
        });
      }
      toPathForJson(jsonPath) {
        const PG_PATH_REGEX = /^{.*}$/;
        if (jsonPath.match(PG_PATH_REGEX)) {
          return jsonPath;
        }
        return "{" + jsonPath.replace(/^(\$\.)/, "").replace(".", ",").replace(/\[([0-9]+)]/, ",$1") + // transform [number] to ,number
        "}";
      }
    };
    Object.assign(Client_PG.prototype, {
      dialect: "postgresql",
      driverName: "pg",
      canCancelQuery: true,
      _escapeBinding: makeEscape({
        escapeArray(val2, esc) {
          return esc(arrayString(val2, esc));
        },
        escapeString(str) {
          let hasBackslash = false;
          let escaped = "'";
          for (let i3 = 0; i3 < str.length; i3++) {
            const c3 = str[i3];
            if (c3 === "'") {
              escaped += c3 + c3;
            } else if (c3 === "\\") {
              escaped += c3 + c3;
              hasBackslash = true;
            } else {
              escaped += c3;
            }
          }
          escaped += "'";
          if (hasBackslash === true) {
            escaped = "E" + escaped;
          }
          return escaped;
        },
        escapeObject(val2, prepareValue, timezone, seen = []) {
          if (val2 && typeof val2.toPostgres === "function") {
            seen = seen || [];
            if (seen.indexOf(val2) !== -1) {
              throw new Error(
                `circular reference detected while preparing "${val2}" for query`
              );
            }
            seen.push(val2);
            return prepareValue(val2.toPostgres(prepareValue), seen);
          }
          return JSON.stringify(val2);
        }
      })
    });
    function arrayString(arr, esc) {
      let result = "{";
      for (let i3 = 0; i3 < arr.length; i3++) {
        if (i3 > 0) result += ",";
        const val2 = arr[i3];
        if (val2 === null || typeof val2 === "undefined") {
          result += "NULL";
        } else if (Array.isArray(val2)) {
          result += arrayString(val2, esc);
        } else if (typeof val2 === "number") {
          result += val2;
        } else {
          result += JSON.stringify(typeof val2 === "string" ? val2 : esc(val2));
        }
      }
      return result + "}";
    }
    module.exports = Client_PG;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-querycompiler.js
var require_crdb_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-querycompiler.js"(exports, module) {
    var QueryCompiler_PG = require_pg_querycompiler();
    var {
      columnize: columnize_,
      wrap: wrap_,
      operator: operator_
    } = require_wrappingFormatter();
    var QueryCompiler_CRDB = class extends QueryCompiler_PG {
      truncate() {
        return `truncate ${this.tableName}`;
      }
      upsert() {
        let sql = this._upsert();
        if (sql === "") return sql;
        const { returning } = this.single;
        if (returning) sql += this._returning(returning);
        return {
          sql,
          returning
        };
      }
      _upsert() {
        const upsertValues = this.single.upsert || [];
        const sql = this.with() + `upsert into ${this.tableName} `;
        const body = this._insertBody(upsertValues);
        return body === "" ? "" : sql + body;
      }
      _groupOrder(item, type) {
        return this._basicGroupOrder(item, type);
      }
      whereJsonPath(statement) {
        let castValue = "";
        if (!isNaN(statement.value) && parseInt(statement.value)) {
          castValue = "::int";
        } else if (!isNaN(statement.value) && parseFloat(statement.value)) {
          castValue = "::float";
        } else {
          castValue = " #>> '{}'";
        }
        return `json_extract_path(${this._columnClause(
          statement
        )}, ${this.client.toArrayPathFromJsonPath(
          statement.jsonPath,
          this.builder,
          this.bindingsHolder
        )})${castValue} ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      // Json common functions
      _jsonExtract(nameFunction, params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        return extractions.map((extraction) => {
          const jsonCol = `json_extract_path(${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this.client.toArrayPathFromJsonPath(
            extraction.path || extraction[1],
            this.builder,
            this.bindingsHolder
          )})`;
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      _onJsonPathEquals(nameJoinFunction, clause) {
        return "json_extract_path(" + wrap_(
          clause.columnFirst,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.toArrayPathFromJsonPath(
          clause.jsonPathFirst,
          this.builder,
          this.bindingsHolder
        ) + ") = json_extract_path(" + wrap_(
          clause.columnSecond,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.toArrayPathFromJsonPath(
          clause.jsonPathSecond,
          this.builder,
          this.bindingsHolder
        ) + ")";
      }
    };
    module.exports = QueryCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-columncompiler.js
var require_crdb_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-columncompiler.js"(exports, module) {
    var ColumnCompiler_PG = require_pg_columncompiler();
    var ColumnCompiler_CRDB = class extends ColumnCompiler_PG {
      uuid(options = { primaryKey: false }) {
        return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key default gen_random_uuid()" : "");
      }
    };
    module.exports = ColumnCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-tablecompiler.js
var require_crdb_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-tablecompiler.js"(exports, module) {
    var TableCompiler = require_pg_tablecompiler();
    var TableCompiler_CRDB = class extends TableCompiler {
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          for (const col of colCompilers) {
            this.client.logger.warn(
              "Experimental alter column in use, see issue: https://github.com/cockroachdb/cockroach/issues/49329"
            );
            this.pushQuery({
              sql: "SET enable_experimental_alter_column_type_general = true",
              bindings: []
            });
            super._addColumn(col);
          }
        } else {
          super.addColumns(columns, prefix);
        }
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${this.tableName()}@${indexName} cascade `);
      }
    };
    module.exports = TableCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-viewcompiler.js
var require_crdb_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-viewcompiler.js"(exports, module) {
    var ViewCompiler_PG = require_pg_viewcompiler();
    var ViewCompiler_CRDB = class extends ViewCompiler_PG {
      renameColumn(from, to) {
        throw new Error("rename column of views is not supported by this dialect.");
      }
      defaultTo(column, defaultValue) {
        throw new Error(
          "change default values of views is not supported by this dialect."
        );
      }
    };
    module.exports = ViewCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-querybuilder.js
var require_crdb_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-querybuilder.js"(exports, module) {
    var QueryBuilder = require_querybuilder();
    var isEmpty = require_isEmpty();
    module.exports = class QueryBuilder_CockroachDB extends QueryBuilder {
      upsert(values, returning, options) {
        this._method = "upsert";
        if (!isEmpty(returning)) this.returning(returning, options);
        this._single.upsert = values;
        return this;
      }
    };
  }
});

// node_modules/knex/lib/dialects/cockroachdb/index.js
var require_cockroachdb = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/index.js"(exports, module) {
    var Client_PostgreSQL = require_postgres();
    var Transaction = require_pg_transaction();
    var QueryCompiler = require_crdb_querycompiler();
    var ColumnCompiler = require_crdb_columncompiler();
    var TableCompiler = require_crdb_tablecompiler();
    var ViewCompiler = require_crdb_viewcompiler();
    var QueryBuilder = require_crdb_querybuilder();
    var Client_CockroachDB = class extends Client_PostgreSQL {
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      _parseVersion(versionString) {
        return versionString.split(" ")[2];
      }
      async cancelQuery(connectionToKill) {
        try {
          return await this._wrappedCancelQueryCall(null, connectionToKill);
        } catch (err) {
          this.logger.warn(`Connection Error: ${err}`);
          throw err;
        }
      }
      _wrappedCancelQueryCall(emptyConnection, connectionToKill) {
        if (connectionToKill.activeQuery.processID === 0 && connectionToKill.activeQuery.secretKey === 0) {
          return;
        }
        return connectionToKill.cancel(
          connectionToKill,
          connectionToKill.activeQuery
        );
      }
      toArrayPathFromJsonPath(jsonPath, builder, bindingsHolder) {
        return jsonPath.replace(/^(\$\.)/, "").replace(/\[([0-9]+)]/, ".$1").split(".").map(
          function(v6) {
            return this.parameter(v6, builder, bindingsHolder);
          }.bind(this)
        ).join(", ");
      }
    };
    Object.assign(Client_CockroachDB.prototype, {
      // The "dialect", for reference elsewhere.
      driverName: "cockroachdb"
    });
    module.exports = Client_CockroachDB;
  }
});

// node_modules/lodash/isNil.js
var require_isNil = __commonJS({
  "node_modules/lodash/isNil.js"(exports, module) {
    function isNil(value) {
      return value == null;
    }
    module.exports = isNil;
  }
});

// node_modules/knex/lib/dialects/mssql/mssql-formatter.js
var require_mssql_formatter = __commonJS({
  "node_modules/knex/lib/dialects/mssql/mssql-formatter.js"(exports, module) {
    var Formatter = require_formatter();
    var MSSQL_Formatter = class extends Formatter {
      // Accepts a string or array of columns to wrap as appropriate.
      columnizeWithPrefix(prefix, target) {
        const columns = typeof target === "string" ? [target] : target;
        let str = "", i3 = -1;
        while (++i3 < columns.length) {
          if (i3 > 0) str += ", ";
          str += prefix + this.wrap(columns[i3]);
        }
        return str;
      }
      /**
       * Returns its argument with single quotes escaped, so it can be included into a single-quoted string.
       *
       * For example, it converts "has'quote" to "has''quote".
       *
       * This assumes QUOTED_IDENTIFIER ON so it is only ' that need escaping,
       * never ", because " cannot be used to quote a string when that's on;
       * otherwise we'd need to be aware of whether the string is quoted with " or '.
       *
       * This assumption is consistent with the SQL Knex generates.
       * @param {string} string
       * @returns {string}
       */
      escapingStringDelimiters(string) {
        return (string || "").replace(/'/g, "''");
      }
    };
    module.exports = MSSQL_Formatter;
  }
});

// node_modules/knex/lib/dialects/mssql/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/knex/lib/dialects/mssql/transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var debug = require_src()("knex:tx");
    var Transaction_MSSQL = class extends Transaction {
      begin(conn) {
        debug("transaction::begin id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.beginTransaction(
            (err) => {
              if (err) {
                debug(
                  "transaction::begin error id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              resolve();
            },
            this.outerTx ? this.txid : void 0,
            nameToIsolationLevelEnum(this.isolationLevel)
          );
        }).then(this._resolver, this._rejecter);
      }
      savepoint(conn) {
        debug("transaction::savepoint id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.saveTransaction(
            (err) => {
              if (err) {
                debug(
                  "transaction::savepoint id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              this.trxClient.emit("query", {
                __knexUid: this.trxClient.__knexUid,
                __knexTxId: this.trxClient.__knexTxId,
                autogenerated: true,
                sql: this.outerTx ? `SAVE TRANSACTION [${this.txid}]` : `SAVE TRANSACTION`
              });
              resolve();
            },
            this.outerTx ? this.txid : void 0
          );
        });
      }
      commit(conn, value) {
        debug("transaction::commit id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.commitTransaction(
            (err) => {
              if (err) {
                debug(
                  "transaction::commit error id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              this._completed = true;
              resolve(value);
            },
            this.outerTx ? this.txid : void 0
          );
        }).then(() => this._resolver(value), this._rejecter);
      }
      release(conn, value) {
        return this._resolver(value);
      }
      rollback(conn, error) {
        this._completed = true;
        debug("transaction::rollback id=%s", this.txid);
        return new Promise((_resolve, reject) => {
          if (!conn.inTransaction) {
            return reject(
              error || new Error("Transaction rejected with non-error: undefined")
            );
          }
          if (conn.state.name !== "LoggedIn") {
            return reject(
              new Error(
                "Can't rollback transaction. There is a request in progress"
              )
            );
          }
          conn.rollbackTransaction(
            (err) => {
              if (err) {
                debug(
                  "transaction::rollback error id=%s message=%s",
                  this.txid,
                  err.message
                );
              }
              reject(
                err || error || new Error("Transaction rejected with non-error: undefined")
              );
            },
            this.outerTx ? this.txid : void 0
          );
        }).catch((err) => {
          if (!error && this.doNotRejectOnRollback) {
            this._resolver();
            return;
          }
          if (error) {
            try {
              err.originalError = error;
            } catch (_err) {
            }
          }
          this._rejecter(err);
        });
      }
      rollbackTo(conn, error) {
        return this.rollback(conn, error).then(
          () => void this.trxClient.emit("query", {
            __knexUid: this.trxClient.__knexUid,
            __knexTxId: this.trxClient.__knexTxId,
            autogenerated: true,
            sql: `ROLLBACK TRANSACTION`
          })
        );
      }
    };
    module.exports = Transaction_MSSQL;
    function nameToIsolationLevelEnum(level) {
      if (!level) return;
      level = level.toUpperCase().replace(" ", "_");
      const knownEnum = isolationEnum[level];
      if (!knownEnum) {
        throw new Error(
          `Unknown Isolation level, was expecting one of: ${JSON.stringify(
            humanReadableKeys
          )}`
        );
      }
      return knownEnum;
    }
    var isolationEnum = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var humanReadableKeys = Object.keys(isolationEnum).map(
      (key) => key.toLowerCase().replace("_", " ")
    );
  }
});

// node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js
var require_mssql_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js"(exports, module) {
    var QueryCompiler = require_querycompiler();
    var compact = require_compact();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var Raw = require_raw();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var components = [
      "comments",
      "columns",
      "join",
      "lock",
      "where",
      "union",
      "group",
      "having",
      "order",
      "limit",
      "offset"
    ];
    var QueryCompiler_MSSQL = class extends QueryCompiler {
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { onConflict } = this.single;
        if (onConflict) {
          throw new Error(".onConflict() is not supported for mssql.");
        }
        this._emptyInsertValue = "default values";
      }
      with() {
        const undoList = [];
        if (this.grouped.with) {
          for (const stmt of this.grouped.with) {
            if (stmt.recursive) {
              undoList.push(stmt);
              stmt.recursive = false;
            }
          }
        }
        const result = super.with();
        for (const stmt of undoList) {
          stmt.recursive = true;
        }
        return result;
      }
      select() {
        const sql = this.with();
        const statements = components.map((component) => this[component](this));
        return sql + compact(statements).join(" ");
      }
      //#region Insert
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.insertWithTriggers();
        } else {
          return this.standardInsert();
        }
      }
      insertWithTriggers() {
        const insertValues = this.single.insert || [];
        const { returning } = this.single;
        let sql = this.with() + `${this._buildTempTable(returning)}insert into ${this.tableName} `;
        const returningSql = returning ? this._returning("insert", returning, true) + " " : "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql + returningSql + this._emptyInsertValue + this._buildReturningSelect(returning),
            returning
          };
        }
        sql += this._buildInsertData(insertValues, returningSql);
        if (returning) {
          sql += this._buildReturningSelect(returning);
        }
        return {
          sql,
          returning
        };
      }
      _buildInsertData(insertValues, returningSql) {
        let sql = "";
        const insertData = this._prepInsert(insertValues);
        if (typeof insertData === "string") {
          sql += insertData;
        } else {
          if (insertData.columns.length) {
            sql += `(${this.formatter.columnize(insertData.columns)}`;
            sql += `) ${returningSql}values (` + this._buildInsertValues(insertData) + ")";
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql += returningSql + this._emptyInsertValue;
          } else {
            return "";
          }
        }
        return sql;
      }
      standardInsert() {
        const insertValues = this.single.insert || [];
        let sql = this.with() + `insert into ${this.tableName} `;
        const { returning } = this.single;
        const returningSql = returning ? this._returning("insert", returning) + " " : "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql + returningSql + this._emptyInsertValue,
            returning
          };
        }
        sql += this._buildInsertData(insertValues, returningSql);
        return {
          sql,
          returning
        };
      }
      //#endregion
      //#region Update
      // Compiles an `update` query, allowing for a return value.
      update() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.updateWithTriggers();
        } else {
          return this.standardUpdate();
        }
      }
      updateWithTriggers() {
        const top = this.top();
        const withSQL = this.with();
        const updates = this._prepUpdate(this.single.update);
        const join = this.join();
        const where = this.where();
        const order = this.order();
        const { returning } = this.single;
        const declaredTemp = this._buildTempTable(returning);
        return {
          sql: withSQL + declaredTemp + `update ${top ? top + " " : ""}${this.tableName} set ` + updates.join(", ") + (returning ? ` ${this._returning("update", returning, true)}` : "") + (join ? ` from ${this.tableName} ${join}` : "") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : this._buildReturningSelect(returning)),
          returning: returning || "@@rowcount"
        };
      }
      _formatGroupsItemValue(value, nulls) {
        const column = super._formatGroupsItemValue(value);
        if (nulls && !(value instanceof Raw)) {
          const collNulls = `IIF(${column} is null,`;
          if (nulls === "first") {
            return `${collNulls}0,1)`;
          } else if (nulls === "last") {
            return `${collNulls}1,0)`;
          }
        }
        return column;
      }
      standardUpdate() {
        const top = this.top();
        const withSQL = this.with();
        const updates = this._prepUpdate(this.single.update);
        const join = this.join();
        const where = this.where();
        const order = this.order();
        const { returning } = this.single;
        return {
          sql: withSQL + `update ${top ? top + " " : ""}${this.tableName} set ` + updates.join(", ") + (returning ? ` ${this._returning("update", returning)}` : "") + (join ? ` from ${this.tableName} ${join}` : "") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : ""),
          returning: returning || "@@rowcount"
        };
      }
      //#endregion
      //#region Delete
      // Compiles a `delete` query.
      del() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.deleteWithTriggers();
        } else {
          return this.standardDelete();
        }
      }
      deleteWithTriggers() {
        const withSQL = this.with();
        const { tableName } = this;
        const wheres = this.where();
        const joins = this.join();
        const { returning } = this.single;
        const returningStr = returning ? ` ${this._returning("del", returning, true)}` : "";
        const deleteSelector = joins ? `${tableName}${returningStr} ` : "";
        return {
          sql: withSQL + `${this._buildTempTable(
            returning
          )}delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : "") + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : this._buildReturningSelect(returning)),
          returning: returning || "@@rowcount"
        };
      }
      standardDelete() {
        const withSQL = this.with();
        const { tableName } = this;
        const wheres = this.where();
        const joins = this.join();
        const { returning } = this.single;
        const returningStr = returning ? ` ${this._returning("del", returning)}` : "";
        const deleteSelector = joins ? `${tableName}${returningStr} ` : "";
        return {
          sql: withSQL + `delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : "") + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : ""),
          returning: returning || "@@rowcount"
        };
      }
      //#endregion
      // Compiles the columns in the query, specifying if an item was distinct.
      columns() {
        let distinctClause = "";
        if (this.onlyUnions()) return "";
        const top = this.top();
        const hints = this._hintComments();
        const columns = this.grouped.columns || [];
        let i3 = -1, sql = [];
        if (columns) {
          while (++i3 < columns.length) {
            const stmt = columns[i3];
            if (stmt.distinct) distinctClause = "distinct ";
            if (stmt.distinctOn) {
              distinctClause = this.distinctOn(stmt.value);
              continue;
            }
            if (stmt.type === "aggregate") {
              sql.push(...this.aggregate(stmt));
            } else if (stmt.type === "aggregateRaw") {
              sql.push(this.aggregateRaw(stmt));
            } else if (stmt.type === "analytic") {
              sql.push(this.analytic(stmt));
            } else if (stmt.type === "json") {
              sql.push(this.json(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql.push(this.formatter.columnize(stmt.value));
            }
          }
        }
        if (sql.length === 0) sql = ["*"];
        const select = this.onlyJson() ? "" : "select ";
        return `${select}${hints}${distinctClause}` + (top ? top + " " : "") + sql.join(", ") + (this.tableName ? ` from ${this.tableName}` : "");
      }
      _returning(method, value, withTrigger) {
        switch (method) {
          case "update":
          case "insert":
            return value ? `output ${this.formatter.columnizeWithPrefix("inserted.", value)}${withTrigger ? " into #out" : ""}` : "";
          case "del":
            return value ? `output ${this.formatter.columnizeWithPrefix("deleted.", value)}${withTrigger ? " into #out" : ""}` : "";
          case "rowcount":
            return value ? ";select @@rowcount" : "";
        }
      }
      _buildTempTable(values) {
        if (values && values.length > 0) {
          let selections = "";
          if (Array.isArray(values)) {
            selections = values.map((value) => `[t].${this.formatter.columnize(value)}`).join(",");
          } else {
            selections = `[t].${this.formatter.columnize(values)}`;
          }
          let sql = `select top(0) ${selections} into #out `;
          sql += `from ${this.tableName} as t `;
          sql += `left join ${this.tableName} on 0=1;`;
          return sql;
        }
        return "";
      }
      _buildReturningSelect(values) {
        if (values && values.length > 0) {
          let selections = "";
          if (Array.isArray(values)) {
            selections = values.map((value) => `${this.formatter.columnize(value)}`).join(",");
          } else {
            selections = this.formatter.columnize(values);
          }
          let sql = `; select ${selections} from #out; `;
          sql += `drop table #out;`;
          return sql;
        }
        return "";
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate table ${this.tableName}`;
      }
      forUpdate() {
        return "with (UPDLOCK)";
      }
      forShare() {
        return "with (HOLDLOCK)";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        let sql = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from INFORMATION_SCHEMA.COLUMNS where table_name = ? and table_catalog = ?`;
        const bindings = [table, this.client.database()];
        if (schema) {
          sql += " and table_schema = ?";
          bindings.push(schema);
        } else {
          sql += ` and table_schema = 'dbo'`;
        }
        return {
          sql,
          bindings,
          output(resp) {
            const out = resp.reduce((columns, val2) => {
              columns[val2[0].value] = {
                defaultValue: val2[1].value,
                type: val2[2].value,
                maxLength: val2[3].value,
                nullable: val2[4].value === "YES"
              };
              return columns;
            }, {});
            return column && out[column] || out;
          }
        };
      }
      top() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        const noOffset = !this.single.offset;
        if (noLimit || !noOffset) return "";
        return `top (${this._getValueOrParameterFromAttribute("limit")})`;
      }
      limit() {
        return "";
      }
      offset() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        const noOffset = !this.single.offset;
        if (noOffset) return "";
        let offset = `offset ${noOffset ? "0" : this._getValueOrParameterFromAttribute("offset")} rows`;
        if (!noLimit) {
          offset += ` fetch next ${this._getValueOrParameterFromAttribute(
            "limit"
          )} rows only`;
        }
        return offset;
      }
      whereLike(statement) {
        return `${this._columnClause(
          statement
        )} collate SQL_Latin1_General_CP1_CS_AS ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      whereILike(statement) {
        return `${this._columnClause(
          statement
        )} collate SQL_Latin1_General_CP1_CI_AS ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      jsonExtract(params) {
        return this._jsonExtract(
          params.singleValue ? "JSON_VALUE" : "JSON_QUERY",
          params
        );
      }
      jsonSet(params) {
        return this._jsonSet("JSON_MODIFY", params);
      }
      jsonInsert(params) {
        return this._jsonSet("JSON_MODIFY", params);
      }
      jsonRemove(params) {
        const jsonCol = `JSON_MODIFY(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )}, NULL)`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("JSON_VALUE", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by MSSQL"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error("Json subset where clause not actually supported by MSSQL");
      }
      _getExtracts(statement, operator) {
        const column = columnize_(
          statement.column,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return (Array.isArray(statement.values) ? statement.values : [statement.values]).map(function(value) {
          return "JSON_VALUE(" + column + "," + this.client.parameter(value, this.builder, this.bindingsHolder) + ")";
        }, this).join(operator);
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("JSON_VALUE", clause);
      }
    };
    module.exports = QueryCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-compiler.js
var require_mssql_compiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-compiler.js"(exports, module) {
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_MSSQL = class extends SchemaCompiler {
      constructor(client, builder) {
        super(client, builder);
      }
      dropTableIfExists(tableName) {
        const name = this.formatter.wrap(prefixedTableName(this.schema, tableName));
        this.pushQuery(
          `if object_id('${name}', 'U') is not null DROP TABLE ${name}`
        );
      }
      dropViewIfExists(viewName) {
        const name = this.formatter.wrap(prefixedTableName(this.schema, viewName));
        this.pushQuery(
          `if object_id('${name}', 'V') is not null DROP VIEW ${name}`
        );
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            prefixedTableName(this.schema, tableName),
            this.builder,
            this.bindingsHolder
          )}, ${this.client.parameter(to, this.builder, this.bindingsHolder)}`
        );
      }
      renameView(viewTable, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            prefixedTableName(this.schema, viewTable),
            this.builder,
            this.bindingsHolder
          )}, ${this.client.parameter(to, this.builder, this.bindingsHolder)}`
        );
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        const formattedTable = this.client.parameter(
          prefixedTableName(this.schema, tableName),
          this.builder,
          this.bindingsHolder
        );
        const bindings = [tableName];
        let sql = `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ${formattedTable}`;
        if (this.schema) {
          sql += " AND TABLE_SCHEMA = ?";
          bindings.push(this.schema);
        }
        this.pushQuery({ sql, bindings, output: (resp) => resp.length > 0 });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        const formattedColumn = this.client.parameter(
          column,
          this.builder,
          this.bindingsHolder
        );
        const formattedTable = this.client.parameter(
          this.formatter.wrap(prefixedTableName(this.schema, tableName)),
          this.builder,
          this.bindingsHolder
        );
        const sql = `select object_id from sys.columns where name = ${formattedColumn} and object_id = object_id(${formattedTable})`;
        this.pushQuery({ sql, output: (resp) => resp.length > 0 });
      }
    };
    SchemaCompiler_MSSQL.prototype.dropTablePrefix = "DROP TABLE ";
    function prefixedTableName(prefix, table) {
      return prefix ? `${prefix}.${table}` : table;
    }
    module.exports = SchemaCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-tablecompiler.js
var require_mssql_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-tablecompiler.js"(exports, module) {
    var TableCompiler = require_tablecompiler();
    var helpers = require_helpers();
    var { isObject } = require_is();
    var TableCompiler_MSSQL = class extends TableCompiler {
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      createQuery(columns, ifNot, like) {
        let createStatement = ifNot ? `if object_id('${this.tableName()}', 'U') is null ` : "";
        if (like) {
          createStatement += `SELECT * INTO ${this.tableName()} FROM ${this.tableNameLike()} WHERE 0=1`;
        } else {
          createStatement += "CREATE TABLE " + this.tableName() + (this._formatting ? " (\n    " : " (") + columns.sql.join(this._formatting ? ",\n    " : ", ") + this._addChecks() + ")";
        }
        this.pushQuery(createStatement);
        if (this.single.comment) {
          this.comment(this.single.comment);
        }
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      comment(comment) {
        if (!comment) {
          return;
        }
        if (comment.length > 7500 / 2) {
          this.client.logger.warn(
            "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
          );
        }
        const value = this.formatter.escapingStringDelimiters(comment);
        const level0name = this.formatter.escapingStringDelimiters(
          this.schemaNameRaw || "dbo"
        );
        const level1name = this.formatter.escapingStringDelimiters(
          this.tableNameRaw
        );
        const args = `N'MS_Description', N'${value}', N'Schema', N'${level0name}', N'Table', N'${level1name}'`;
        const isAlreadyDefined = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${level0name}', N'Table', N'${level1name}', NULL, NULL))`;
        this.pushQuery(
          `IF ${isAlreadyDefined}
  EXEC sys.sp_updateextendedproperty ${args}
ELSE
  EXEC sys.sp_addextendedproperty ${args}`
        );
      }
      // Compiles column add.  Multiple columns need only one ADD clause (not one ADD per column) so core addColumns doesn't work.  #1348
      addColumns(columns, prefix) {
        prefix = prefix || this.addColumnsPrefix;
        if (columns.sql.length > 0) {
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + prefix + columns.sql.join(", "),
            bindings: columns.bindings
          });
        }
      }
      alterColumns(columns, colBuilder) {
        for (let i3 = 0, l3 = colBuilder.length; i3 < l3; i3++) {
          const builder = colBuilder[i3];
          if (builder.modified.defaultTo) {
            const schema = this.schemaNameRaw || "dbo";
            const baseQuery = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${schema}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${builder.getColumnName()}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
            this.pushQuery(baseQuery);
          }
        }
        columns.sql.forEach((sql) => {
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + (this.lowerCase ? this.alterColumnPrefix.toLowerCase() : this.alterColumnPrefix) + sql,
            bindings: columns.bindings
          });
        });
      }
      // Compiles column drop.  Multiple columns need only one DROP clause (not one DROP per column) so core dropColumn doesn't work.  #1348
      dropColumn() {
        const _this2 = this;
        const columns = helpers.normalizeArr.apply(null, arguments);
        const columnsArray = Array.isArray(columns) ? columns : [columns];
        const drops = columnsArray.map((column) => _this2.formatter.wrap(column));
        const schema = this.schemaNameRaw || "dbo";
        for (const column of columns) {
          const baseQuery = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${schema}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${column}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
          this.pushQuery(baseQuery);
        }
        this.pushQuery(
          (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + this.dropColumnPrefix + drops.join(", ")
        );
      }
      changeType() {
      }
      // Renames a column on the table.
      renameColumn(from, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            this.tableName() + "." + from,
            this.tableBuilder,
            this.bindingsHolder
          )}, ${this.client.parameter(
            to,
            this.tableBuilder,
            this.bindingsHolder
          )}, 'COLUMN'`
        );
      }
      dropFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref) {
            const constraintName = formatter.wrap(ref.CONSTRAINT_NAME);
            const tableName = formatter.wrap(ref.TABLE_NAME);
            return runner.query({
              sql: `ALTER TABLE ${tableName} DROP CONSTRAINT ${constraintName}`
            });
          })
        );
      }
      createFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref) {
            const tableName = formatter.wrap(ref.TABLE_NAME);
            const keyName = formatter.wrap(ref.CONSTRAINT_NAME);
            const column = formatter.columnize(ref.COLUMN_NAME);
            const references = formatter.columnize(ref.REFERENCED_COLUMN_NAME);
            const inTable = formatter.wrap(ref.REFERENCED_TABLE_NAME);
            const onUpdate = ` ON UPDATE ${ref.UPDATE_RULE}`;
            const onDelete = ` ON DELETE ${ref.DELETE_RULE}`;
            return runner.query({
              sql: `ALTER TABLE ${tableName} ADD CONSTRAINT ${keyName} FOREIGN KEY (` + column + ") REFERENCES " + inTable + " (" + references + ")" + onUpdate + onDelete
            });
          })
        );
      }
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        let predicate;
        if (isObject(options)) {
          ({ predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `CREATE INDEX ${indexName} ON ${this.tableName()} (${this.formatter.columnize(
            columns
          )})${predicateQuery}`
        );
      }
      /**
       * Create a primary key.
       *
       * @param {undefined | string | string[]} columns
       * @param {string | {constraintName: string, deferrable?: 'not deferrable'|'deferred'|'immediate' }} constraintName
       */
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mssql: primary key constraint [${constraintName}] will not be deferrable ${deferrable} because mssql does not support deferred constraints.`
          );
        }
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (!this.forCreate) {
          this.pushQuery(
            `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${constraintName} PRIMARY KEY (${this.formatter.columnize(
              columns
            )})`
          );
        } else {
          this.pushQuery(
            `CONSTRAINT ${constraintName} PRIMARY KEY (${this.formatter.columnize(
              columns
            )})`
          );
        }
      }
      /**
       * Create a unique index.
       *
       * @param {string | string[]} columns
       * @param {string | {indexName: undefined | string, deferrable?: 'not deferrable'|'deferred'|'immediate', useConstraint?: true|false, predicate?: QueryBuilder }} indexName
       */
      unique(columns, indexName) {
        let deferrable;
        let useConstraint = false;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, useConstraint, predicate } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mssql: unique index [${indexName}] will not be deferrable ${deferrable} because mssql does not support deferred constraints.`
          );
        }
        if (useConstraint && predicate) {
          throw new Error("mssql cannot create constraint with predicate");
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        if (!Array.isArray(columns)) {
          columns = [columns];
        }
        if (useConstraint) {
          this.pushQuery(
            `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${indexName} UNIQUE (${this.formatter.columnize(
              columns
            )})`
          );
        } else {
          const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : " WHERE " + columns.map((column) => this.formatter.columnize(column) + " IS NOT NULL").join(" AND ");
          this.pushQuery(
            `CREATE UNIQUE INDEX ${indexName} ON ${this.tableName()} (${this.formatter.columnize(
              columns
            )})${predicateQuery}`
          );
        }
      }
      // Compile a drop index command.
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`DROP INDEX ${indexName} ON ${this.tableName()}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${indexName}`
        );
      }
      // Compile a drop primary key command.
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        this.pushQuery(
          `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${constraintName}`
        );
      }
      // Compile a drop unique key command.
      dropUnique(column, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, column);
        this.pushQuery(`DROP INDEX ${indexName} ON ${this.tableName()}`);
      }
    };
    TableCompiler_MSSQL.prototype.createAlterTableMethods = ["foreign", "primary"];
    TableCompiler_MSSQL.prototype.lowerCase = false;
    TableCompiler_MSSQL.prototype.addColumnsPrefix = "ADD ";
    TableCompiler_MSSQL.prototype.dropColumnPrefix = "DROP COLUMN ";
    TableCompiler_MSSQL.prototype.alterColumnPrefix = "ALTER COLUMN ";
    module.exports = TableCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-viewcompiler.js
var require_mssql_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-viewcompiler.js"(exports, module) {
    var ViewCompiler = require_viewcompiler();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var ViewCompiler_MSSQL = class extends ViewCompiler {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createQuery(columns, selectQuery, materialized, replace) {
        const createStatement = "CREATE " + (replace ? "OR ALTER " : "") + "VIEW ";
        let sql = createStatement + this.viewName();
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        sql += columnList;
        sql += " AS ";
        sql += selectQuery.toString();
        this.pushQuery({
          sql
        });
      }
      renameColumn(from, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            this.viewName() + "." + from,
            this.viewBuilder,
            this.bindingsHolder
          )}, ${this.client.parameter(
            to,
            this.viewBuilder,
            this.bindingsHolder
          )}, 'COLUMN'`
        );
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
    };
    module.exports = ViewCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-columncompiler.js
var require_mssql_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-columncompiler.js"(exports, module) {
    var ColumnCompiler = require_columncompiler();
    var { toNumber } = require_helpers();
    var { formatDefault } = require_formatterUtils();
    var { operator: operator_ } = require_wrappingFormatter();
    var ColumnCompiler_MSSQL = class extends ColumnCompiler {
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = ["nullable", "defaultTo", "first", "after", "comment"];
        this._addCheckModifiers();
      }
      // Types
      // ------
      double(precision, scale) {
        return "float";
      }
      floating(precision, scale) {
        return `float`;
      }
      integer() {
        return "int";
      }
      tinyint() {
        return "tinyint";
      }
      varchar(length) {
        return `nvarchar(${toNumber(length, 255)})`;
      }
      timestamp({ useTz = false } = {}) {
        return useTz ? "datetimeoffset" : "datetime2";
      }
      bit(length) {
        if (length > 1) {
          this.client.logger.warn("Bit field is exactly 1 bit length for MSSQL");
        }
        return "bit";
      }
      binary(length) {
        return length ? `varbinary(${toNumber(length)})` : "varbinary(max)";
      }
      // Modifiers
      // ------
      first() {
        this.client.logger.warn("Column first modifier not available for MSSQL");
        return "";
      }
      after(column) {
        this.client.logger.warn("Column after modifier not available for MSSQL");
        return "";
      }
      defaultTo(value, { constraintName } = {}) {
        const formattedValue = formatDefault(value, this.type, this.client);
        constraintName = typeof constraintName !== "undefined" ? constraintName : `${this.tableCompiler.tableNameRaw}_${this.getColumnName()}_default`.toLowerCase();
        if (this.columnBuilder._method === "alter") {
          this.pushAdditional(function() {
            this.pushQuery(
              `ALTER TABLE ${this.tableCompiler.tableName()} ADD CONSTRAINT ${this.formatter.wrap(
                constraintName
              )} DEFAULT ${formattedValue} FOR ${this.formatter.wrap(
                this.getColumnName()
              )}`
            );
          });
          return "";
        }
        if (!constraintName) {
          return `DEFAULT ${formattedValue}`;
        }
        return `CONSTRAINT ${this.formatter.wrap(
          constraintName
        )} DEFAULT ${formattedValue}`;
      }
      comment(comment) {
        if (!comment) {
          return;
        }
        if (comment && comment.length > 7500 / 2) {
          this.client.logger.warn(
            "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
          );
        }
        const value = this.formatter.escapingStringDelimiters(comment);
        const level0name = this.tableCompiler.schemaNameRaw || "dbo";
        const level1name = this.formatter.escapingStringDelimiters(
          this.tableCompiler.tableNameRaw
        );
        const level2name = this.formatter.escapingStringDelimiters(
          this.args[0] || this.defaults("columnName")
        );
        const args = `N'MS_Description', N'${value}', N'Schema', N'${level0name}', N'Table', N'${level1name}', N'Column', N'${level2name}'`;
        this.pushAdditional(function() {
          const isAlreadyDefined = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${level0name}', N'Table', N'${level1name}', N'Column', N'${level2name}'))`;
          this.pushQuery(
            `IF ${isAlreadyDefined}
  EXEC sys.sp_updateextendedproperty ${args}
ELSE
  EXEC sys.sp_addextendedproperty ${args}`
          );
        });
        return "";
      }
      checkLength(operator, length, constraintName) {
        return this._check(
          `LEN(${this.formatter.wrap(this.getColumnName())}) ${operator_(
            operator,
            this.columnBuilder,
            this.bindingsHolder
          )} ${toNumber(length)}`,
          constraintName
        );
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} LIKE ${this.client._escapeBinding("%" + regex + "%")}`,
          constraintName
        );
      }
      increments(options = { primaryKey: true }) {
        return "int identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigint identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
    };
    ColumnCompiler_MSSQL.prototype.bigint = "bigint";
    ColumnCompiler_MSSQL.prototype.mediumint = "int";
    ColumnCompiler_MSSQL.prototype.smallint = "smallint";
    ColumnCompiler_MSSQL.prototype.text = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.mediumtext = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.longtext = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.json = ColumnCompiler_MSSQL.prototype.jsonb = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.enu = "nvarchar(100)";
    ColumnCompiler_MSSQL.prototype.uuid = ({ useBinaryUuid = false } = {}) => useBinaryUuid ? "binary(16)" : "uniqueidentifier";
    ColumnCompiler_MSSQL.prototype.datetime = "datetime2";
    ColumnCompiler_MSSQL.prototype.bool = "bit";
    module.exports = ColumnCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/index.js
var require_mssql = __commonJS({
  "node_modules/knex/lib/dialects/mssql/index.js"(exports, module) {
    var map2 = require_map();
    var isNil = require_isNil();
    var Client = require_client();
    var MSSQL_Formatter = require_mssql_formatter();
    var Transaction = require_transaction2();
    var QueryCompiler = require_mssql_querycompiler();
    var SchemaCompiler = require_mssql_compiler();
    var TableCompiler = require_mssql_tablecompiler();
    var ViewCompiler = require_mssql_viewcompiler();
    var ColumnCompiler = require_mssql_columncompiler();
    var QueryBuilder = require_querybuilder();
    var { setHiddenProperty } = require_security();
    var debug = require_src()("knex:mssql");
    var SQL_INT4 = { MIN: -2147483648, MAX: 2147483647 };
    var SQL_BIGINT_SAFE = { MIN: -9007199254740991, MAX: 9007199254740991 };
    var Client_MSSQL = class extends Client {
      constructor(config = {}) {
        super(config);
      }
      /**
       * @param {import('knex').Config} options
       */
      _generateConnection() {
        const settings = this.connectionSettings;
        settings.options = settings.options || {};
        const cfg = {
          authentication: {
            type: settings.type || "default",
            options: {
              userName: settings.userName || settings.user,
              password: settings.password,
              domain: settings.domain,
              token: settings.token,
              clientId: settings.clientId,
              clientSecret: settings.clientSecret,
              tenantId: settings.tenantId,
              msiEndpoint: settings.msiEndpoint
            }
          },
          server: settings.server || settings.host,
          options: {
            database: settings.database,
            encrypt: settings.encrypt || false,
            port: settings.port || 1433,
            connectTimeout: settings.connectionTimeout || settings.timeout || 15e3,
            requestTimeout: !isNil(settings.requestTimeout) ? settings.requestTimeout : 15e3,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            useColumnNames: false,
            tdsVersion: settings.options.tdsVersion || "7_4",
            appName: settings.options.appName || "knex",
            trustServerCertificate: false,
            ...settings.options
          }
        };
        if (cfg.authentication.options.password) {
          setHiddenProperty(cfg.authentication.options);
        }
        if (cfg.options.instanceName) delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0;
        if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;
        if (settings.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _driver() {
        const tds = __require("tedious");
        return tds;
      }
      formatter() {
        return new MSSQL_Formatter(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler() {
        return new QueryCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      queryBuilder() {
        const b3 = new QueryBuilder(this);
        return b3;
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      wrapIdentifierImpl(value) {
        if (value === "*") {
          return "*";
        }
        return `[${value.replace(/[[\]]+/g, "")}]`;
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          debug("connection::connection new connection requested");
          const Driver = this._driver();
          const settings = Object.assign({}, this._generateConnection());
          const connection = new Driver.Connection(settings);
          connection.connect((err) => {
            if (err) {
              debug("connection::connect error: %s", err.message);
              return rejecter(err);
            }
            debug("connection::connect connected to server");
            connection.connected = true;
            connection.on("error", (e3) => {
              debug("connection::error message=%s", e3.message);
              connection.__knex__disposed = e3;
              connection.connected = false;
            });
            connection.once("end", () => {
              connection.connected = false;
              connection.__knex__disposed = "Connection to server was terminated.";
              debug("connection::end connection ended.");
            });
            return resolver(connection);
          });
        });
      }
      validateConnection(connection) {
        return connection && connection.connected;
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      destroyRawConnection(connection) {
        debug("connection::destroy");
        return new Promise((resolve) => {
          connection.once("end", () => {
            resolve();
          });
          connection.close();
        });
      }
      // Position the bindings for the query.
      positionBindings(sql) {
        let questionCount = -1;
        return sql.replace(/\\?\?/g, (match) => {
          if (match === "\\?") {
            return "?";
          }
          questionCount += 1;
          return `@p${questionCount}`;
        });
      }
      _chomp(connection) {
        if (connection.state.name === "LoggedIn") {
          const nextRequest = this.requestQueue.pop();
          if (nextRequest) {
            debug(
              "connection::query executing query, %d more in queue",
              this.requestQueue.length
            );
            connection.execSql(nextRequest);
          }
        }
      }
      _enqueueRequest(request, connection) {
        this.requestQueue.push(request);
        this._chomp(connection);
      }
      _makeRequest(query, callback) {
        const Driver = this._driver();
        const sql = typeof query === "string" ? query : query.sql;
        let rowCount = 0;
        if (!sql) throw new Error("The query is empty");
        debug("request::request sql=%s", sql);
        const request = new Driver.Request(sql, (err, remoteRowCount) => {
          if (err) {
            debug("request::error message=%s", err.message);
            return callback(err);
          }
          rowCount = remoteRowCount;
          debug("request::callback rowCount=%d", rowCount);
        });
        request.on("prepared", () => {
          debug("request %s::request prepared", this.id);
        });
        request.on("done", (rowCount2, more) => {
          debug("request::done rowCount=%d more=%s", rowCount2, more);
        });
        request.on("doneProc", (rowCount2, more) => {
          debug(
            "request::doneProc id=%s rowCount=%d more=%s",
            request.id,
            rowCount2,
            more
          );
        });
        request.on("doneInProc", (rowCount2, more) => {
          debug(
            "request::doneInProc id=%s rowCount=%d more=%s",
            request.id,
            rowCount2,
            more
          );
        });
        request.once("requestCompleted", () => {
          debug("request::completed id=%s", request.id);
          return callback(null, rowCount);
        });
        request.on("error", (err) => {
          debug("request::error id=%s message=%s", request.id, err.message);
          return callback(err);
        });
        return request;
      }
      // Grab a connection, run the query via the MSSQL streaming interface,
      // and pass that through to the stream we've sent back to the client.
      _stream(connection, query, stream2) {
        return new Promise((resolve, reject) => {
          const request = this._makeRequest(query, (err) => {
            if (err) {
              stream2.emit("error", err);
              return reject(err);
            }
            resolve();
          });
          request.on("row", (row) => {
            stream2.write(
              row.reduce(
                (prev, curr) => ({
                  ...prev,
                  [curr.metadata.colName]: curr.value
                }),
                {}
              )
            );
          });
          request.on("error", (err) => {
            stream2.emit("error", err);
            reject(err);
          });
          request.once("requestCompleted", () => {
            stream2.end();
            resolve();
          });
          this._assignBindings(request, query.bindings);
          this._enqueueRequest(request, connection);
        });
      }
      _assignBindings(request, bindings) {
        if (Array.isArray(bindings)) {
          for (let i3 = 0; i3 < bindings.length; i3++) {
            const binding = bindings[i3];
            this._setReqInput(request, i3, binding);
          }
        }
      }
      _scaleForBinding(binding) {
        if (binding % 1 === 0) {
          throw new Error(`The binding value ${binding} must be a decimal number.`);
        }
        return { scale: 10 };
      }
      _typeForBinding(binding) {
        const Driver = this._driver();
        if (this.connectionSettings.options && this.connectionSettings.options.mapBinding) {
          const result = this.connectionSettings.options.mapBinding(binding);
          if (result) {
            return [result.value, result.type];
          }
        }
        switch (typeof binding) {
          case "string":
            return [binding, Driver.TYPES.NVarChar];
          case "boolean":
            return [binding, Driver.TYPES.Bit];
          case "number": {
            if (binding % 1 !== 0) {
              return [binding, Driver.TYPES.Float];
            }
            if (binding < SQL_INT4.MIN || binding > SQL_INT4.MAX) {
              if (binding < SQL_BIGINT_SAFE.MIN || binding > SQL_BIGINT_SAFE.MAX) {
                throw new Error(
                  `Bigint must be safe integer or must be passed as string, saw ${binding}`
                );
              }
              return [binding, Driver.TYPES.BigInt];
            }
            return [binding, Driver.TYPES.Int];
          }
          default: {
            if (binding instanceof Date) {
              return [binding, Driver.TYPES.DateTime];
            }
            if (binding instanceof Buffer) {
              return [binding, Driver.TYPES.VarBinary];
            }
            return [binding, Driver.TYPES.NVarChar];
          }
        }
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, query) {
        return new Promise((resolve, reject) => {
          const rows = [];
          const request = this._makeRequest(query, (err, count) => {
            if (err) {
              return reject(err);
            }
            query.response = rows;
            process.nextTick(() => this._chomp(connection));
            resolve(query);
          });
          request.on("row", (row) => {
            debug("request::row");
            rows.push(row);
          });
          this._assignBindings(request, query.bindings);
          this._enqueueRequest(request, connection);
        });
      }
      // sets a request input parameter. Detects bigints and decimals and sets type appropriately.
      _setReqInput(req, i3, inputBinding) {
        const [binding, tediousType] = this._typeForBinding(inputBinding);
        const bindingName = "p".concat(i3);
        let options;
        if (typeof binding === "number" && binding % 1 !== 0) {
          options = this._scaleForBinding(binding);
        }
        debug(
          "request::binding pos=%d type=%s value=%s",
          i3,
          tediousType.name,
          binding
        );
        if (Buffer.isBuffer(binding)) {
          options = {
            length: "max"
          };
        }
        req.addParameter(bindingName, tediousType, binding, options);
      }
      // Process the response as returned from the query.
      processResponse(query, runner) {
        if (query == null) return;
        let { response } = query;
        const { method } = query;
        if (query.output) {
          return query.output.call(runner, response);
        }
        response = response.map(
          (row) => row.reduce((columns, r3) => {
            const colName = r3.metadata.colName;
            if (columns[colName]) {
              if (!Array.isArray(columns[colName])) {
                columns[colName] = [columns[colName]];
              }
              columns[colName].push(r3.value);
            } else {
              columns[colName] = r3.value;
            }
            return columns;
          }, {})
        );
        if (query.output) return query.output.call(runner, response);
        switch (method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map2(response, query.pluck);
          case "insert":
          case "del":
          case "update":
          case "counter":
            if (query.returning) {
              if (query.returning === "@@rowcount") {
                return response[0][""];
              }
            }
            return response;
          default:
            return response;
        }
      }
    };
    Object.assign(Client_MSSQL.prototype, {
      requestQueue: [],
      dialect: "mssql",
      driverName: "mssql"
    });
    module.exports = Client_MSSQL;
  }
});

// node_modules/lodash/_baseDelay.js
var require_baseDelay = __commonJS({
  "node_modules/lodash/_baseDelay.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function baseDelay(func, wait, args) {
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() {
        func.apply(void 0, args);
      }, wait);
    }
    module.exports = baseDelay;
  }
});

// node_modules/lodash/defer.js
var require_defer = __commonJS({
  "node_modules/lodash/defer.js"(exports, module) {
    var baseDelay = require_baseDelay();
    var baseRest = require_baseRest();
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });
    module.exports = defer;
  }
});

// node_modules/knex/lib/dialects/mysql/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/knex/lib/dialects/mysql/transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var Debug = require_src();
    var debug = Debug("knex:tx");
    var Transaction_MySQL = class extends Transaction {
      query(conn, sql, status, value) {
        const t3 = this;
        const q3 = this.trxClient.query(conn, sql).catch((err) => {
          if (err.errno === 1305) {
            this.trxClient.logger.warn(
              "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
            );
            return;
          }
          status = 2;
          value = err;
          t3._completed = true;
          debug("%s error running transaction query", t3.txid);
        }).then(function(res) {
          if (status === 1) t3._resolver(value);
          if (status === 2) {
            if (value === void 0) {
              if (t3.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
                t3._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            t3._rejecter(value);
          }
          return res;
        });
        if (status === 1 || status === 2) {
          t3._completed = true;
        }
        return q3;
      }
    };
    module.exports = Transaction_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js
var require_mysql_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js"(exports, module) {
    var QueryBuilder = require_querybuilder();
    var isEmpty = require_isEmpty();
    module.exports = class QueryBuilder_MySQL extends QueryBuilder {
      upsert(values, returning, options) {
        this._method = "upsert";
        if (!isEmpty(returning)) {
          this.returning(returning, options);
        }
        this._single.upsert = values;
        return this;
      }
    };
  }
});

// node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js
var require_mysql_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js"(exports, module) {
    var assert = __require("assert");
    var identity = require_identity();
    var isPlainObject = require_isPlainObject();
    var isEmpty = require_isEmpty();
    var QueryCompiler = require_querycompiler();
    var { wrapAsIdentifier } = require_formatterUtils();
    var {
      columnize: columnize_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var isPlainObjectOrArray = (value) => isPlainObject(value) || Array.isArray(value);
    var QueryCompiler_MySQL = class extends QueryCompiler {
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { returning } = this.single;
        if (returning) {
          this.client.logger.warn(
            ".returning() is not supported by mysql and will not have any effect."
          );
        }
        this._emptyInsertValue = "() values ()";
      }
      // Compiles an `delete` allowing comments
      del() {
        const sql = super.del();
        if (sql === "") return sql;
        const comments = this.comments();
        return (comments === "" ? "" : comments + " ") + sql;
      }
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let sql = super.insert();
        if (sql === "") return sql;
        const comments = this.comments();
        sql = (comments === "" ? "" : comments + " ") + sql;
        const { ignore, merge, insert } = this.single;
        if (ignore) sql = sql.replace("insert into", "insert ignore into");
        if (merge) {
          sql += this._merge(merge.updates, insert);
          const wheres = this.where();
          if (wheres) {
            throw new Error(
              ".onConflict().merge().where() is not supported for mysql"
            );
          }
        }
        return sql;
      }
      upsert() {
        const upsertValues = this.single.upsert || [];
        const sql = this.with() + `replace into ${this.tableName} `;
        const body = this._insertBody(upsertValues);
        return body === "" ? "" : sql + body;
      }
      // Compiles merge for onConflict, allowing for different merge strategies
      _merge(updates, insert) {
        const sql = " on duplicate key update ";
        if (updates && Array.isArray(updates)) {
          return sql + updates.map(
            (column) => wrapAsIdentifier(column, this.formatter.builder, this.client)
          ).map((column) => `${column} = values(${column})`).join(", ");
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          return sql + updateData.join(",");
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          return sql + insertData.columns.map((column) => wrapAsIdentifier(column, this.builder, this.client)).map((column) => `${column} = values(${column})`).join(", ");
        }
      }
      // Update method, including joins, wheres, order & limits.
      update() {
        const comments = this.comments();
        const withSQL = this.with();
        const join = this.join();
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        const order = this.order();
        const limit = this.limit();
        return (comments === "" ? "" : comments + " ") + withSQL + `update ${this.tableName}` + (join ? ` ${join}` : "") + " set " + updates.join(", ") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (limit ? ` ${limit}` : "");
      }
      forUpdate() {
        return "for update";
      }
      forShare() {
        return "lock in share mode";
      }
      // Only supported on MySQL 8.0+
      skipLocked() {
        return "skip locked";
      }
      // Supported on MySQL 8.0+ and MariaDB 10.3.0+
      noWait() {
        return "nowait";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        return {
          sql: "select * from information_schema.columns where table_name = ? and table_schema = ?",
          bindings: [table, this.client.database()],
          output(resp) {
            const out = resp.reduce(function(columns, val2) {
              columns[val2.COLUMN_NAME] = {
                defaultValue: val2.COLUMN_DEFAULT === "NULL" ? null : val2.COLUMN_DEFAULT,
                type: val2.DATA_TYPE,
                maxLength: val2.CHARACTER_MAXIMUM_LENGTH,
                nullable: val2.IS_NULLABLE === "YES"
              };
              return columns;
            }, {});
            return column && out[column] || out;
          }
        };
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit && !this.single.offset) return "";
        const limit = this.single.offset && noLimit ? "18446744073709551615" : this._getValueOrParameterFromAttribute("limit");
        return `limit ${limit}`;
      }
      whereBasic(statement) {
        assert(
          !isPlainObjectOrArray(statement.value),
          "The values in where clause must not be object or array."
        );
        return super.whereBasic(statement);
      }
      whereRaw(statement) {
        assert(
          isEmpty(statement.value.bindings) || !Object.values(statement.value.bindings).some(isPlainObjectOrArray),
          "The values in where clause must not be object or array."
        );
        return super.whereRaw(statement);
      }
      whereLike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)} COLLATE utf8_bin`;
      }
      whereILike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract(["json_extract", "json_unquote"], params);
      }
      jsonSet(params) {
        return this._jsonSet("json_set", params);
      }
      jsonInsert(params) {
        return this._jsonSet("json_insert", params);
      }
      jsonRemove(params) {
        const jsonCol = `json_remove(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonObject(statement) {
        return this._not(
          statement,
          `json_contains(${this._columnClause(statement)}, ${this._jsonValueClause(
            statement
          )})`
        );
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_extract", statement);
      }
      whereJsonSupersetOf(statement) {
        return this._not(
          statement,
          `json_contains(${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )},${this._jsonValueClause(statement)})`
        );
      }
      whereJsonSubsetOf(statement) {
        return this._not(
          statement,
          `json_contains(${this._jsonValueClause(statement)},${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )})`
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract", clause);
      }
    };
    module.exports = QueryCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js
var require_mysql_compiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js"(exports, module) {
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_MySQL = class extends SchemaCompiler {
      constructor(client, builder) {
        super(client, builder);
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        this.pushQuery(
          `rename table ${this.formatter.wrap(tableName)} to ${this.formatter.wrap(
            to
          )}`
        );
      }
      renameView(from, to) {
        this.renameTable(from, to);
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        let sql = "select * from information_schema.tables where table_name = ?";
        const bindings = [tableName];
        if (this.schema) {
          sql += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql += " and table_schema = database()";
        }
        this.pushQuery({
          sql,
          bindings,
          output: function output(resp) {
            return resp.length > 0;
          }
        });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        this.pushQuery({
          sql: `show columns from ${this.formatter.wrap(tableName)}`,
          output(resp) {
            return resp.some((row) => {
              return this.client.wrapIdentifier(row.Field.toLowerCase()) === this.client.wrapIdentifier(column.toLowerCase());
            });
          }
        });
      }
    };
    module.exports = SchemaCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js
var require_mysql_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js"(exports, module) {
    var TableCompiler = require_tablecompiler();
    var { isObject, isString } = require_is();
    var TableCompiler_MySQL = class extends TableCompiler {
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const { client } = this;
        let conn = {};
        let columnsSql = " (" + columns.sql.join(", ");
        columnsSql += this.primaryKeys() || "";
        columnsSql += this._addChecks();
        columnsSql += ")";
        let sql = createStatement + this.tableName() + (like && this.tableNameLike() ? " like " + this.tableNameLike() : columnsSql);
        if (client.connectionSettings) {
          conn = client.connectionSettings;
        }
        const charset = this.single.charset || conn.charset || "";
        const collation = this.single.collate || conn.collate || "";
        const engine = this.single.engine || "";
        if (charset && !like) sql += ` default character set ${charset}`;
        if (collation) sql += ` collate ${collation}`;
        if (engine) sql += ` engine = ${engine}`;
        if (this.single.comment) {
          const comment = this.single.comment || "";
          const MAX_COMMENT_LENGTH = 1024;
          if (comment.length > MAX_COMMENT_LENGTH)
            this.client.logger.warn(
              `The max length for a table comment is ${MAX_COMMENT_LENGTH} characters`
            );
          sql += ` comment = '${comment}'`;
        }
        this.pushQuery(sql);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(`alter table ${this.tableName()} comment = '${comment}'`);
      }
      changeType() {
      }
      // Renames a column on the table.
      renameColumn(from, to) {
        const compiler = this;
        const table = this.tableName();
        const wrapped = this.formatter.wrap(from) + " " + this.formatter.wrap(to);
        this.pushQuery({
          sql: `show full fields from ${table} where field = ` + this.client.parameter(from, this.tableBuilder, this.bindingsHolder),
          output(resp) {
            const column = resp[0];
            const runner = this;
            return compiler.getFKRefs(runner).then(
              ([refs]) => new Promise((resolve, reject) => {
                try {
                  if (!refs.length) {
                    resolve();
                  }
                  resolve(compiler.dropFKRefs(runner, refs));
                } catch (e3) {
                  reject(e3);
                }
              }).then(function() {
                let sql = `alter table ${table} change ${wrapped} ${column.Type}`;
                if (String(column.Null).toUpperCase() !== "YES") {
                  sql += ` NOT NULL`;
                } else {
                  sql += ` NULL`;
                }
                if (column.Default !== void 0 && column.Default !== null) {
                  sql += ` DEFAULT '${column.Default}'`;
                }
                if (column.Collation !== void 0 && column.Collation !== null) {
                  sql += ` COLLATE '${column.Collation}'`;
                }
                if (column.Extra == "auto_increment") {
                  sql += ` AUTO_INCREMENT`;
                }
                return runner.query({
                  sql
                });
              }).then(function() {
                if (!refs.length) {
                  return;
                }
                return compiler.createFKRefs(
                  runner,
                  refs.map(function(ref) {
                    if (ref.REFERENCED_COLUMN_NAME === from) {
                      ref.REFERENCED_COLUMN_NAME = to;
                    }
                    if (ref.COLUMN_NAME === from) {
                      ref.COLUMN_NAME = to;
                    }
                    return ref;
                  })
                );
              })
            );
          }
        });
      }
      primaryKeys() {
        const pks = (this.grouped.alterTable || []).filter(
          (k3) => k3.method === "primary"
        );
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          if (this.grouped.columns) {
            const incrementsCols = this._getIncrementsColumnNames();
            if (incrementsCols.length) {
              incrementsCols.forEach((c3) => {
                if (!columns.includes(c3)) {
                  columns.unshift(c3);
                }
              });
            }
            const bigIncrementsCols = this._getBigIncrementsColumnNames();
            if (bigIncrementsCols.length) {
              bigIncrementsCols.forEach((c3) => {
                if (!columns.includes(c3)) {
                  columns.unshift(c3);
                }
              });
            }
          }
          return `,${constraintName} primary key (${this.formatter.columnize(
            columns
          )})`;
        }
      }
      getFKRefs(runner) {
        const bindingsHolder = {
          bindings: []
        };
        const sql = "SELECT KCU.CONSTRAINT_NAME, KCU.TABLE_NAME, KCU.COLUMN_NAME,        KCU.REFERENCED_TABLE_NAME, KCU.REFERENCED_COLUMN_NAME,        RC.UPDATE_RULE, RC.DELETE_RULE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC        USING(CONSTRAINT_NAME)WHERE KCU.REFERENCED_TABLE_NAME = " + this.client.parameter(
          this.tableNameRaw,
          this.tableBuilder,
          bindingsHolder
        ) + "   AND KCU.CONSTRAINT_SCHEMA = " + this.client.parameter(
          this.client.database(),
          this.tableBuilder,
          bindingsHolder
        ) + "   AND RC.CONSTRAINT_SCHEMA = " + this.client.parameter(
          this.client.database(),
          this.tableBuilder,
          bindingsHolder
        );
        return runner.query({
          sql,
          bindings: bindingsHolder.bindings
        });
      }
      dropFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref) {
            const constraintName = formatter.wrap(ref.CONSTRAINT_NAME);
            const tableName = formatter.wrap(ref.TABLE_NAME);
            return runner.query({
              sql: `alter table ${tableName} drop foreign key ${constraintName}`
            });
          })
        );
      }
      createFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref) {
            const tableName = formatter.wrap(ref.TABLE_NAME);
            const keyName = formatter.wrap(ref.CONSTRAINT_NAME);
            const column = formatter.columnize(ref.COLUMN_NAME);
            const references = formatter.columnize(ref.REFERENCED_COLUMN_NAME);
            const inTable = formatter.wrap(ref.REFERENCED_TABLE_NAME);
            const onUpdate = ` ON UPDATE ${ref.UPDATE_RULE}`;
            const onDelete = ` ON DELETE ${ref.DELETE_RULE}`;
            return runner.query({
              sql: `alter table ${tableName} add constraint ${keyName} foreign key (` + column + ") references " + inTable + " (" + references + ")" + onUpdate + onDelete
            });
          })
        );
      }
      index(columns, indexName, options) {
        let storageEngineIndexType;
        let indexType;
        if (isString(options)) {
          indexType = options;
        } else if (isObject(options)) {
          ({ indexType, storageEngineIndexType } = options);
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        storageEngineIndexType = storageEngineIndexType ? ` using ${storageEngineIndexType}` : "";
        this.pushQuery(
          `alter table ${this.tableName()} add${indexType ? ` ${indexType}` : ""} index ${indexName}(${this.formatter.columnize(
            columns
          )})${storageEngineIndexType}`
        );
      }
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mysql: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
          );
        }
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        const primaryCols = columns;
        let incrementsCols = [];
        let bigIncrementsCols = [];
        if (this.grouped.columns) {
          incrementsCols = this._getIncrementsColumnNames();
          if (incrementsCols) {
            incrementsCols.forEach((c3) => {
              if (!primaryCols.includes(c3)) {
                primaryCols.unshift(c3);
              }
            });
          }
          bigIncrementsCols = this._getBigIncrementsColumnNames();
          if (bigIncrementsCols) {
            bigIncrementsCols.forEach((c3) => {
              if (!primaryCols.includes(c3)) {
                primaryCols.unshift(c3);
              }
            });
          }
        }
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery(
            `alter table ${this.tableName()} add primary key ${constraintName}(${this.formatter.columnize(
              primaryCols
            )})`
          );
        }
        if (incrementsCols.length) {
          this.pushQuery(
            `alter table ${this.tableName()} modify column ${this.formatter.columnize(
              incrementsCols
            )} int unsigned not null auto_increment`
          );
        }
        if (bigIncrementsCols.length) {
          this.pushQuery(
            `alter table ${this.tableName()} modify column ${this.formatter.columnize(
              bigIncrementsCols
            )} bigint unsigned not null auto_increment`
          );
        }
      }
      unique(columns, indexName) {
        let storageEngineIndexType;
        let deferrable;
        if (isObject(indexName)) {
          ({ indexName, deferrable, storageEngineIndexType } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mysql: unique index \`${indexName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
          );
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        storageEngineIndexType = storageEngineIndexType ? ` using ${storageEngineIndexType}` : "";
        this.pushQuery(
          `alter table ${this.tableName()} add unique ${indexName}(${this.formatter.columnize(
            columns
          )})${storageEngineIndexType}`
        );
      }
      // Compile a drop index command.
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop foreign key ${indexName}`
        );
      }
      // Compile a drop primary key command.
      dropPrimary() {
        this.pushQuery(`alter table ${this.tableName()} drop primary key`);
      }
      // Compile a drop unique key command.
      dropUnique(column, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, column);
        this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
      }
    };
    TableCompiler_MySQL.prototype.addColumnsPrefix = "add ";
    TableCompiler_MySQL.prototype.alterColumnsPrefix = "modify ";
    TableCompiler_MySQL.prototype.dropColumnPrefix = "drop ";
    module.exports = TableCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js
var require_mysql_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js"(exports, module) {
    var ColumnCompiler = require_columncompiler();
    var { isObject } = require_is();
    var { toNumber } = require_helpers();
    var commentEscapeRegex = /(?<!\\)'/g;
    var ColumnCompiler_MySQL = class extends ColumnCompiler {
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = [
          "unsigned",
          "nullable",
          "defaultTo",
          "comment",
          "collate",
          "first",
          "after"
        ];
        this._addCheckModifiers();
      }
      // Types
      // ------
      double(precision, scale) {
        if (!precision) return "double";
        return `double(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      integer(length) {
        length = length ? `(${toNumber(length, 11)})` : "";
        return `int${length}`;
      }
      tinyint(length) {
        length = length ? `(${toNumber(length, 1)})` : "";
        return `tinyint${length}`;
      }
      text(column) {
        switch (column) {
          case "medium":
          case "mediumtext":
            return "mediumtext";
          case "long":
          case "longtext":
            return "longtext";
          default:
            return "text";
        }
      }
      mediumtext() {
        return this.text("medium");
      }
      longtext() {
        return this.text("long");
      }
      enu(allowed) {
        return `enum('${allowed.join("', '")}')`;
      }
      datetime(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `datetime(${precision})` : "datetime";
      }
      timestamp(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `timestamp(${precision})` : "timestamp";
      }
      time(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `time(${precision})` : "time";
      }
      bit(length) {
        return length ? `bit(${toNumber(length)})` : "bit";
      }
      binary(length) {
        return length ? `varbinary(${toNumber(length)})` : "blob";
      }
      json() {
        return "json";
      }
      jsonb() {
        return "json";
      }
      // Modifiers
      // ------
      defaultTo(value) {
        if (value === null || value === void 0) {
          return;
        }
        if ((this.type === "json" || this.type === "jsonb") && isObject(value)) {
          return `default ('${JSON.stringify(value)}')`;
        }
        const defaultVal = super.defaultTo.apply(this, arguments);
        if (this.type !== "blob" && this.type.indexOf("text") === -1) {
          return defaultVal;
        }
        return "";
      }
      unsigned() {
        return "unsigned";
      }
      comment(comment) {
        if (comment && comment.length > 255) {
          this.client.logger.warn(
            "Your comment is longer than the max comment length for MySQL"
          );
        }
        return comment && `comment '${comment.replace(commentEscapeRegex, "\\'")}'`;
      }
      first() {
        return "first";
      }
      after(column) {
        return `after ${this.formatter.wrap(column)}`;
      }
      collate(collation) {
        return collation && `collate '${collation}'`;
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} REGEXP ${this.client._escapeBinding(regex)}`,
          constraintName
        );
      }
      increments(options = { primaryKey: true }) {
        return "int unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
        // initialize this column as classic int column then modify it later in table compiler
        (this.tableCompiler._canBeAddPrimaryKey(options) ? " auto_increment primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigint unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
        // initialize this column as classic int column then modify it later in table compiler
        (this.tableCompiler._canBeAddPrimaryKey(options) ? " auto_increment primary key" : "");
      }
    };
    ColumnCompiler_MySQL.prototype.bigint = "bigint";
    ColumnCompiler_MySQL.prototype.mediumint = "mediumint";
    ColumnCompiler_MySQL.prototype.smallint = "smallint";
    module.exports = ColumnCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js
var require_mysql_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js"(exports, module) {
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_MySQL = class extends ViewCompiler {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
    };
    module.exports = ViewCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js
var require_mysql_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js"(exports, module) {
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_MySQL = class extends ViewBuilder {
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
      localCheckOption() {
        this._single.checkOption = "local";
      }
      cascadedCheckOption() {
        this._single.checkOption = "cascaded";
      }
    };
    module.exports = ViewBuilder_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/index.js
var require_mysql = __commonJS({
  "node_modules/knex/lib/dialects/mysql/index.js"(exports, module) {
    var defer = require_defer();
    var map2 = require_map();
    var { promisify } = __require("util");
    var Client = require_client();
    var Transaction = require_transaction3();
    var QueryBuilder = require_mysql_querybuilder();
    var QueryCompiler = require_mysql_querycompiler();
    var SchemaCompiler = require_mysql_compiler();
    var TableCompiler = require_mysql_tablecompiler();
    var ColumnCompiler = require_mysql_columncompiler();
    var { makeEscape } = require_string();
    var ViewCompiler = require_mysql_viewcompiler();
    var ViewBuilder = require_mysql_viewbuilder();
    var Client_MySQL = class extends Client {
      _driver() {
        return __require("mysql");
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `\`${value.replace(/`/g, "``")}\`` : "*";
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          const connection = this.driver.createConnection(this.connectionSettings);
          connection.on("error", (err) => {
            connection.__knex__disposed = err;
          });
          connection.connect((err) => {
            if (err) {
              connection.removeAllListeners();
              return rejecter(err);
            }
            resolver(connection);
          });
        });
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        try {
          const end = promisify((cb) => connection.end(cb));
          return await end();
        } catch (err) {
          connection.__knex__disposed = err;
        } finally {
          defer(() => connection.removeAllListeners());
        }
      }
      validateConnection(connection) {
        return connection.state === "connected" || connection.state === "authenticated";
      }
      // Grab a connection, run the query via the MySQL streaming interface,
      // and pass that through to the stream we've sent back to the client.
      _stream(connection, obj, stream2, options) {
        if (!obj.sql) throw new Error("The query is empty");
        options = options || {};
        const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
        return new Promise((resolver, rejecter) => {
          stream2.on("error", rejecter);
          stream2.on("end", resolver);
          const queryStream = connection.query(queryOptions, obj.bindings).stream(options);
          queryStream.on("error", (err) => {
            rejecter(err);
            stream2.emit("error", err);
          });
          queryStream.pipe(stream2);
        });
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj || typeof obj === "string") obj = { sql: obj };
        if (!obj.sql) throw new Error("The query is empty");
        return new Promise(function(resolver, rejecter) {
          if (!obj.sql) {
            resolver();
            return;
          }
          const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
          connection.query(
            queryOptions,
            obj.bindings,
            function(err, rows, fields) {
              if (err) return rejecter(err);
              obj.response = [rows, fields];
              resolver(obj);
            }
          );
        });
      }
      // Process the response as returned from the query.
      processResponse(obj, runner) {
        if (obj == null) return;
        const { response } = obj;
        const { method } = obj;
        const rows = response[0];
        const fields = response[1];
        if (obj.output) return obj.output.call(runner, rows, fields);
        switch (method) {
          case "select":
            return rows;
          case "first":
            return rows[0];
          case "pluck":
            return map2(rows, obj.pluck);
          case "insert":
            return [rows.insertId];
          case "del":
          case "update":
          case "counter":
            return rows.affectedRows;
          default:
            return response;
        }
      }
      async cancelQuery(connectionToKill) {
        const conn = await this.acquireRawConnection();
        try {
          return await this._wrappedCancelQueryCall(conn, connectionToKill);
        } finally {
          await this.destroyRawConnection(conn);
          if (conn.__knex__disposed) {
            this.logger.warn(`Connection Error: ${conn.__knex__disposed}`);
          }
        }
      }
      _wrappedCancelQueryCall(conn, connectionToKill) {
        return this._query(conn, {
          sql: "KILL QUERY ?",
          bindings: [connectionToKill.threadId],
          options: {}
        });
      }
    };
    Object.assign(Client_MySQL.prototype, {
      dialect: "mysql",
      driverName: "mysql",
      _escapeBinding: makeEscape(),
      canCancelQuery: true
    });
    module.exports = Client_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql2/transaction.js
var require_transaction4 = __commonJS({
  "node_modules/knex/lib/dialects/mysql2/transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var debug = require_src()("knex:tx");
    var Transaction_MySQL2 = class extends Transaction {
      query(conn, sql, status, value) {
        const t3 = this;
        const q3 = this.trxClient.query(conn, sql).catch((err) => {
          if (err.code === "ER_SP_DOES_NOT_EXIST") {
            this.trxClient.logger.warn(
              "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
            );
            return;
          }
          status = 2;
          value = err;
          t3._completed = true;
          debug("%s error running transaction query", t3.txid);
        }).then(function(res) {
          if (status === 1) t3._resolver(value);
          if (status === 2) {
            if (value === void 0) {
              if (t3.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
                t3._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            t3._rejecter(value);
            return res;
          }
        });
        if (status === 1 || status === 2) {
          t3._completed = true;
        }
        return q3;
      }
    };
    module.exports = Transaction_MySQL2;
  }
});

// node_modules/knex/lib/dialects/mysql2/index.js
var require_mysql2 = __commonJS({
  "node_modules/knex/lib/dialects/mysql2/index.js"(exports, module) {
    var Client_MySQL = require_mysql();
    var Transaction = require_transaction4();
    var Client_MySQL2 = class extends Client_MySQL {
      transaction() {
        return new Transaction(this, ...arguments);
      }
      _driver() {
        return __require("mysql2");
      }
      initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e3) {
          let message = `Knex: run
$ npm install ${this.driverName}`;
          const nodeMajorVersion = process.version.replace(/^v/, "").split(".")[0];
          if (nodeMajorVersion <= 12) {
            message += `@3.2.0`;
            this.logger.error(
              "Mysql2 version 3.2.0 is the latest version to support Node.js 12 or lower."
            );
          }
          message += ` --save`;
          this.logger.error(`${message}
${e3.message}
${e3.stack}`);
          throw new Error(`${message}
${e3.message}`);
        }
      }
      validateConnection(connection) {
        return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;
      }
    };
    Object.assign(Client_MySQL2.prototype, {
      // The "dialect", for reference elsewhere.
      driverName: "mysql2"
    });
    module.exports = Client_MySQL2;
  }
});

// node_modules/knex/lib/dialects/oracle/utils.js
var require_utils6 = __commonJS({
  "node_modules/knex/lib/dialects/oracle/utils.js"(exports, module) {
    var NameHelper = class {
      constructor(oracleVersion) {
        this.oracleVersion = oracleVersion;
        const versionParts = oracleVersion.split(".").map((versionPart) => parseInt(versionPart));
        if (versionParts[0] > 12 || versionParts[0] === 12 && versionParts[1] >= 2) {
          this.limit = 128;
        } else {
          this.limit = 30;
        }
      }
      generateCombinedName(logger, postfix, name, subNames) {
        const crypto10 = __require("crypto");
        if (!Array.isArray(subNames)) subNames = subNames ? [subNames] : [];
        const table = name.replace(/\.|-/g, "_");
        const subNamesPart = subNames.join("_");
        let result = `${table}_${subNamesPart.length ? subNamesPart + "_" : ""}${postfix}`.toLowerCase();
        if (result.length > this.limit) {
          logger.warn(
            `Automatically generated name "${result}" exceeds ${this.limit} character limit for Oracle Database ${this.oracleVersion}. Using base64 encoded sha1 of that name instead.`
          );
          result = crypto10.createHash("sha1").update(result).digest("base64").replace("=", "");
        }
        return result;
      }
    };
    function wrapSqlWithCatch(sql, errorNumberToCatch) {
      return `begin execute immediate '${sql.replace(/'/g, "''")}'; exception when others then if sqlcode != ${errorNumberToCatch} then raise; end if; end;`;
    }
    function ReturningHelper(columnName) {
      this.columnName = columnName;
    }
    ReturningHelper.prototype.toString = function() {
      return `[object ReturningHelper:${this.columnName}]`;
    };
    function isConnectionError(err) {
      return [
        "DPI-1010",
        // not connected
        "DPI-1080",
        // connection was closed by ORA-%d
        "ORA-03114",
        // not connected to ORACLE
        "ORA-03113",
        // end-of-file on communication channel
        "ORA-03135",
        // connection lost contact
        "ORA-12514",
        // listener does not currently know of service requested in connect descriptor
        "ORA-00022",
        // invalid session ID; access denied
        "ORA-00028",
        // your session has been killed
        "ORA-00031",
        // your session has been marked for kill
        "ORA-00045",
        // your session has been terminated with no replay
        "ORA-00378",
        // buffer pools cannot be created as specified
        "ORA-00602",
        // internal programming exception
        "ORA-00603",
        // ORACLE server session terminated by fatal error
        "ORA-00609",
        // could not attach to incoming connection
        "ORA-01012",
        // not logged on
        "ORA-01041",
        // internal error. hostdef extension doesn't exist
        "ORA-01043",
        // user side memory corruption
        "ORA-01089",
        // immediate shutdown or close in progress
        "ORA-01092",
        // ORACLE instance terminated. Disconnection forced
        "ORA-02396",
        // exceeded maximum idle time, please connect again
        "ORA-03122",
        // attempt to close ORACLE-side window on user side
        "ORA-12153",
        // TNS'not connected
        "ORA-12537",
        // TNS'connection closed
        "ORA-12547",
        // TNS'lost contact
        "ORA-12570",
        // TNS'packet reader failure
        "ORA-12583",
        // TNS'no reader
        "ORA-27146",
        // post/wait initialization failed
        "ORA-28511",
        // lost RPC connection
        "ORA-56600",
        // an illegal OCI function call was issued
        "NJS-024",
        "NJS-003"
      ].some(function(prefix) {
        return err.message.indexOf(prefix) === 0;
      });
    }
    module.exports = {
      NameHelper,
      isConnectionError,
      wrapSqlWithCatch,
      ReturningHelper
    };
  }
});

// node_modules/knex/lib/dialects/oracle/schema/internal/trigger.js
var require_trigger = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/internal/trigger.js"(exports, module) {
    var { NameHelper } = require_utils6();
    var Trigger = class {
      constructor(oracleVersion) {
        this.nameHelper = new NameHelper(oracleVersion);
      }
      renameColumnTrigger(logger, tableName, columnName, to) {
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('ALTER TABLE "${tableName}" RENAME COLUMN "${columnName}" TO "${to}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${triggerName}';  IF (IS_AUTOINC > 0) THEN    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${tableName}';    IF ('${to}' = PK_NAME) THEN      EXECUTE IMMEDIATE ('DROP TRIGGER "${triggerName}"');      EXECUTE IMMEDIATE ('create or replace trigger "${triggerName}"      BEFORE INSERT on "${tableName}" for each row        declare        checking number := 1;        begin          if (:new."${to}" is null) then            while checking >= 1 loop              select "${sequenceName}".nextval into :new."${to}" from dual;              select count("${to}") into checking from "${tableName}"              where "${to}" = :new."${to}";            end loop;          end if;        end;');    end if;  end if;END;`;
      }
      createAutoIncrementTrigger(logger, tableName, schemaName) {
        const tableQuoted = `"${tableName}"`;
        const tableUnquoted = tableName;
        const schemaQuoted = schemaName ? `"${schemaName}".` : "";
        const constraintOwner = schemaName ? `'${schemaName}'` : "cols.owner";
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceNameUnquoted = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        const sequenceNameQuoted = `"${sequenceNameUnquoted}"`;
        return `DECLARE PK_NAME VARCHAR(200); BEGIN  EXECUTE IMMEDIATE ('CREATE SEQUENCE ${schemaQuoted}${sequenceNameQuoted}');  SELECT cols.column_name INTO PK_NAME  FROM all_constraints cons, all_cons_columns cols  WHERE cons.constraint_type = 'P'  AND cons.constraint_name = cols.constraint_name  AND cons.owner = ${constraintOwner}  AND cols.table_name = '${tableUnquoted}';  execute immediate ('create or replace trigger ${schemaQuoted}"${triggerName}"  BEFORE INSERT on ${schemaQuoted}${tableQuoted}  for each row  declare  checking number := 1;  begin    if (:new."' || PK_NAME || '" is null) then      while checking >= 1 loop        select ${schemaQuoted}${sequenceNameQuoted}.nextval into :new."' || PK_NAME || '" from dual;        select count("' || PK_NAME || '") into checking from ${schemaQuoted}${tableQuoted}        where "' || PK_NAME || '" = :new."' || PK_NAME || '";      end loop;    end if;  end;'); END;`;
      }
      renameTableAndAutoIncrementTrigger(logger, tableName, to) {
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        const toTriggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          to
        );
        const toSequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          to
        );
        return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('RENAME "${tableName}" TO "${to}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${triggerName}';  IF (IS_AUTOINC > 0) THEN    EXECUTE IMMEDIATE ('DROP TRIGGER "${triggerName}"');    EXECUTE IMMEDIATE ('RENAME "${sequenceName}" TO "${toSequenceName}"');    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${to}';    EXECUTE IMMEDIATE ('create or replace trigger "${toTriggerName}"    BEFORE INSERT on "${to}" for each row      declare      checking number := 1;      begin        if (:new."' || PK_NAME || '" is null) then          while checking >= 1 loop            select "${toSequenceName}".nextval into :new."' || PK_NAME || '" from dual;            select count("' || PK_NAME || '") into checking from "${to}"            where "' || PK_NAME || '" = :new."' || PK_NAME || '";          end loop;        end if;      end;');  end if;END;`;
      }
    };
    module.exports = Trigger;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-compiler.js
var require_oracle_compiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-compiler.js"(exports, module) {
    var SchemaCompiler = require_compiler();
    var utils = require_utils6();
    var Trigger = require_trigger();
    var SchemaCompiler_Oracle = class extends SchemaCompiler {
      constructor() {
        super(...arguments);
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        const trigger = new Trigger(this.client.version);
        const renameTable = trigger.renameTableAndAutoIncrementTrigger(
          this.client.logger,
          tableName,
          to
        );
        this.pushQuery(renameTable);
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        this.pushQuery({
          sql: "select TABLE_NAME from USER_TABLES where TABLE_NAME = " + this.client.parameter(tableName, this.builder, this.bindingsHolder),
          output(resp) {
            return resp.length > 0;
          }
        });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        const sql = `select COLUMN_NAME from ALL_TAB_COLUMNS where TABLE_NAME = ${this.client.parameter(
          tableName,
          this.builder,
          this.bindingsHolder
        )} and COLUMN_NAME = ${this.client.parameter(
          column,
          this.builder,
          this.bindingsHolder
        )}`;
        this.pushQuery({ sql, output: (resp) => resp.length > 0 });
      }
      dropSequenceIfExists(sequenceName) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        this.pushQuery(
          utils.wrapSqlWithCatch(
            `drop sequence ${prefix}${this.formatter.wrap(sequenceName)}`,
            -2289
          )
        );
      }
      _dropRelatedSequenceIfExists(tableName) {
        const nameHelper = new utils.NameHelper(this.client.version);
        const sequenceName = nameHelper.generateCombinedName(
          this.client.logger,
          "seq",
          tableName
        );
        this.dropSequenceIfExists(sequenceName);
      }
      dropTable(tableName) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        this.pushQuery(`drop table ${prefix}${this.formatter.wrap(tableName)}`);
        this._dropRelatedSequenceIfExists(tableName);
      }
      dropTableIfExists(tableName) {
        this.dropObject(tableName, "table");
      }
      dropViewIfExists(viewName) {
        this.dropObject(viewName, "view");
      }
      dropObject(objectName, type) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        let errorCode = -942;
        if (type === "materialized view") {
          errorCode = -12003;
        }
        this.pushQuery(
          utils.wrapSqlWithCatch(
            `drop ${type} ${prefix}${this.formatter.wrap(objectName)}`,
            errorCode
          )
        );
        this._dropRelatedSequenceIfExists(objectName);
      }
      refreshMaterializedView(viewName) {
        return this.pushQuery({
          sql: `BEGIN DBMS_MVIEW.REFRESH('${this.schemaNameRaw ? this.schemaNameRaw + "." : ""}${viewName}'); END;`
        });
      }
      dropMaterializedView(viewName) {
        this._dropView(viewName, false, true);
      }
      dropMaterializedViewIfExists(viewName) {
        this.dropObject(viewName, "materialized view");
      }
    };
    module.exports = SchemaCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-columnbuilder.js
var require_oracle_columnbuilder = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-columnbuilder.js"(exports, module) {
    var ColumnBuilder = require_columnbuilder();
    var toArray = require_toArray();
    var ColumnBuilder_Oracle = class extends ColumnBuilder {
      constructor() {
        super(...arguments);
      }
      // checkIn added to the builder to allow the column compiler to change the
      // order via the modifiers ("check" must be after "default")
      checkIn() {
        this._modifiers.checkIn = toArray(arguments);
        return this;
      }
    };
    module.exports = ColumnBuilder_Oracle;
  }
});

// node_modules/lodash/noop.js
var require_noop3 = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop3();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module.exports = uniq;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/internal/incrementUtils.js
var require_incrementUtils = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/internal/incrementUtils.js"(exports, module) {
    var Trigger = require_trigger();
    function createAutoIncrementTriggerAndSequence(columnCompiler) {
      const trigger = new Trigger(columnCompiler.client.version);
      columnCompiler.pushAdditional(function() {
        const tableName = this.tableCompiler.tableNameRaw;
        const schemaName = this.tableCompiler.schemaNameRaw;
        const createTriggerSQL = trigger.createAutoIncrementTrigger(
          this.client.logger,
          tableName,
          schemaName
        );
        this.pushQuery(createTriggerSQL);
      });
    }
    module.exports = {
      createAutoIncrementTriggerAndSequence
    };
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-columncompiler.js
var require_oracle_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-columncompiler.js"(exports, module) {
    var uniq = require_uniq();
    var Raw = require_raw();
    var ColumnCompiler = require_columncompiler();
    var {
      createAutoIncrementTriggerAndSequence
    } = require_incrementUtils();
    var { toNumber } = require_helpers();
    var ColumnCompiler_Oracle = class extends ColumnCompiler {
      constructor() {
        super(...arguments);
        this.modifiers = ["defaultTo", "checkIn", "nullable", "comment"];
      }
      increments(options = { primaryKey: true }) {
        createAutoIncrementTriggerAndSequence(this);
        return "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        createAutoIncrementTriggerAndSequence(this);
        return "number(20, 0) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      floating(precision) {
        const parsedPrecision = toNumber(precision, 0);
        return `float${parsedPrecision ? `(${parsedPrecision})` : ""}`;
      }
      double(precision, scale) {
        return `number(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      decimal(precision, scale) {
        if (precision === null) return "decimal";
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      integer(length) {
        return length ? `number(${toNumber(length, 11)})` : "integer";
      }
      enu(allowed) {
        allowed = uniq(allowed);
        const maxLength = (allowed || []).reduce(
          (maxLength2, name) => Math.max(maxLength2, String(name).length),
          1
        );
        this.columnBuilder._modifiers.checkIn = [allowed];
        return `varchar2(${maxLength})`;
      }
      datetime(without) {
        return without ? "timestamp" : "timestamp with time zone";
      }
      timestamp(without) {
        return without ? "timestamp" : "timestamp with time zone";
      }
      bool() {
        this.columnBuilder._modifiers.checkIn = [[0, 1]];
        return "number(1, 0)";
      }
      varchar(length) {
        return `varchar2(${toNumber(length, 255)})`;
      }
      // Modifiers
      // ------
      comment(comment) {
        const columnName = this.args[0] || this.defaults("columnName");
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(columnName) + " is '" + (comment || "") + "'"
          );
        }, comment);
      }
      checkIn(value) {
        if (value === void 0) {
          return "";
        } else if (value instanceof Raw) {
          value = value.toQuery();
        } else if (Array.isArray(value)) {
          value = value.map((v6) => `'${v6}'`).join(", ");
        } else {
          value = `'${value}'`;
        }
        return `check (${this.formatter.wrap(this.args[0])} in (${value}))`;
      }
    };
    ColumnCompiler_Oracle.prototype.tinyint = "smallint";
    ColumnCompiler_Oracle.prototype.smallint = "smallint";
    ColumnCompiler_Oracle.prototype.mediumint = "integer";
    ColumnCompiler_Oracle.prototype.biginteger = "number(20, 0)";
    ColumnCompiler_Oracle.prototype.text = "clob";
    ColumnCompiler_Oracle.prototype.time = "timestamp with time zone";
    ColumnCompiler_Oracle.prototype.bit = "clob";
    ColumnCompiler_Oracle.prototype.json = "clob";
    module.exports = ColumnCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-tablecompiler.js
var require_oracle_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-tablecompiler.js"(exports, module) {
    var utils = require_utils6();
    var TableCompiler = require_tablecompiler();
    var helpers = require_helpers();
    var Trigger = require_trigger();
    var { isObject } = require_is();
    var TableCompiler_Oracle = class extends TableCompiler {
      constructor() {
        super(...arguments);
      }
      addColumns(columns, prefix) {
        if (columns.sql.length > 0) {
          prefix = prefix || this.addColumnsPrefix;
          const columnSql = columns.sql;
          const alter = this.lowerCase ? "alter table " : "ALTER TABLE ";
          let sql = `${alter}${this.tableName()} ${prefix}`;
          if (columns.sql.length > 1) {
            sql += `(${columnSql.join(", ")})`;
          } else {
            sql += columnSql.join(", ");
          }
          this.pushQuery({
            sql,
            bindings: columns.bindings
          });
        }
      }
      // Compile a rename column command.
      renameColumn(from, to) {
        const tableName = this.tableName().slice(1, -1);
        const trigger = new Trigger(this.client.version);
        return this.pushQuery(
          trigger.renameColumnTrigger(this.client.logger, tableName, from, to)
        );
      }
      compileAdd(builder) {
        const table = this.formatter.wrap(builder);
        const columns = this.prefixArray("add column", this.getColumns(builder));
        return this.pushQuery({
          sql: `alter table ${table} ${columns.join(", ")}`
        });
      }
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const columnsSql = like && this.tableNameLike() ? " as (select * from " + this.tableNameLike() + " where 0=1)" : " (" + columns.sql.join(", ") + this._addChecks() + ")";
        const sql = `create table ${this.tableName()}${columnsSql}`;
        this.pushQuery({
          // catch "name is already used by an existing object" for workaround for "if not exists"
          sql: ifNot ? utils.wrapSqlWithCatch(sql, -955) : sql,
          bindings: columns.bindings
        });
        if (this.single.comment) this.comment(this.single.comment);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(`comment on table ${this.tableName()} is '${comment}'`);
      }
      dropColumn() {
        const columns = helpers.normalizeArr.apply(null, arguments);
        this.pushQuery(
          `alter table ${this.tableName()} drop (${this.formatter.columnize(
            columns
          )})`
        );
      }
      _indexCommand(type, tableName, columns) {
        const nameHelper = new utils.NameHelper(this.client.version);
        return this.formatter.wrap(
          nameHelper.generateCombinedName(
            this.client.logger,
            type,
            tableName,
            columns
          )
        );
      }
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        const primaryCols = columns;
        let incrementsCols = [];
        if (this.grouped.columns) {
          incrementsCols = this._getIncrementsColumnNames();
          if (incrementsCols) {
            incrementsCols.forEach((c3) => {
              if (!primaryCols.includes(c3)) {
                primaryCols.unshift(c3);
              }
            });
          }
        }
        this.pushQuery(
          `alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(
            primaryCols
          )})${deferrable}`
        );
      }
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + "_pkey");
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${constraintName}`
        );
      }
      index(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(
          `create index ${indexName} on ${this.tableName()} (` + this.formatter.columnize(columns) + ")"
        );
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      unique(columns, indexName) {
        let deferrable;
        if (isObject(indexName)) {
          ({ indexName, deferrable } = indexName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} add constraint ${indexName} unique (` + this.formatter.columnize(columns) + ")" + deferrable
        );
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
    };
    TableCompiler_Oracle.prototype.addColumnsPrefix = "add ";
    TableCompiler_Oracle.prototype.alterColumnsPrefix = "modify ";
    module.exports = TableCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/index.js
var require_oracle = __commonJS({
  "node_modules/knex/lib/dialects/oracle/index.js"(exports, module) {
    var { ReturningHelper } = require_utils6();
    var { isConnectionError } = require_utils6();
    var Client = require_client();
    var SchemaCompiler = require_oracle_compiler();
    var ColumnBuilder = require_oracle_columnbuilder();
    var ColumnCompiler = require_oracle_columncompiler();
    var TableCompiler = require_oracle_tablecompiler();
    var Client_Oracle = class extends Client {
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      columnBuilder() {
        return new ColumnBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      // Return the database for the Oracle client.
      database() {
        return this.connectionSettings.database;
      }
      // Position the bindings for the query.
      positionBindings(sql) {
        let questionCount = 0;
        return sql.replace(/\?/g, function() {
          questionCount += 1;
          return `:${questionCount}`;
        });
      }
      _stream(connection, obj, stream2, options) {
        if (!obj.sql) throw new Error("The query is empty");
        return new Promise(function(resolver, rejecter) {
          stream2.on("error", (err) => {
            if (isConnectionError(err)) {
              connection.__knex__disposed = err;
            }
            rejecter(err);
          });
          stream2.on("end", resolver);
          const queryStream = connection.queryStream(
            obj.sql,
            obj.bindings,
            options
          );
          queryStream.pipe(stream2);
          queryStream.on("error", function(error) {
            rejecter(error);
            stream2.emit("error", error);
          });
        });
      }
      // Formatter part
      alias(first, second) {
        return first + " " + second;
      }
      parameter(value, builder, formatter) {
        if (value instanceof ReturningHelper && this.driver) {
          value = new this.driver.OutParam(this.driver.OCCISTRING);
        } else if (typeof value === "boolean") {
          value = value ? 1 : 0;
        }
        return super.parameter(value, builder, formatter);
      }
    };
    Object.assign(Client_Oracle.prototype, {
      dialect: "oracle",
      driverName: "oracle"
    });
    module.exports = Client_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js
var require_oracle_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js"(exports, module) {
    var compact = require_compact();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var { ReturningHelper } = require_utils6();
    var { isString } = require_is();
    var components = [
      "comments",
      "columns",
      "join",
      "where",
      "union",
      "group",
      "having",
      "order",
      "lock"
    ];
    var QueryCompiler_Oracle = class extends QueryCompiler {
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { onConflict } = this.single;
        if (onConflict) {
          throw new Error(".onConflict() is not supported for oracledb.");
        }
        this.first = this.select;
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let insertValues = this.single.insert || [];
        let { returning } = this.single;
        if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {
          insertValues = [this.single.insert];
        }
        if (returning && !Array.isArray(returning)) {
          returning = [returning];
        }
        if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} (${this.formatter.wrap(
              this.single.returning
            )}) values (default)`,
            returning,
            this.tableName
          );
        }
        if (isEmpty(this.single.insert) && typeof this.single.insert !== "function") {
          return "";
        }
        const insertData = this._prepInsert(insertValues);
        const sql = {};
        if (isString(insertData)) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} ${insertData}`,
            returning
          );
        }
        if (insertData.values.length === 1) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} (${this.formatter.columnize(
              insertData.columns
            )}) values (${this.client.parameterize(
              insertData.values[0],
              void 0,
              this.builder,
              this.bindingsHolder
            )})`,
            returning,
            this.tableName
          );
        }
        const insertDefaultsOnly = insertData.columns.length === 0;
        sql.sql = "begin " + insertData.values.map((value) => {
          let returningHelper;
          const parameterizedValues = !insertDefaultsOnly ? this.client.parameterize(
            value,
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          ) : "";
          const returningValues = Array.isArray(returning) ? returning : [returning];
          let subSql = `insert into ${this.tableName} `;
          if (returning) {
            returningHelper = new ReturningHelper(returningValues.join(":"));
            sql.outParams = (sql.outParams || []).concat(returningHelper);
          }
          if (insertDefaultsOnly) {
            subSql += `(${this.formatter.wrap(
              this.single.returning
            )}) values (default)`;
          } else {
            subSql += `(${this.formatter.columnize(
              insertData.columns
            )}) values (${parameterizedValues})`;
          }
          subSql += returning ? ` returning ROWID into ${this.client.parameter(
            returningHelper,
            this.builder,
            this.bindingsHolder
          )}` : "";
          subSql = this.formatter.client.positionBindings(subSql);
          const parameterizedValuesWithoutDefault = parameterizedValues.replace("DEFAULT, ", "").replace(", DEFAULT", "");
          return `execute immediate '${subSql.replace(/'/g, "''")}` + (parameterizedValuesWithoutDefault || returning ? "' using " : "") + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ", " : "") + (returning ? "out ?" : "") + ";";
        }).join(" ") + "end;";
        if (returning) {
          sql.returning = returning;
          sql.returningSql = `select ${this.formatter.columnize(returning)} from ` + this.tableName + " where ROWID in (" + sql.outParams.map((v6, i3) => `:${i3 + 1}`).join(", ") + ") order by case ROWID " + sql.outParams.map((v6, i3) => `when CHARTOROWID(:${i3 + 1}) then ${i3}`).join(" ") + " end";
        }
        return sql;
      }
      // Update method, including joins, wheres, order & limits.
      update() {
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        let { returning } = this.single;
        const sql = `update ${this.tableName} set ` + updates.join(", ") + (where ? ` ${where}` : "");
        if (!returning) {
          return sql;
        }
        if (!Array.isArray(returning)) {
          returning = [returning];
        }
        return this._addReturningToSqlAndConvert(sql, returning, this.tableName);
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate table ${this.tableName}`;
      }
      forUpdate() {
        return "for update";
      }
      forShare() {
        this.client.logger.warn(
          "lock for share is not supported by oracle dialect"
        );
        return "";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        const sql = `select * from xmltable( '/ROWSET/ROW'
      passing dbms_xmlgen.getXMLType('
      select char_col_decl_length, column_name, data_type, data_default, nullable
      from all_tab_columns where table_name = ''${table}'' ')
      columns
      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),
      DATA_DEFAULT clob, NULLABLE varchar2(1))`;
        return {
          sql,
          output(resp) {
            const out = reduce(
              resp,
              function(columns, val2) {
                columns[val2.COLUMN_NAME] = {
                  type: val2.DATA_TYPE,
                  defaultValue: val2.DATA_DEFAULT,
                  maxLength: val2.CHAR_COL_DECL_LENGTH,
                  nullable: val2.NULLABLE === "Y"
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      select() {
        let query = this.with();
        const statements = components.map((component) => {
          return this[component]();
        });
        query += compact(statements).join(" ");
        return this._surroundQueryWithLimitAndOffset(query);
      }
      aggregate(stmt) {
        return this._aggregate(stmt, { aliasSeparator: " " });
      }
      // for single commands only
      _addReturningToSqlAndConvert(sql, returning, tableName) {
        const res = {
          sql
        };
        if (!returning) {
          return res;
        }
        const returningValues = Array.isArray(returning) ? returning : [returning];
        const returningHelper = new ReturningHelper(returningValues.join(":"));
        res.sql = sql + " returning ROWID into " + this.client.parameter(returningHelper, this.builder, this.bindingsHolder);
        res.returningSql = `select ${this.formatter.columnize(
          returning
        )} from ${tableName} where ROWID = :1`;
        res.outParams = [returningHelper];
        res.returning = returning;
        return res;
      }
      _surroundQueryWithLimitAndOffset(query) {
        let { limit } = this.single;
        const { offset } = this.single;
        const hasLimit = limit || limit === 0 || limit === "0";
        limit = +limit;
        if (!hasLimit && !offset) return query;
        query = query || "";
        if (hasLimit && !offset) {
          return `select * from (${query}) where rownum <= ${this._getValueOrParameterFromAttribute(
            "limit",
            limit
          )}`;
        }
        const endRow = +offset + (hasLimit ? limit : 1e13);
        return "select * from (select row_.*, ROWNUM rownum_ from (" + query + ") row_ where rownum <= " + (this.single.skipBinding["offset"] ? endRow : this.client.parameter(endRow, this.builder, this.bindingsHolder)) + ") where rownum_ > " + this._getValueOrParameterFromAttribute("offset", offset);
      }
    };
    module.exports = QueryCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracledb/utils.js
var require_utils7 = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/utils.js"(exports, module) {
    var Utils = require_utils6();
    var { promisify } = __require("util");
    var stream2 = __require("stream");
    function BlobHelper(columnName, value) {
      this.columnName = columnName;
      this.value = value;
      this.returning = false;
    }
    BlobHelper.prototype.toString = function() {
      return "[object BlobHelper:" + this.columnName + "]";
    };
    function readStream(stream3, type) {
      return new Promise((resolve, reject) => {
        let data = type === "string" ? "" : Buffer.alloc(0);
        stream3.on("error", function(err) {
          reject(err);
        });
        stream3.on("data", function(chunk) {
          if (type === "string") {
            data += chunk;
          } else {
            data = Buffer.concat([data, chunk]);
          }
        });
        stream3.on("end", function() {
          resolve(data);
        });
      });
    }
    var lobProcessing = function(stream3) {
      const oracledb = __require("oracledb");
      let type;
      if (stream3.type) {
        if (stream3.type === oracledb.BLOB) {
          type = "buffer";
        } else if (stream3.type === oracledb.CLOB) {
          type = "string";
        }
      } else if (stream3.iLob) {
        if (stream3.iLob.type === oracledb.CLOB) {
          type = "string";
        } else if (stream3.iLob.type === oracledb.BLOB) {
          type = "buffer";
        }
      } else {
        throw new Error("Unrecognized oracledb lob stream type");
      }
      if (type === "string") {
        stream3.setEncoding("utf-8");
      }
      return readStream(stream3, type);
    };
    function monkeyPatchConnection(connection, client) {
      if (connection.executeAsync) {
        return;
      }
      connection.commitAsync = function() {
        return new Promise((commitResolve, commitReject) => {
          this.commit(function(err) {
            if (err) {
              return commitReject(err);
            }
            commitResolve();
          });
        });
      };
      connection.rollbackAsync = function() {
        return new Promise((rollbackResolve, rollbackReject) => {
          this.rollback(function(err) {
            if (err) {
              return rollbackReject(err);
            }
            rollbackResolve();
          });
        });
      };
      const fetchAsync = promisify(function(sql, bindParams, options, cb) {
        options = options || {};
        options.outFormat = client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;
        if (!options.outFormat) {
          throw new Error("not found oracledb.outFormat constants");
        }
        if (options.resultSet) {
          connection.execute(
            sql,
            bindParams || [],
            options,
            function(err, result) {
              if (err) {
                if (Utils.isConnectionError(err)) {
                  connection.close().catch(function(err2) {
                  });
                  connection.__knex__disposed = err;
                }
                return cb(err);
              }
              const fetchResult = { rows: [], resultSet: result.resultSet };
              const numRows = 100;
              const fetchRowsFromRS = function(connection2, resultSet, numRows2) {
                resultSet.getRows(numRows2, function(err2, rows) {
                  if (err2) {
                    if (Utils.isConnectionError(err2)) {
                      connection2.close().catch(function(err3) {
                      });
                      connection2.__knex__disposed = err2;
                    }
                    resultSet.close(function() {
                      return cb(err2);
                    });
                  } else if (rows.length === 0) {
                    return cb(null, fetchResult);
                  } else if (rows.length > 0) {
                    if (rows.length === numRows2) {
                      fetchResult.rows = fetchResult.rows.concat(rows);
                      fetchRowsFromRS(connection2, resultSet, numRows2);
                    } else {
                      fetchResult.rows = fetchResult.rows.concat(rows);
                      return cb(null, fetchResult);
                    }
                  }
                });
              };
              fetchRowsFromRS(connection, result.resultSet, numRows);
            }
          );
        } else {
          connection.execute(
            sql,
            bindParams || [],
            options,
            function(err, result) {
              if (err) {
                if (Utils.isConnectionError(err)) {
                  connection.close().catch(function(err2) {
                  });
                  connection.__knex__disposed = err;
                }
                return cb(err);
              }
              return cb(null, result);
            }
          );
        }
      });
      connection.executeAsync = function(sql, bindParams, options) {
        return fetchAsync(sql, bindParams, options).then(async (results) => {
          const closeResultSet = () => {
            return results.resultSet ? promisify(results.resultSet.close).call(results.resultSet) : Promise.resolve();
          };
          const lobs = [];
          if (results.rows) {
            if (Array.isArray(results.rows)) {
              for (let i3 = 0; i3 < results.rows.length; i3++) {
                const row = results.rows[i3];
                for (const column in row) {
                  if (row[column] instanceof stream2.Readable) {
                    lobs.push({ index: i3, key: column, stream: row[column] });
                  }
                }
              }
            }
          }
          try {
            for (const lob of lobs) {
              results.rows[lob.index][lob.key] = await lobProcessing(lob.stream);
            }
          } catch (e3) {
            await closeResultSet().catch(() => {
            });
            throw e3;
          }
          await closeResultSet();
          return results;
        });
      };
    }
    Utils.BlobHelper = BlobHelper;
    Utils.monkeyPatchConnection = monkeyPatchConnection;
    module.exports = Utils;
  }
});

// node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js
var require_oracledb_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js"(exports, module) {
    var clone = require_clone();
    var each = require_each();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var Oracle_Compiler = require_oracle_querycompiler();
    var ReturningHelper = require_utils7().ReturningHelper;
    var BlobHelper = require_utils7().BlobHelper;
    var { isString } = require_is();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var Oracledb_Compiler = class extends Oracle_Compiler {
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const self2 = this;
        const outBindPrep = this._prepOutbindings(
          this.single.insert,
          this.single.returning
        );
        const outBinding = outBindPrep.outBinding;
        const returning = outBindPrep.returning;
        const insertValues = outBindPrep.values;
        if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {
          const returningFragment = this.single.returning ? " (" + this.formatter.wrap(this.single.returning) + ")" : "";
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + returningFragment + " values (default)",
            outBinding[0],
            this.tableName,
            returning
          );
        }
        if (isEmpty(this.single.insert) && typeof this.single.insert !== "function") {
          return "";
        }
        const insertData = this._prepInsert(insertValues);
        const sql = {};
        if (isString(insertData)) {
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + " " + insertData,
            outBinding[0],
            this.tableName,
            returning
          );
        }
        if (insertData.values.length === 1) {
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + " (" + this.formatter.columnize(insertData.columns) + ") values (" + this.client.parameterize(
              insertData.values[0],
              void 0,
              this.builder,
              this.bindingsHolder
            ) + ")",
            outBinding[0],
            this.tableName,
            returning
          );
        }
        const insertDefaultsOnly = insertData.columns.length === 0;
        sql.returning = returning;
        sql.sql = "begin " + insertData.values.map(function(value, index) {
          const parameterizedValues = !insertDefaultsOnly ? self2.client.parameterize(
            value,
            self2.client.valueForUndefined,
            self2.builder,
            self2.bindingsHolder
          ) : "";
          let subSql = "insert into " + self2.tableName;
          if (insertDefaultsOnly) {
            subSql += " (" + self2.formatter.wrap(self2.single.returning) + ") values (default)";
          } else {
            subSql += " (" + self2.formatter.columnize(insertData.columns) + ") values (" + parameterizedValues + ")";
          }
          let returningClause = "";
          let intoClause = "";
          let usingClause = "";
          let outClause = "";
          each(value, function(val2) {
            if (!(val2 instanceof BlobHelper)) {
              usingClause += " ?,";
            }
          });
          usingClause = usingClause.slice(0, -1);
          outBinding[index].forEach(function(ret) {
            const columnName = ret.columnName || ret;
            returningClause += self2.formatter.wrap(columnName) + ",";
            intoClause += " ?,";
            outClause += " out ?,";
            if (ret instanceof BlobHelper) {
              return self2.formatter.bindings.push(ret);
            }
            self2.formatter.bindings.push(new ReturningHelper(columnName));
          });
          returningClause = returningClause.slice(0, -1);
          intoClause = intoClause.slice(0, -1);
          outClause = outClause.slice(0, -1);
          if (returningClause && intoClause) {
            subSql += " returning " + returningClause + " into" + intoClause;
          }
          subSql = self2.formatter.client.positionBindings(subSql);
          const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues.replace(/DEFAULT, /g, "").replace(/, DEFAULT/g, "").replace("EMPTY_BLOB(), ", "").replace(", EMPTY_BLOB()", "");
          return "execute immediate '" + subSql.replace(/'/g, "''") + (parameterizedValuesWithoutDefaultAndBlob || value ? "' using " : "") + parameterizedValuesWithoutDefaultAndBlob + (parameterizedValuesWithoutDefaultAndBlob && outClause ? "," : "") + outClause + ";";
        }).join(" ") + "end;";
        sql.outBinding = outBinding;
        if (returning[0] === "*") {
          sql.returningSql = function() {
            return "select * from " + self2.tableName + " where ROWID in (" + this.outBinding.map(function(v6, i3) {
              return ":" + (i3 + 1);
            }).join(", ") + ") order by case ROWID " + this.outBinding.map(function(v6, i3) {
              return "when CHARTOROWID(:" + (i3 + 1) + ") then " + i3;
            }).join(" ") + " end";
          };
        }
        return sql;
      }
      with() {
        const undoList = [];
        if (this.grouped.with) {
          for (const stmt of this.grouped.with) {
            if (stmt.recursive) {
              undoList.push(stmt);
              stmt.recursive = false;
            }
          }
        }
        const result = super.with();
        for (const stmt of undoList) {
          stmt.recursive = true;
        }
        return result;
      }
      _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {
        const self2 = this;
        const res = {
          sql
        };
        if (!outBinding) {
          return res;
        }
        const returningValues = Array.isArray(outBinding) ? outBinding : [outBinding];
        let returningClause = "";
        let intoClause = "";
        returningValues.forEach(function(ret) {
          const columnName = ret.columnName || ret;
          returningClause += self2.formatter.wrap(columnName) + ",";
          intoClause += "?,";
          if (ret instanceof BlobHelper) {
            return self2.formatter.bindings.push(ret);
          }
          self2.formatter.bindings.push(new ReturningHelper(columnName));
        });
        res.sql = sql;
        returningClause = returningClause.slice(0, -1);
        intoClause = intoClause.slice(0, -1);
        if (returningClause && intoClause) {
          res.sql += " returning " + returningClause + " into " + intoClause;
        }
        res.outBinding = [outBinding];
        if (returning[0] === "*") {
          res.returningSql = function() {
            return "select * from " + self2.tableName + " where ROWID = :1";
          };
        }
        res.returning = returning;
        return res;
      }
      _prepOutbindings(paramValues, paramReturning) {
        const result = {};
        let params = paramValues || [];
        let returning = paramReturning || [];
        if (!Array.isArray(params) && isPlainObject(paramValues)) {
          params = [params];
        }
        if (returning && !Array.isArray(returning)) {
          returning = [returning];
        }
        const outBinding = [];
        each(params, function(values, index) {
          if (returning[0] === "*") {
            outBinding[index] = ["ROWID"];
          } else {
            outBinding[index] = clone(returning);
          }
          each(values, function(value, key) {
            if (value instanceof Buffer) {
              values[key] = new BlobHelper(key, value);
              const blobIndex = outBinding[index].indexOf(key);
              if (blobIndex >= 0) {
                outBinding[index].splice(blobIndex, 1);
                values[key].returning = true;
              }
              outBinding[index].push(values[key]);
            }
            if (value === void 0) {
              delete params[index][key];
            }
          });
        });
        result.returning = returning;
        result.outBinding = outBinding;
        result.values = params;
        return result;
      }
      _groupOrder(item, type) {
        return super._groupOrderNulls(item, type);
      }
      update() {
        const self2 = this;
        const sql = {};
        const outBindPrep = this._prepOutbindings(
          this.single.update || this.single.counter,
          this.single.returning
        );
        const outBinding = outBindPrep.outBinding;
        const returning = outBindPrep.returning;
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        let returningClause = "";
        let intoClause = "";
        if (isEmpty(updates) && typeof this.single.update !== "function") {
          return "";
        }
        outBinding.forEach(function(out) {
          out.forEach(function(ret) {
            const columnName = ret.columnName || ret;
            returningClause += self2.formatter.wrap(columnName) + ",";
            intoClause += " ?,";
            if (ret instanceof BlobHelper) {
              return self2.formatter.bindings.push(ret);
            }
            self2.formatter.bindings.push(new ReturningHelper(columnName));
          });
        });
        returningClause = returningClause.slice(0, -1);
        intoClause = intoClause.slice(0, -1);
        sql.outBinding = outBinding;
        sql.returning = returning;
        sql.sql = "update " + this.tableName + " set " + updates.join(", ") + (where ? " " + where : "");
        if (outBinding.length && !isEmpty(outBinding[0])) {
          sql.sql += " returning " + returningClause + " into" + intoClause;
        }
        if (returning[0] === "*") {
          sql.returningSql = function() {
            let sql2 = "select * from " + self2.tableName;
            const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;
            let returningSqlIn = " where ROWID in (";
            let returningSqlOrderBy = ") order by case ROWID ";
            for (let i3 = 0; i3 < modifiedRowsCount; i3++) {
              if (this.returning[0] === "*") {
                returningSqlIn += ":" + (i3 + 1) + ", ";
                returningSqlOrderBy += "when CHARTOROWID(:" + (i3 + 1) + ") then " + i3 + " ";
              }
            }
            if (this.returning[0] === "*") {
              this.returning = this.returning.slice(0, -1);
              returningSqlIn = returningSqlIn.slice(0, -2);
              returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);
            }
            return sql2 += returningSqlIn + returningSqlOrderBy + " end";
          };
        }
        return sql;
      }
      _jsonPathWrap(extraction) {
        return `'${extraction.path || extraction[1]}'`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract(
          params.singleValue ? "json_value" : "json_query",
          params
        );
      }
      jsonSet(params) {
        return `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, set ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )} = ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
      }
      jsonInsert(params) {
        return `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, insert ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )} = ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
      }
      jsonRemove(params) {
        const jsonCol = `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, remove ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_value", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by Oracle"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error(
          "Json subset where clause not actually supported by Oracle"
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_value", clause);
      }
    };
    module.exports = Oracledb_Compiler;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-tablecompiler.js
var require_oracledb_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-tablecompiler.js"(exports, module) {
    var TableCompiler_Oracle = require_oracle_tablecompiler();
    var TableCompiler_Oracledb = class extends TableCompiler_Oracle {
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      _setNullableState(column, isNullable) {
        const nullability = isNullable ? "NULL" : "NOT NULL";
        const sql = `alter table ${this.tableName()} modify (${this.formatter.wrap(
          column
        )} ${nullability})`;
        return this.pushQuery({
          sql
        });
      }
    };
    module.exports = TableCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-columncompiler.js
var require_oracledb_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-columncompiler.js"(exports, module) {
    var ColumnCompiler_Oracle = require_oracle_columncompiler();
    var { isObject } = require_is();
    var ColumnCompiler_Oracledb = class extends ColumnCompiler_Oracle {
      constructor() {
        super(...arguments);
        this.modifiers = ["defaultTo", "nullable", "comment", "checkJson"];
        this._addCheckModifiers();
      }
      datetime(withoutTz) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        return useTz ? "timestamp with local time zone" : "timestamp";
      }
      timestamp(withoutTz) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        return useTz ? "timestamp with local time zone" : "timestamp";
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `REGEXP_LIKE(${this.formatter.wrap(
            this.getColumnName()
          )},${this.client._escapeBinding(regex)})`,
          constraintName
        );
      }
      json() {
        this.columnBuilder._modifiers.checkJson = [
          this.formatter.columnize(this.getColumnName())
        ];
        return "varchar2(4000)";
      }
      jsonb() {
        return this.json();
      }
      checkJson(column) {
        return `check (${column} is json)`;
      }
    };
    ColumnCompiler_Oracledb.prototype.time = "timestamp with local time zone";
    ColumnCompiler_Oracledb.prototype.uuid = ({ useBinaryUuid = false } = {}) => useBinaryUuid ? "raw(16)" : "char(36)";
    module.exports = ColumnCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewcompiler.js
var require_oracledb_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewcompiler.js"(exports, module) {
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_Oracledb = class extends ViewCompiler {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
      createMaterializedView() {
        this.createQuery(this.columns, this.selectQuery, true);
      }
    };
    module.exports = ViewCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewbuilder.js
var require_oracledb_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewbuilder.js"(exports, module) {
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_Oracledb = class extends ViewBuilder {
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
    };
    module.exports = ViewBuilder_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/transaction.js
var require_transaction5 = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/transaction.js"(exports, module) {
    var Transaction = require_transaction();
    var { timeout, KnexTimeoutError } = require_timeout();
    var debugTx = require_src()("knex:tx");
    var supportedIsolationLevels = ["read committed", "serializable"];
    var isIsolationLevelEnabled = false;
    module.exports = class Oracle_Transaction extends Transaction {
      // disable autocommit to allow correct behavior (default is true)
      begin(conn) {
        if (this.isolationLevel) {
          if (isIsolationLevelEnabled) {
            if (!supportedIsolationLevels.includes(this.isolationLevel)) {
              this.client.logger.warn(
                "Oracle only supports read committed and serializable transactions, ignoring the isolation level param"
              );
            } else {
              return this.query(conn, `SET TRANSACTION ${this.isolationLevel}`);
            }
          } else {
            this.client.logger.warn(
              "Transaction isolation is not currently supported for Oracle"
            );
          }
        }
        return Promise.resolve();
      }
      async commit(conn, value) {
        this._completed = true;
        try {
          await conn.commitAsync();
          this._resolver(value);
        } catch (err) {
          this._rejecter(err);
        }
      }
      release(conn, value) {
        return this._resolver(value);
      }
      rollback(conn, err) {
        this._completed = true;
        debugTx("%s: rolling back", this.txid);
        return timeout(conn.rollbackAsync(), 5e3).catch((e3) => {
          if (!(e3 instanceof KnexTimeoutError)) {
            return Promise.reject(e3);
          }
          this._rejecter(e3);
        }).then(() => {
          if (err === void 0) {
            if (this.doNotRejectOnRollback) {
              this._resolver();
              return;
            }
            err = new Error(`Transaction rejected with non-error: ${err}`);
          }
          this._rejecter(err);
        });
      }
      savepoint(conn) {
        return this.query(conn, `SAVEPOINT ${this.txid}`);
      }
      async acquireConnection(config, cb) {
        const configConnection = config && config.connection;
        const connection = configConnection || await this.client.acquireConnection();
        try {
          connection.__knexTxId = this.txid;
          connection.isTransaction = true;
          return await cb(connection);
        } finally {
          debugTx("%s: releasing connection", this.txid);
          connection.isTransaction = false;
          try {
            await connection.commitAsync();
          } catch (err) {
            this._rejecter(err);
          } finally {
            if (!configConnection) {
              await this.client.releaseConnection(connection);
            } else {
              debugTx("%s: not releasing external connection", this.txid);
            }
          }
        }
      }
    };
  }
});

// node_modules/knex/lib/dialects/oracledb/index.js
var require_oracledb = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/index.js"(exports, module) {
    var each = require_each();
    var flatten = require_flatten();
    var isEmpty = require_isEmpty();
    var map2 = require_map();
    var Formatter = require_formatter();
    var QueryCompiler = require_oracledb_querycompiler();
    var TableCompiler = require_oracledb_tablecompiler();
    var ColumnCompiler = require_oracledb_columncompiler();
    var {
      BlobHelper,
      ReturningHelper,
      monkeyPatchConnection
    } = require_utils7();
    var ViewCompiler = require_oracledb_viewcompiler();
    var ViewBuilder = require_oracledb_viewbuilder();
    var Transaction = require_transaction5();
    var Client_Oracle = require_oracle();
    var { isString } = require_is();
    var { outputQuery, unwrapRaw } = require_wrappingFormatter();
    var { compileCallback } = require_formatterUtils();
    var Client_Oracledb = class extends Client_Oracle {
      constructor(config) {
        super(config);
        if (this.version) {
          this.version = parseVersion(this.version);
        }
        if (this.driver) {
          process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;
          process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;
        }
      }
      _driver() {
        const client = this;
        const oracledb = __require("oracledb");
        client.fetchAsString = [];
        if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {
          this.config.fetchAsString.forEach(function(type) {
            if (!isString(type)) return;
            type = type.toUpperCase();
            if (oracledb[type]) {
              if (type !== "NUMBER" && type !== "DATE" && type !== "CLOB" && type !== "BUFFER") {
                this.logger.warn(
                  'Only "date", "number", "clob" and "buffer" are supported for fetchAsString'
                );
              }
              client.fetchAsString.push(oracledb[type]);
            }
          });
        }
        return oracledb;
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      formatter(builder) {
        return new Formatter(this, builder);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      prepBindings(bindings) {
        return map2(bindings, (value) => {
          if (value instanceof BlobHelper && this.driver) {
            return { type: this.driver.BLOB, dir: this.driver.BIND_OUT };
          } else if (value instanceof ReturningHelper && this.driver) {
            return { type: this.driver.STRING, dir: this.driver.BIND_OUT };
          } else if (typeof value === "boolean") {
            return value ? 1 : 0;
          }
          return value;
        });
      }
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter(value, builder, formatter) {
        if (typeof value === "function") {
          return outputQuery(
            compileCallback(value, void 0, this, formatter),
            true,
            builder,
            this
          );
        } else if (value instanceof BlobHelper) {
          formatter.bindings.push(value.value);
          return "?";
        }
        return unwrapRaw(value, true, builder, this, formatter) || "?";
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          const oracleDbConfig = this.connectionSettings.externalAuth ? { externalAuth: this.connectionSettings.externalAuth } : {
            user: this.connectionSettings.user,
            password: this.connectionSettings.password
          };
          oracleDbConfig.connectString = resolveConnectString(
            this.connectionSettings
          );
          if (this.connectionSettings.prefetchRowCount) {
            oracleDbConfig.prefetchRows = this.connectionSettings.prefetchRowCount;
          }
          if (this.connectionSettings.stmtCacheSize !== void 0) {
            oracleDbConfig.stmtCacheSize = this.connectionSettings.stmtCacheSize;
          }
          this.driver.fetchAsString = this.fetchAsString;
          this.driver.getConnection(oracleDbConfig, (err, connection) => {
            if (err) {
              return rejecter(err);
            }
            monkeyPatchConnection(connection, this);
            resolver(connection);
          });
        });
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      destroyRawConnection(connection) {
        return connection.release();
      }
      // Handle oracle version resolution on acquiring connection from pool instead of connection creation.
      // Must do this here since only the client used to create a connection would be updated with version
      // information on creation. Poses a problem when knex instance is cloned since instances share the
      // connection pool while having their own client instances.
      async acquireConnection() {
        const connection = await super.acquireConnection();
        this.checkVersion(connection);
        return connection;
      }
      // In Oracle, we need to check the version to dynamically determine
      // certain limits. If user did not specify a version, get it from the connection.
      checkVersion(connection) {
        if (this.version) {
          return this.version;
        }
        const detectedVersion = parseVersion(connection.oracleServerVersionString);
        if (!detectedVersion) {
          throw new Error(
            this.version === null ? "Invalid Oracledb version number format passed to knex. Unable to successfully auto-detect as fallback. Please specify a valid oracledb version." : "Unable to detect Oracledb version number automatically. Please specify the version in knex configuration."
          );
        }
        this.version = detectedVersion;
        return detectedVersion;
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        const options = Object.assign({}, obj.options, { autoCommit: false });
        if (obj.method === "select") {
          options.resultSet = true;
        }
        return connection.executeAsync(obj.sql, obj.bindings, options).then(async function(response) {
          let outBinds = flatten(response.outBinds);
          obj.response = response.rows || [];
          obj.rowsAffected = response.rows ? response.rows.rowsAffected : response.rowsAffected;
          if (obj.method === "raw" && outBinds.length > 0) {
            return {
              response: outBinds
            };
          }
          if (obj.method === "update") {
            const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;
            const updatedObjOutBinding = [];
            const updatedOutBinds = [];
            const updateOutBinds = (i3) => function(value, index) {
              const OutBindsOffset = index * modifiedRowsCount;
              updatedOutBinds.push(outBinds[i3 + OutBindsOffset]);
            };
            for (let i3 = 0; i3 < modifiedRowsCount; i3++) {
              updatedObjOutBinding.push(obj.outBinding[0]);
              each(obj.outBinding[0], updateOutBinds(i3));
            }
            outBinds = updatedOutBinds;
            obj.outBinding = updatedObjOutBinding;
          }
          if (!obj.returning && outBinds.length === 0) {
            if (!connection.isTransaction) {
              await connection.commitAsync();
            }
            return obj;
          }
          const rowIds = [];
          let offset = 0;
          for (let line = 0; line < obj.outBinding.length; line++) {
            const ret = obj.outBinding[line];
            offset = offset + (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);
            for (let index = 0; index < ret.length; index++) {
              const out = ret[index];
              await new Promise(function(bindResolver, bindRejecter) {
                if (out instanceof BlobHelper) {
                  const blob = outBinds[index + offset];
                  if (out.returning) {
                    obj.response[line] = obj.response[line] || {};
                    obj.response[line][out.columnName] = out.value;
                  }
                  blob.on("error", function(err) {
                    bindRejecter(err);
                  });
                  blob.on("finish", function() {
                    bindResolver();
                  });
                  blob.write(out.value);
                  blob.end();
                } else if (obj.outBinding[line][index] === "ROWID") {
                  rowIds.push(outBinds[index + offset]);
                  bindResolver();
                } else {
                  obj.response[line] = obj.response[line] || {};
                  obj.response[line][out] = outBinds[index + offset];
                  bindResolver();
                }
              });
            }
          }
          if (obj.returningSql) {
            const response2 = await connection.executeAsync(
              obj.returningSql(),
              rowIds,
              { resultSet: true }
            );
            obj.response = response2.rows;
          }
          if (connection.isTransaction) {
            return obj;
          }
          await connection.commitAsync();
          return obj;
        });
      }
      // Process the response as returned from the query.
      processResponse(obj, runner) {
        const { response } = obj;
        if (obj.output) {
          return obj.output.call(runner, response);
        }
        switch (obj.method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map2(response, obj.pluck);
          case "insert":
          case "del":
          case "update":
          case "counter":
            if (obj.returning && !isEmpty(obj.returning) || obj.returningSql) {
              return response;
            } else if (obj.rowsAffected !== void 0) {
              return obj.rowsAffected;
            } else {
              return 1;
            }
          default:
            return response;
        }
      }
      processPassedConnection(connection) {
        this.checkVersion(connection);
        monkeyPatchConnection(connection, this);
      }
    };
    Client_Oracledb.prototype.driverName = "oracledb";
    function parseVersion(versionString) {
      try {
        const versionParts = versionString.split(".").slice(0, 2);
        versionParts.forEach((versionPart, idx) => {
          versionParts[idx] = versionPart.replace(/\D$/, "");
        });
        const version3 = versionParts.join(".");
        return version3.match(/^\d+\.?\d*$/) ? version3 : null;
      } catch (err) {
        return null;
      }
    }
    function resolveConnectString(connectionSettings) {
      if (connectionSettings.connectString) {
        return connectionSettings.connectString;
      }
      if (!connectionSettings.port) {
        return connectionSettings.host + "/" + connectionSettings.database;
      }
      return connectionSettings.host + ":" + connectionSettings.port + "/" + connectionSettings.database;
    }
    module.exports = Client_Oracledb;
  }
});

// node_modules/knex/lib/dialects/pgnative/index.js
var require_pgnative = __commonJS({
  "node_modules/knex/lib/dialects/pgnative/index.js"(exports, module) {
    var Client_PG = require_postgres();
    var Client_PgNative = class extends Client_PG {
      constructor(...args) {
        super(...args);
        this.driverName = "pgnative";
        this.canCancelQuery = true;
      }
      _driver() {
        return require_lib2().native;
      }
      _stream(connection, obj, stream2, options) {
        if (!obj.sql) throw new Error("The query is empty");
        const client = this;
        return new Promise((resolver, rejecter) => {
          stream2.on("error", rejecter);
          stream2.on("end", resolver);
          return client._query(connection, obj).then((obj2) => obj2.response).then(({ rows }) => rows.forEach((row) => stream2.write(row))).catch(function(err) {
            stream2.emit("error", err);
          }).then(function() {
            stream2.end();
          });
        });
      }
      async cancelQuery(connectionToKill) {
        try {
          return await this._wrappedCancelQueryCall(null, connectionToKill);
        } catch (err) {
          this.logger.warn(`Connection Error: ${err}`);
          throw err;
        }
      }
      _wrappedCancelQueryCall(emptyConnection, connectionToKill) {
        return new Promise(function(resolve, reject) {
          connectionToKill.native.cancel(function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(true);
          });
        });
      }
    };
    module.exports = Client_PgNative;
  }
});

// node_modules/knex/lib/dialects/redshift/transaction.js
var require_transaction6 = __commonJS({
  "node_modules/knex/lib/dialects/redshift/transaction.js"(exports, module) {
    var Transaction = require_transaction();
    module.exports = class Redshift_Transaction extends Transaction {
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `BEGIN ${trxMode};`);
      }
      savepoint(conn) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
      release(conn, value) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
      rollbackTo(conn, error) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
    };
  }
});

// node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js
var require_redshift_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js"(exports, module) {
    var QueryCompiler = require_querycompiler();
    var QueryCompiler_PG = require_pg_querycompiler();
    var identity = require_identity();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var QueryCompiler_Redshift = class extends QueryCompiler_PG {
      truncate() {
        return `truncate ${this.tableName.toLowerCase()}`;
      }
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const sql = QueryCompiler.prototype.insert.apply(this, arguments);
        if (sql === "") return sql;
        this._slightReturn();
        return {
          sql
        };
      }
      // Compiles an `update` query, warning on unsupported returning
      update() {
        const sql = QueryCompiler.prototype.update.apply(this, arguments);
        this._slightReturn();
        return {
          sql
        };
      }
      // Compiles an `delete` query, warning on unsupported returning
      del() {
        const sql = QueryCompiler.prototype.del.apply(this, arguments);
        this._slightReturn();
        return {
          sql
        };
      }
      // simple: if trying to return, warn
      _slightReturn() {
        if (this.single.isReturning) {
          this.client.logger.warn(
            "insert/update/delete returning is not supported by redshift dialect"
          );
        }
      }
      forUpdate() {
        this.client.logger.warn("table lock is not supported by redshift dialect");
        return "";
      }
      forShare() {
        this.client.logger.warn(
          "lock for share is not supported by redshift dialect"
        );
        return "";
      }
      forNoKeyUpdate() {
        this.client.logger.warn("table lock is not supported by redshift dialect");
        return "";
      }
      forKeyShare() {
        this.client.logger.warn(
          "lock for share is not supported by redshift dialect"
        );
        return "";
      }
      // Compiles a columnInfo query
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        const sql = "select * from information_schema.columns where table_name = ? and table_catalog = ?";
        const bindings = [
          table.toLowerCase(),
          this.client.database().toLowerCase()
        ];
        return this._buildColumnInfoQuery(schema, sql, bindings, column);
      }
      jsonExtract(params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        return extractions.map((extraction) => {
          const jsonCol = `json_extract_path_text(${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this.client.toPathForJson(
            params.path || extraction[1],
            this.builder,
            this.bindingsHolder
          )})`;
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      jsonSet(params) {
        throw new Error("Json set is not supported by Redshift");
      }
      jsonInsert(params) {
        throw new Error("Json insert is not supported by Redshift");
      }
      jsonRemove(params) {
        throw new Error("Json remove is not supported by Redshift");
      }
      whereJsonPath(statement) {
        return this._whereJsonPath(
          "json_extract_path_text",
          Object.assign({}, statement, {
            path: this.client.toPathForJson(statement.path)
          })
        );
      }
      whereJsonSupersetOf(statement) {
        throw new Error("Json superset is not supported by Redshift");
      }
      whereJsonSubsetOf(statement) {
        throw new Error("Json subset is not supported by Redshift");
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract_path_text", clause);
      }
    };
    module.exports = QueryCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-columnbuilder.js
var require_redshift_columnbuilder = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-columnbuilder.js"(exports, module) {
    var ColumnBuilder = require_columnbuilder();
    var ColumnBuilder_Redshift = class extends ColumnBuilder {
      constructor() {
        super(...arguments);
      }
      // primary needs to set not null on non-preexisting columns, or fail
      primary() {
        this.notNullable();
        return super.primary(...arguments);
      }
      index() {
        this.client.logger.warn(
          "Redshift does not support the creation of indexes."
        );
        return this;
      }
    };
    module.exports = ColumnBuilder_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-columncompiler.js
var require_redshift_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-columncompiler.js"(exports, module) {
    var ColumnCompiler_PG = require_pg_columncompiler();
    var ColumnCompiler = require_columncompiler();
    var ColumnCompiler_Redshift = class extends ColumnCompiler_PG {
      constructor() {
        super(...arguments);
      }
      // Types:
      // ------
      bit(column) {
        return column.length !== false ? `char(${column.length})` : "char(1)";
      }
      datetime(without) {
        return without ? "timestamp" : "timestamptz";
      }
      timestamp(without) {
        return without ? "timestamp" : "timestamptz";
      }
      // Modifiers:
      // ------
      comment(comment) {
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(this.args[0]) + " is " + (comment ? `'${comment}'` : "NULL")
          );
        }, comment);
      }
    };
    ColumnCompiler_Redshift.prototype.increments = ({ primaryKey = true } = {}) => "integer identity(1,1)" + (primaryKey ? " primary key" : "") + " not null";
    ColumnCompiler_Redshift.prototype.bigincrements = ({
      primaryKey = true
    } = {}) => "bigint identity(1,1)" + (primaryKey ? " primary key" : "") + " not null";
    ColumnCompiler_Redshift.prototype.binary = "varchar(max)";
    ColumnCompiler_Redshift.prototype.blob = "varchar(max)";
    ColumnCompiler_Redshift.prototype.enu = "varchar(255)";
    ColumnCompiler_Redshift.prototype.enum = "varchar(255)";
    ColumnCompiler_Redshift.prototype.json = "varchar(max)";
    ColumnCompiler_Redshift.prototype.jsonb = "varchar(max)";
    ColumnCompiler_Redshift.prototype.longblob = "varchar(max)";
    ColumnCompiler_Redshift.prototype.mediumblob = "varchar(16777218)";
    ColumnCompiler_Redshift.prototype.set = "text";
    ColumnCompiler_Redshift.prototype.text = "varchar(max)";
    ColumnCompiler_Redshift.prototype.tinyblob = "varchar(256)";
    ColumnCompiler_Redshift.prototype.uuid = ColumnCompiler.prototype.uuid;
    ColumnCompiler_Redshift.prototype.varbinary = "varchar(max)";
    ColumnCompiler_Redshift.prototype.bigint = "bigint";
    ColumnCompiler_Redshift.prototype.bool = "boolean";
    ColumnCompiler_Redshift.prototype.double = "double precision";
    ColumnCompiler_Redshift.prototype.floating = "real";
    ColumnCompiler_Redshift.prototype.smallint = "smallint";
    ColumnCompiler_Redshift.prototype.tinyint = "smallint";
    module.exports = ColumnCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-tablecompiler.js
var require_redshift_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-tablecompiler.js"(exports, module) {
    var has = require_has();
    var TableCompiler_PG = require_pg_tablecompiler();
    var TableCompiler_Redshift = class extends TableCompiler_PG {
      constructor() {
        super(...arguments);
      }
      index(columns, indexName, options) {
        this.client.logger.warn(
          "Redshift does not support the creation of indexes."
        );
      }
      dropIndex(columns, indexName) {
        this.client.logger.warn(
          "Redshift does not support the deletion of indexes."
        );
      }
      // TODO: have to disable setting not null on columns that already exist...
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const columnsSql = " (" + columns.sql.join(", ") + this._addChecks() + ")";
        let sql = createStatement + this.tableName() + (like && this.tableNameLike() ? " (like " + this.tableNameLike() + ")" : columnsSql);
        if (this.single.inherits)
          sql += ` like (${this.formatter.wrap(this.single.inherits)})`;
        this.pushQuery({
          sql,
          bindings: columns.bindings
        });
        const hasComment = has(this.single, "comment");
        if (hasComment) this.comment(this.single.comment);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      primary(columns, constraintName) {
        const self2 = this;
        constraintName = constraintName ? self2.formatter.wrap(constraintName) : self2.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (columns.constructor !== Array) {
          columns = [columns];
        }
        const thiscolumns = self2.grouped.columns;
        if (thiscolumns) {
          for (let i3 = 0; i3 < columns.length; i3++) {
            let exists = thiscolumns.find(
              (tcb) => tcb.grouping === "columns" && tcb.builder && tcb.builder._method === "add" && tcb.builder._args && tcb.builder._args.indexOf(columns[i3]) > -1
            );
            if (exists) {
              exists = exists.builder;
            }
            const nullable = !(exists && exists._modifiers && exists._modifiers["nullable"] && exists._modifiers["nullable"][0] === false);
            if (nullable) {
              if (exists) {
                return this.client.logger.warn(
                  "Redshift does not allow primary keys to contain nullable columns."
                );
              } else {
                return this.client.logger.warn(
                  "Redshift does not allow primary keys to contain nonexistent columns."
                );
              }
            }
          }
        }
        return self2.pushQuery(
          `alter table ${self2.tableName()} add constraint ${constraintName} primary key (${self2.formatter.columnize(
            columns
          )})`
        );
      }
      // Compiles column add. Redshift can only add one column per ALTER TABLE, so core addColumns doesn't work.  #2545
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          super.addColumns(columns, prefix, colCompilers);
        } else {
          prefix = prefix || this.addColumnsPrefix;
          colCompilers = colCompilers || this.getColumns();
          for (const col of colCompilers) {
            const quotedTableName = this.tableName();
            const colCompiled = col.compileColumn();
            this.pushQuery({
              sql: `alter table ${quotedTableName} ${prefix}${colCompiled}`,
              bindings: []
            });
          }
        }
      }
    };
    module.exports = TableCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-compiler.js
var require_redshift_compiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-compiler.js"(exports, module) {
    var SchemaCompiler_PG = require_pg_compiler();
    var SchemaCompiler_Redshift = class extends SchemaCompiler_PG {
      constructor() {
        super(...arguments);
      }
    };
    module.exports = SchemaCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-viewcompiler.js
var require_redshift_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-viewcompiler.js"(exports, module) {
    var ViewCompiler_PG = require_pg_viewcompiler();
    var ViewCompiler_Redshift = class extends ViewCompiler_PG {
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
    };
    module.exports = ViewCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/index.js
var require_redshift = __commonJS({
  "node_modules/knex/lib/dialects/redshift/index.js"(exports, module) {
    var Client_PG = require_postgres();
    var map2 = require_map();
    var Transaction = require_transaction6();
    var QueryCompiler = require_redshift_querycompiler();
    var ColumnBuilder = require_redshift_columnbuilder();
    var ColumnCompiler = require_redshift_columncompiler();
    var TableCompiler = require_redshift_tablecompiler();
    var SchemaCompiler = require_redshift_compiler();
    var ViewCompiler = require_redshift_viewcompiler();
    var Client_Redshift = class extends Client_PG {
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnBuilder() {
        return new ColumnBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      _driver() {
        return require_lib2();
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const resp = obj.response;
        if (obj.output) return obj.output.call(runner, resp);
        if (obj.method === "raw") return resp;
        if (resp.command === "SELECT") {
          if (obj.method === "first") return resp.rows[0];
          if (obj.method === "pluck") return map2(resp.rows, obj.pluck);
          return resp.rows;
        }
        if (resp.command === "INSERT" || resp.command === "UPDATE" || resp.command === "DELETE") {
          return resp.rowCount;
        }
        return resp;
      }
      toPathForJson(jsonPath, builder, bindingsHolder) {
        return jsonPath.replace(/^(\$\.)/, "").split(".").map(
          function(v6) {
            return this.parameter(v6, builder, bindingsHolder);
          }.bind(this)
        ).join(", ");
      }
    };
    Object.assign(Client_Redshift.prototype, {
      dialect: "redshift",
      driverName: "pg-redshift"
    });
    module.exports = Client_Redshift;
  }
});

// node_modules/knex/lib/dialects/index.js
var require_dialects = __commonJS({
  "node_modules/knex/lib/dialects/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDialectByNameOrAlias = void 0;
    var { resolveClientNameWithAliases } = require_helpers();
    var dbNameToDialectLoader = Object.freeze({
      "better-sqlite3": () => require_better_sqlite3(),
      cockroachdb: () => require_cockroachdb(),
      mssql: () => require_mssql(),
      mysql: () => require_mysql(),
      mysql2: () => require_mysql2(),
      oracle: () => require_oracle(),
      oracledb: () => require_oracledb(),
      pgnative: () => require_pgnative(),
      postgres: () => require_postgres(),
      redshift: () => require_redshift(),
      sqlite3: () => require_sqlite3()
    });
    function getDialectByNameOrAlias(clientName) {
      const resolvedClientName = resolveClientNameWithAliases(clientName);
      const dialectLoader = dbNameToDialectLoader[resolvedClientName];
      if (!dialectLoader) {
        throw new Error(`Invalid clientName given: ${clientName}`);
      }
      return dialectLoader();
    }
    exports.getDialectByNameOrAlias = getDialectByNameOrAlias;
  }
});

// node_modules/knex/lib/knex-builder/internal/config-resolver.js
var require_config_resolver = __commonJS({
  "node_modules/knex/lib/knex-builder/internal/config-resolver.js"(exports, module) {
    var Client = require_client();
    var { SUPPORTED_CLIENTS } = require_constants3();
    var parseConnection = require_parse_connection();
    var { getDialectByNameOrAlias } = require_dialects();
    function resolveConfig(config) {
      let Dialect;
      let resolvedConfig;
      const parsedConfig = typeof config === "string" ? Object.assign(parseConnection(config), arguments[2]) : config;
      if (arguments.length === 0 || !parsedConfig.client && !parsedConfig.dialect) {
        Dialect = Client;
      } else if (typeof parsedConfig.client === "function") {
        Dialect = parsedConfig.client;
      } else {
        const clientName = parsedConfig.client || parsedConfig.dialect;
        if (!SUPPORTED_CLIENTS.includes(clientName)) {
          throw new Error(
            `knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`
          );
        }
        Dialect = getDialectByNameOrAlias(clientName);
      }
      if (typeof parsedConfig.connection === "string") {
        resolvedConfig = Object.assign({}, parsedConfig, {
          connection: parseConnection(parsedConfig.connection).connection
        });
      } else {
        resolvedConfig = Object.assign({}, parsedConfig);
      }
      return {
        resolvedConfig,
        Dialect
      };
    }
    module.exports = {
      resolveConfig
    };
  }
});

// node_modules/knex/lib/knex-builder/Knex.js
var require_Knex = __commonJS({
  "node_modules/knex/lib/knex-builder/Knex.js"(exports, module) {
    var Client = require_client();
    var QueryBuilder = require_querybuilder();
    var QueryInterface = require_method_constants();
    var makeKnex = require_make_knex();
    var { KnexTimeoutError } = require_timeout();
    var { resolveConfig } = require_config_resolver();
    var SchemaBuilder = require_builder();
    var ViewBuilder = require_viewbuilder();
    var ColumnBuilder = require_columnbuilder();
    var TableBuilder = require_tablebuilder();
    function knex2(config) {
      const { resolvedConfig, Dialect } = resolveConfig(...arguments);
      const newKnex = makeKnex(new Dialect(resolvedConfig));
      if (resolvedConfig.userParams) {
        newKnex.userParams = resolvedConfig.userParams;
      }
      return newKnex;
    }
    knex2.Client = Client;
    knex2.KnexTimeoutError = KnexTimeoutError;
    knex2.QueryBuilder = {
      extend: function(methodName, fn) {
        QueryBuilder.extend(methodName, fn);
        QueryInterface.push(methodName);
      }
    };
    knex2.SchemaBuilder = {
      extend: function(methodName, fn) {
        SchemaBuilder.extend(methodName, fn);
      }
    };
    knex2.ViewBuilder = {
      extend: function(methodName, fn) {
        ViewBuilder.extend(methodName, fn);
      }
    };
    knex2.ColumnBuilder = {
      extend: function(methodName, fn) {
        ColumnBuilder.extend(methodName, fn);
      }
    };
    knex2.TableBuilder = {
      extend: function(methodName, fn) {
        TableBuilder.extend(methodName, fn);
      }
    };
    module.exports = knex2;
  }
});

// node_modules/knex/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/knex/lib/index.js"(exports, module) {
    var Knex = require_Knex();
    module.exports = Knex;
  }
});

// node_modules/knex/knex.js
var require_knex = __commonJS({
  "node_modules/knex/knex.js"(exports, module) {
    var knex2 = require_lib3();
    knex2.knex = knex2;
    knex2.default = knex2;
    module.exports = knex2;
  }
});

// node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "node_modules/@smithy/types/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      AlgorithmId: () => AlgorithmId,
      EndpointURLScheme: () => EndpointURLScheme,
      FieldPosition: () => FieldPosition,
      HttpApiKeyAuthLocation: () => HttpApiKeyAuthLocation2,
      HttpAuthLocation: () => HttpAuthLocation,
      IniSectionType: () => IniSectionType,
      RequestHandlerProtocol: () => RequestHandlerProtocol,
      SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_KEY4,
      getDefaultClientConfiguration: () => getDefaultClientConfiguration,
      resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var HttpAuthLocation = /* @__PURE__ */ ((HttpAuthLocation2) => {
      HttpAuthLocation2["HEADER"] = "header";
      HttpAuthLocation2["QUERY"] = "query";
      return HttpAuthLocation2;
    })(HttpAuthLocation || {});
    var HttpApiKeyAuthLocation2 = /* @__PURE__ */ ((HttpApiKeyAuthLocation22) => {
      HttpApiKeyAuthLocation22["HEADER"] = "header";
      HttpApiKeyAuthLocation22["QUERY"] = "query";
      return HttpApiKeyAuthLocation22;
    })(HttpApiKeyAuthLocation2 || {});
    var EndpointURLScheme = /* @__PURE__ */ ((EndpointURLScheme2) => {
      EndpointURLScheme2["HTTP"] = "http";
      EndpointURLScheme2["HTTPS"] = "https";
      return EndpointURLScheme2;
    })(EndpointURLScheme || {});
    var AlgorithmId = /* @__PURE__ */ ((AlgorithmId2) => {
      AlgorithmId2["MD5"] = "md5";
      AlgorithmId2["CRC32"] = "crc32";
      AlgorithmId2["CRC32C"] = "crc32c";
      AlgorithmId2["SHA1"] = "sha1";
      AlgorithmId2["SHA256"] = "sha256";
      return AlgorithmId2;
    })(AlgorithmId || {});
    var getChecksumConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
      const checksumAlgorithms = [];
      if (runtimeConfig.sha256 !== void 0) {
        checksumAlgorithms.push({
          algorithmId: () => "sha256",
          checksumConstructor: () => runtimeConfig.sha256
        });
      }
      if (runtimeConfig.md5 != void 0) {
        checksumAlgorithms.push({
          algorithmId: () => "md5",
          checksumConstructor: () => runtimeConfig.md5
        });
      }
      return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
          this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms;
        }
      };
    }, "getChecksumConfiguration");
    var resolveChecksumRuntimeConfig = /* @__PURE__ */ __name((clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    }, "resolveChecksumRuntimeConfig");
    var getDefaultClientConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
      return {
        ...getChecksumConfiguration(runtimeConfig)
      };
    }, "getDefaultClientConfiguration");
    var resolveDefaultRuntimeConfig3 = /* @__PURE__ */ __name((config) => {
      return {
        ...resolveChecksumRuntimeConfig(config)
      };
    }, "resolveDefaultRuntimeConfig");
    var FieldPosition = /* @__PURE__ */ ((FieldPosition2) => {
      FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
      FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
      return FieldPosition2;
    })(FieldPosition || {});
    var SMITHY_CONTEXT_KEY4 = "__smithy_context";
    var IniSectionType = /* @__PURE__ */ ((IniSectionType2) => {
      IniSectionType2["PROFILE"] = "profile";
      IniSectionType2["SSO_SESSION"] = "sso-session";
      IniSectionType2["SERVICES"] = "services";
      return IniSectionType2;
    })(IniSectionType || {});
    var RequestHandlerProtocol = /* @__PURE__ */ ((RequestHandlerProtocol2) => {
      RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
      RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
      RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
      return RequestHandlerProtocol2;
    })(RequestHandlerProtocol || {});
  }
});

// node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "node_modules/@smithy/protocol-http/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Field: () => Field,
      Fields: () => Fields,
      HttpRequest: () => HttpRequest7,
      HttpResponse: () => HttpResponse2,
      IHttpRequest: () => import_types5.HttpRequest,
      getHttpHandlerExtensionConfiguration: () => getHttpHandlerExtensionConfiguration3,
      isValidHostname: () => isValidHostname,
      resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var getHttpHandlerExtensionConfiguration3 = /* @__PURE__ */ __name((runtimeConfig) => {
      let httpHandler = runtimeConfig.httpHandler;
      return {
        setHttpHandler(handler2) {
          httpHandler = handler2;
        },
        httpHandler() {
          return httpHandler;
        },
        updateHttpClientConfig(key, value) {
          httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
          return httpHandler.httpHandlerConfigs();
        }
      };
    }, "getHttpHandlerExtensionConfiguration");
    var resolveHttpHandlerRuntimeConfig3 = /* @__PURE__ */ __name((httpHandlerExtensionConfiguration) => {
      return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler()
      };
    }, "resolveHttpHandlerRuntimeConfig");
    var import_types5 = require_dist_cjs();
    var Field = class {
      static {
        __name(this, "Field");
      }
      constructor({ name, kind = import_types5.FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
      }
      /**
       * Appends a value to the field.
       *
       * @param value The value to append.
       */
      add(value) {
        this.values.push(value);
      }
      /**
       * Overwrite existing field values.
       *
       * @param values The new field values.
       */
      set(values) {
        this.values = values;
      }
      /**
       * Remove all matching entries from list.
       *
       * @param value Value to remove.
       */
      remove(value) {
        this.values = this.values.filter((v6) => v6 !== value);
      }
      /**
       * Get comma-delimited string.
       *
       * @returns String representation of {@link Field}.
       */
      toString() {
        return this.values.map((v6) => v6.includes(",") || v6.includes(" ") ? `"${v6}"` : v6).join(", ");
      }
      /**
       * Get string values as a list
       *
       * @returns Values in {@link Field} as a list.
       */
      get() {
        return this.values;
      }
    };
    var Fields = class {
      constructor({ fields = [], encoding = "utf-8" }) {
        this.entries = {};
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
      }
      static {
        __name(this, "Fields");
      }
      /**
       * Set entry for a {@link Field} name. The `name`
       * attribute will be used to key the collection.
       *
       * @param field The {@link Field} to set.
       */
      setField(field) {
        this.entries[field.name.toLowerCase()] = field;
      }
      /**
       *  Retrieve {@link Field} entry by name.
       *
       * @param name The name of the {@link Field} entry
       *  to retrieve
       * @returns The {@link Field} if it exists.
       */
      getField(name) {
        return this.entries[name.toLowerCase()];
      }
      /**
       * Delete entry from collection.
       *
       * @param name Name of the entry to delete.
       */
      removeField(name) {
        delete this.entries[name.toLowerCase()];
      }
      /**
       * Helper function for retrieving specific types of fields.
       * Used to grab all headers or all trailers.
       *
       * @param kind {@link FieldPosition} of entries to retrieve.
       * @returns The {@link Field} entries with the specified
       *  {@link FieldPosition}.
       */
      getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
      }
    };
    var HttpRequest7 = class _HttpRequest {
      static {
        __name(this, "HttpRequest");
      }
      constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
      }
      /**
       * Note: this does not deep-clone the body.
       */
      static clone(request) {
        const cloned = new _HttpRequest({
          ...request,
          headers: { ...request.headers }
        });
        if (cloned.query) {
          cloned.query = cloneQuery(cloned.query);
        }
        return cloned;
      }
      /**
       * This method only actually asserts that request is the interface {@link IHttpRequest},
       * and not necessarily this concrete class. Left in place for API stability.
       *
       * Do not call instance methods on the input of this function, and
       * do not assume it has the HttpRequest prototype.
       */
      static isInstance(request) {
        if (!request) {
          return false;
        }
        const req = request;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
      }
      /**
       * @deprecated use static HttpRequest.clone(request) instead. It's not safe to call
       * this method because {@link HttpRequest.isInstance} incorrectly
       * asserts that IHttpRequest (interface) objects are of type HttpRequest (class).
       */
      clone() {
        return _HttpRequest.clone(this);
      }
    };
    function cloneQuery(query) {
      return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
          ...carry,
          [paramName]: Array.isArray(param) ? [...param] : param
        };
      }, {});
    }
    __name(cloneQuery, "cloneQuery");
    var HttpResponse2 = class {
      static {
        __name(this, "HttpResponse");
      }
      constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
      }
      static isInstance(response) {
        if (!response)
          return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
      }
    };
    function isValidHostname(hostname) {
      const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
      return hostPattern.test(hostname);
    }
    __name(isValidHostname, "isValidHostname");
  }
});

// node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs3 = __commonJS({
  "node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      getHostHeaderPlugin: () => getHostHeaderPlugin3,
      hostHeaderMiddleware: () => hostHeaderMiddleware,
      hostHeaderMiddlewareOptions: () => hostHeaderMiddlewareOptions,
      resolveHostHeaderConfig: () => resolveHostHeaderConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_protocol_http11 = require_dist_cjs2();
    function resolveHostHeaderConfig3(input) {
      return input;
    }
    __name(resolveHostHeaderConfig3, "resolveHostHeaderConfig");
    var hostHeaderMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
      if (!import_protocol_http11.HttpRequest.isInstance(args.request))
        return next(args);
      const { request } = args;
      const { handlerProtocol = "" } = options.requestHandler.metadata || {};
      if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
      } else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
          host += `:${request.port}`;
        request.headers["host"] = host;
      }
      return next(args);
    }, "hostHeaderMiddleware");
    var hostHeaderMiddlewareOptions = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: true
    };
    var getHostHeaderPlugin3 = /* @__PURE__ */ __name((options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
      }
    }), "getHostHeaderPlugin");
  }
});

// node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs4 = __commonJS({
  "node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      getLoggerPlugin: () => getLoggerPlugin3,
      loggerMiddleware: () => loggerMiddleware,
      loggerMiddlewareOptions: () => loggerMiddlewareOptions
    });
    module.exports = __toCommonJS2(src_exports);
    var loggerMiddleware = /* @__PURE__ */ __name(() => (next, context) => async (args) => {
      try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger?.info?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          output: outputFilterSensitiveLog(outputWithoutMetadata),
          metadata: $metadata
        });
        return response;
      } catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger?.error?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          error,
          metadata: error.$metadata
        });
        throw error;
      }
    }, "loggerMiddleware");
    var loggerMiddlewareOptions = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: true
    };
    var getLoggerPlugin3 = /* @__PURE__ */ __name((options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
      }
    }), "getLoggerPlugin");
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs5 = __commonJS({
  "node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      addRecursionDetectionMiddlewareOptions: () => addRecursionDetectionMiddlewareOptions,
      getRecursionDetectionPlugin: () => getRecursionDetectionPlugin3,
      recursionDetectionMiddleware: () => recursionDetectionMiddleware
    });
    module.exports = __toCommonJS2(index_exports);
    var import_protocol_http11 = require_dist_cjs2();
    var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
    var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
    var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
    var recursionDetectionMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
      const { request } = args;
      if (!import_protocol_http11.HttpRequest.isInstance(request) || options.runtime !== "node") {
        return next(args);
      }
      const traceIdHeader = Object.keys(request.headers ?? {}).find((h3) => h3.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
      if (request.headers.hasOwnProperty(traceIdHeader)) {
        return next(args);
      }
      const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
      const traceId = process.env[ENV_TRACE_ID];
      const nonEmptyString = /* @__PURE__ */ __name((str) => typeof str === "string" && str.length > 0, "nonEmptyString");
      if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
      }
      return next({
        ...args,
        request
      });
    }, "recursionDetectionMiddleware");
    var addRecursionDetectionMiddlewareOptions = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: true,
      priority: "low"
    };
    var getRecursionDetectionPlugin3 = /* @__PURE__ */ __name((options) => ({
      applyToStack: /* @__PURE__ */ __name((clientStack) => {
        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
      }, "applyToStack")
    }), "getRecursionDetectionPlugin");
  }
});

// node_modules/@smithy/core/dist-es/getSmithyContext.js
var import_types, getSmithyContext;
var init_getSmithyContext = __esm({
  "node_modules/@smithy/core/dist-es/getSmithyContext.js"() {
    import_types = __toESM(require_dist_cjs());
    getSmithyContext = (context) => context[import_types.SMITHY_CONTEXT_KEY] || (context[import_types.SMITHY_CONTEXT_KEY] = {});
  }
});

// node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs6 = __commonJS({
  "node_modules/@smithy/util-middleware/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      getSmithyContext: () => getSmithyContext6,
      normalizeProvider: () => normalizeProvider4
    });
    module.exports = __toCommonJS2(src_exports);
    var import_types5 = require_dist_cjs();
    var getSmithyContext6 = /* @__PURE__ */ __name((context) => context[import_types5.SMITHY_CONTEXT_KEY] || (context[import_types5.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");
    var normalizeProvider4 = /* @__PURE__ */ __name((input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    }, "normalizeProvider");
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map2 = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map2.set(scheme.schemeId, scheme);
  }
  return map2;
}
var import_types2, import_util_middleware, httpAuthSchemeMiddleware;
var init_httpAuthSchemeMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js"() {
    import_types2 = __toESM(require_dist_cjs());
    import_util_middleware = __toESM(require_dist_cjs6());
    httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
      const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
      const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
      const smithyContext = (0, import_util_middleware.getSmithyContext)(context);
      const failureReasons = [];
      for (const option of options) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
          continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
          continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
          httpAuthOption: option,
          identity: await identityProvider(option.identityProperties),
          signer: scheme.signer
        };
        break;
      }
      if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
      }
      return next(args);
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions, getHttpAuthSchemeEndpointRuleSetPlugin;
var init_getHttpAuthSchemeEndpointRuleSetPlugin = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js"() {
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
    getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
          httpAuthSchemeParametersProvider,
          identityProviderConfigProvider
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs7 = __commonJS({
  "node_modules/@smithy/middleware-serde/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      deserializerMiddleware: () => deserializerMiddleware,
      deserializerMiddlewareOption: () => deserializerMiddlewareOption,
      getSerdePlugin: () => getSerdePlugin4,
      serializerMiddleware: () => serializerMiddleware,
      serializerMiddlewareOption: () => serializerMiddlewareOption2
    });
    module.exports = __toCommonJS2(src_exports);
    var deserializerMiddleware = /* @__PURE__ */ __name((options, deserializer) => (next, context) => async (args) => {
      const { response } = await next(args);
      try {
        const parsed = await deserializer(response, options);
        return {
          response,
          output: parsed
        };
      } catch (error) {
        Object.defineProperty(error, "$response", {
          value: response
        });
        if (!("$metadata" in error)) {
          const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
          try {
            error.message += "\n  " + hint;
          } catch (e3) {
            if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(hint);
            } else {
              context.logger?.warn?.(hint);
            }
          }
          if (typeof error.$responseBodyText !== "undefined") {
            if (error.$response) {
              error.$response.body = error.$responseBodyText;
            }
          }
        }
        throw error;
      }
    }, "deserializerMiddleware");
    var serializerMiddleware = /* @__PURE__ */ __name((options, serializer) => (next, context) => async (args) => {
      const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
      if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
      }
      const request = await serializer(args.input, { ...options, endpoint });
      return next({
        ...args,
        request
      });
    }, "serializerMiddleware");
    var deserializerMiddlewareOption = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    var serializerMiddlewareOption2 = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
    function getSerdePlugin4(config, serializer, deserializer) {
      return {
        applyToStack: (commandStack) => {
          commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
          commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption2);
        }
      };
    }
    __name(getSerdePlugin4, "getSerdePlugin");
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
var import_middleware_serde, httpAuthSchemeMiddlewareOptions, getHttpAuthSchemePlugin;
var init_getHttpAuthSchemePlugin = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js"() {
    import_middleware_serde = __toESM(require_dist_cjs7());
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: import_middleware_serde.serializerMiddlewareOption.name
    };
    getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
          httpAuthSchemeParametersProvider,
          identityProviderConfigProvider
        }), httpAuthSchemeMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
var init_middleware_http_auth_scheme = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js"() {
    init_httpAuthSchemeMiddleware();
    init_getHttpAuthSchemeEndpointRuleSetPlugin();
    init_getHttpAuthSchemePlugin();
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
var import_protocol_http, import_types3, import_util_middleware2, defaultErrorHandler, defaultSuccessHandler, httpSigningMiddleware;
var init_httpSigningMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js"() {
    import_protocol_http = __toESM(require_dist_cjs2());
    import_types3 = __toESM(require_dist_cjs());
    import_util_middleware2 = __toESM(require_dist_cjs6());
    defaultErrorHandler = (signingProperties) => (error) => {
      throw error;
    };
    defaultSuccessHandler = (httpResponse, signingProperties) => {
    };
    httpSigningMiddleware = (config) => (next, context) => async (args) => {
      if (!import_protocol_http.HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const smithyContext = (0, import_util_middleware2.getSmithyContext)(context);
      const scheme = smithyContext.selectedHttpAuthScheme;
      if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
      }
      const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
      const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties)
      }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
      (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
      return output;
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions, getHttpSigningPlugin;
var init_getHttpSigningMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js"() {
    init_httpSigningMiddleware();
    httpSigningMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: true,
      relation: "after",
      toMiddleware: "retryMiddleware"
    };
    getHttpSigningPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
var init_middleware_http_signing = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/index.js"() {
    init_httpSigningMiddleware();
    init_getHttpSigningMiddleware();
  }
});

// node_modules/@smithy/core/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "node_modules/@smithy/core/dist-es/normalizeProvider.js"() {
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// node_modules/@smithy/core/dist-es/pagination/createPaginator.js
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
  return async function* paginateOperation(config, input, ...additionalArguments) {
    const _input = input;
    let token = config.startingToken ?? _input[inputTokenName];
    let hasNext = true;
    let page;
    while (hasNext) {
      _input[inputTokenName] = token;
      if (pageSizeTokenName) {
        _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
      }
      if (config.client instanceof ClientCtor) {
        page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
      } else {
        throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
      }
      yield page;
      const prevToken = token;
      token = get(page, outputTokenName);
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return void 0;
  };
}
var makePagedClientRequest, get;
var init_createPaginator = __esm({
  "node_modules/@smithy/core/dist-es/pagination/createPaginator.js"() {
    makePagedClientRequest = async (CommandCtor, client, input, withCommand = (_2) => _2, ...args) => {
      let command = new CommandCtor(input);
      command = withCommand(command) ?? command;
      return await client.send(command, ...args);
    };
    get = (fromObject, path) => {
      let cursor = fromObject;
      const pathComponents = path.split(".");
      for (const step of pathComponents) {
        if (!cursor || typeof cursor !== "object") {
          return void 0;
        }
        cursor = cursor[step];
      }
      return cursor;
    };
  }
});

// node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs8 = __commonJS({
  "node_modules/@smithy/is-array-buffer/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      isArrayBuffer: () => isArrayBuffer
    });
    module.exports = __toCommonJS2(src_exports);
    var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
  }
});

// node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs9 = __commonJS({
  "node_modules/@smithy/util-buffer-from/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromArrayBuffer: () => fromArrayBuffer,
      fromString: () => fromString
    });
    module.exports = __toCommonJS2(src_exports);
    var import_is_array_buffer = require_dist_cjs8();
    var import_buffer2 = __require("buffer");
    var fromArrayBuffer = /* @__PURE__ */ __name((input, offset = 0, length = input.byteLength - offset) => {
      if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return import_buffer2.Buffer.from(input, offset, length);
    }, "fromArrayBuffer");
    var fromString = /* @__PURE__ */ __name((input, encoding) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding ? import_buffer2.Buffer.from(input, encoding) : import_buffer2.Buffer.from(input);
    }, "fromString");
  }
});

// node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS({
  "node_modules/@smithy/util-base64/dist-cjs/fromBase64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromBase64 = void 0;
    var util_buffer_from_1 = require_dist_cjs9();
    var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
    var fromBase644 = (input) => {
      if (input.length * 3 % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
      }
      if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
      }
      const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    };
    exports.fromBase64 = fromBase644;
  }
});

// node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs10 = __commonJS({
  "node_modules/@smithy/util-utf8/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromUtf8: () => fromUtf83,
      toUint8Array: () => toUint8Array,
      toUtf8: () => toUtf83
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_buffer_from = require_dist_cjs9();
    var fromUtf83 = /* @__PURE__ */ __name((input) => {
      const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }, "fromUtf8");
    var toUint8Array = /* @__PURE__ */ __name((data) => {
      if (typeof data === "string") {
        return fromUtf83(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }, "toUint8Array");
    var toUtf83 = /* @__PURE__ */ __name((input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
    }, "toUtf8");
  }
});

// node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS({
  "node_modules/@smithy/util-base64/dist-cjs/toBase64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBase64 = void 0;
    var util_buffer_from_1 = require_dist_cjs9();
    var util_utf8_1 = require_dist_cjs10();
    var toBase644 = (_input) => {
      let input;
      if (typeof _input === "string") {
        input = (0, util_utf8_1.fromUtf8)(_input);
      } else {
        input = _input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      }
      return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
    };
    exports.toBase64 = toBase644;
  }
});

// node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs11 = __commonJS({
  "node_modules/@smithy/util-base64/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    module.exports = __toCommonJS2(src_exports);
    __reExport(src_exports, require_fromBase64(), module.exports);
    __reExport(src_exports, require_toBase64(), module.exports);
  }
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChecksumStream = void 0;
    var util_base64_1 = require_dist_cjs11();
    var stream_1 = __require("stream");
    var ChecksumStream2 = class extends stream_1.Duplex {
      constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) {
        var _a2, _b;
        super();
        if (typeof source.pipe === "function") {
          this.source = source;
        } else {
          throw new Error(`@smithy/util-stream: unsupported source type ${(_b = (_a2 = source === null || source === void 0 ? void 0 : source.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b !== void 0 ? _b : source} in ChecksumStream.`);
        }
        this.base64Encoder = base64Encoder !== null && base64Encoder !== void 0 ? base64Encoder : util_base64_1.toBase64;
        this.expectedChecksum = expectedChecksum;
        this.checksum = checksum;
        this.checksumSourceLocation = checksumSourceLocation;
        this.source.pipe(this);
      }
      _read(size) {
      }
      _write(chunk, encoding, callback) {
        try {
          this.checksum.update(chunk);
          this.push(chunk);
        } catch (e3) {
          return callback(e3);
        }
        return callback();
      }
      async _final(callback) {
        try {
          const digest = await this.checksum.digest();
          const received = this.base64Encoder(digest);
          if (this.expectedChecksum !== received) {
            return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}" in response header "${this.checksumSourceLocation}".`));
          }
        } catch (e3) {
          return callback(e3);
        }
        this.push(null);
        return callback();
      }
    };
    exports.ChecksumStream = ChecksumStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBlob = exports.isReadableStream = void 0;
    var isReadableStream2 = (stream2) => {
      var _a2;
      return typeof ReadableStream === "function" && (((_a2 = stream2 === null || stream2 === void 0 ? void 0 : stream2.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === ReadableStream.name || stream2 instanceof ReadableStream);
    };
    exports.isReadableStream = isReadableStream2;
    var isBlob2 = (blob) => {
      var _a2;
      return typeof Blob === "function" && (((_a2 = blob === null || blob === void 0 ? void 0 : blob.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === Blob.name || blob instanceof Blob);
    };
    exports.isBlob = isBlob2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChecksumStream = void 0;
    var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
    };
    var ChecksumStream2 = class extends ReadableStreamRef {
    };
    exports.ChecksumStream = ChecksumStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createChecksumStream = void 0;
    var util_base64_1 = require_dist_cjs11();
    var stream_type_check_1 = require_stream_type_check();
    var ChecksumStream_browser_1 = require_ChecksumStream_browser();
    var createChecksumStream2 = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
      var _a2, _b;
      if (!(0, stream_type_check_1.isReadableStream)(source)) {
        throw new Error(`@smithy/util-stream: unsupported source type ${(_b = (_a2 = source === null || source === void 0 ? void 0 : source.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b !== void 0 ? _b : source} in ChecksumStream.`);
      }
      const encoder = base64Encoder !== null && base64Encoder !== void 0 ? base64Encoder : util_base64_1.toBase64;
      if (typeof TransformStream !== "function") {
        throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
      }
      const transform = new TransformStream({
        start() {
        },
        async transform(chunk, controller) {
          checksum.update(chunk);
          controller.enqueue(chunk);
        },
        async flush(controller) {
          const digest = await checksum.digest();
          const received = encoder(digest);
          if (expectedChecksum !== received) {
            const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}" in response header "${checksumSourceLocation}".`);
            controller.error(error);
          } else {
            controller.terminate();
          }
        }
      });
      source.pipeThrough(transform);
      const readable = transform.readable;
      Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
      return readable;
    };
    exports.createChecksumStream = createChecksumStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createChecksumStream = void 0;
    var stream_type_check_1 = require_stream_type_check();
    var ChecksumStream_1 = require_ChecksumStream();
    var createChecksumStream_browser_1 = require_createChecksumStream_browser();
    function createChecksumStream2(init) {
      if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init.source)) {
        return (0, createChecksumStream_browser_1.createChecksumStream)(init);
      }
      return new ChecksumStream_1.ChecksumStream(init);
    }
    exports.createChecksumStream = createChecksumStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js
var require_ByteArrayCollector = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteArrayCollector = void 0;
    var ByteArrayCollector = class {
      constructor(allocByteArray) {
        this.allocByteArray = allocByteArray;
        this.byteLength = 0;
        this.byteArrays = [];
      }
      push(byteArray) {
        this.byteArrays.push(byteArray);
        this.byteLength += byteArray.byteLength;
      }
      flush() {
        if (this.byteArrays.length === 1) {
          const bytes = this.byteArrays[0];
          this.reset();
          return bytes;
        }
        const aggregation = this.allocByteArray(this.byteLength);
        let cursor = 0;
        for (let i3 = 0; i3 < this.byteArrays.length; ++i3) {
          const bytes = this.byteArrays[i3];
          aggregation.set(bytes, cursor);
          cursor += bytes.byteLength;
        }
        this.reset();
        return aggregation;
      }
      reset() {
        this.byteArrays = [];
        this.byteLength = 0;
      }
    };
    exports.ByteArrayCollector = ByteArrayCollector;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js
var require_createBufferedReadableStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modeOf = exports.sizeOf = exports.flush = exports.merge = exports.createBufferedReadable = exports.createBufferedReadableStream = void 0;
    var ByteArrayCollector_1 = require_ByteArrayCollector();
    function createBufferedReadableStream(upstream, size, logger) {
      const reader = upstream.getReader();
      let streamBufferingLoggedWarning = false;
      let bytesSeen = 0;
      const buffers = ["", new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2))];
      let mode = -1;
      const pull = async (controller) => {
        const { value, done } = await reader.read();
        const chunk = value;
        if (done) {
          if (mode !== -1) {
            const remainder = flush(buffers, mode);
            if (sizeOf(remainder) > 0) {
              controller.enqueue(remainder);
            }
          }
          controller.close();
        } else {
          const chunkMode = modeOf(chunk);
          if (mode !== chunkMode) {
            if (mode >= 0) {
              controller.enqueue(flush(buffers, mode));
            }
            mode = chunkMode;
          }
          if (mode === -1) {
            controller.enqueue(chunk);
            return;
          }
          const chunkSize = sizeOf(chunk);
          bytesSeen += chunkSize;
          const bufferSize = sizeOf(buffers[mode]);
          if (chunkSize >= size && bufferSize === 0) {
            controller.enqueue(chunk);
          } else {
            const newSize = merge(buffers, mode, chunk);
            if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
              streamBufferingLoggedWarning = true;
              logger === null || logger === void 0 ? void 0 : logger.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
            }
            if (newSize >= size) {
              controller.enqueue(flush(buffers, mode));
            } else {
              await pull(controller);
            }
          }
        }
      };
      return new ReadableStream({
        pull
      });
    }
    exports.createBufferedReadableStream = createBufferedReadableStream;
    exports.createBufferedReadable = createBufferedReadableStream;
    function merge(buffers, mode, chunk) {
      switch (mode) {
        case 0:
          buffers[0] += chunk;
          return sizeOf(buffers[0]);
        case 1:
        case 2:
          buffers[mode].push(chunk);
          return sizeOf(buffers[mode]);
      }
    }
    exports.merge = merge;
    function flush(buffers, mode) {
      switch (mode) {
        case 0:
          const s3 = buffers[0];
          buffers[0] = "";
          return s3;
        case 1:
        case 2:
          return buffers[mode].flush();
      }
      throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
    }
    exports.flush = flush;
    function sizeOf(chunk) {
      var _a2, _b;
      return (_b = (_a2 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a2 !== void 0 ? _a2 : chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _b !== void 0 ? _b : 0;
    }
    exports.sizeOf = sizeOf;
    function modeOf(chunk) {
      if (typeof Buffer !== "undefined" && chunk instanceof Buffer) {
        return 2;
      }
      if (chunk instanceof Uint8Array) {
        return 1;
      }
      if (typeof chunk === "string") {
        return 0;
      }
      return -1;
    }
    exports.modeOf = modeOf;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js
var require_createBufferedReadable = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBufferedReadable = void 0;
    var node_stream_1 = __require("node:stream");
    var ByteArrayCollector_1 = require_ByteArrayCollector();
    var createBufferedReadableStream_1 = require_createBufferedReadableStream();
    var stream_type_check_1 = require_stream_type_check();
    function createBufferedReadable2(upstream, size, logger) {
      if ((0, stream_type_check_1.isReadableStream)(upstream)) {
        return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger);
      }
      const downstream = new node_stream_1.Readable({ read() {
      } });
      let streamBufferingLoggedWarning = false;
      let bytesSeen = 0;
      const buffers = [
        "",
        new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2)),
        new ByteArrayCollector_1.ByteArrayCollector((size2) => Buffer.from(new Uint8Array(size2)))
      ];
      let mode = -1;
      upstream.on("data", (chunk) => {
        const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk);
        if (mode !== chunkMode) {
          if (mode >= 0) {
            downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
          }
          mode = chunkMode;
        }
        if (mode === -1) {
          downstream.push(chunk);
          return;
        }
        const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk);
        bytesSeen += chunkSize;
        const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
          downstream.push(chunk);
        } else {
          const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk);
          if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
            streamBufferingLoggedWarning = true;
            logger === null || logger === void 0 ? void 0 : logger.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
          }
          if (newSize >= size) {
            downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
          }
        }
      });
      upstream.on("end", () => {
        if (mode !== -1) {
          const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
          if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) {
            downstream.push(remainder);
          }
        }
        downstream.push(null);
      });
      return downstream;
    }
    exports.createBufferedReadable = createBufferedReadable2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAwsChunkedEncodingStream = void 0;
    var stream_1 = __require("stream");
    var getAwsChunkedEncodingStream2 = (readableStream, options) => {
      const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
      const checksumRequired = base64Encoder !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
      const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
      const awsChunkedEncodingStream = new stream_1.Readable({ read: () => {
      } });
      readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
      });
      readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r
`);
        if (checksumRequired) {
          const checksum = base64Encoder(await digest);
          awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
          awsChunkedEncodingStream.push(`\r
`);
        }
        awsChunkedEncodingStream.push(null);
      });
      return awsChunkedEncodingStream;
    };
    exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.headStream = void 0;
    async function headStream2(stream2, bytes) {
      var _a2;
      let byteLengthCounter = 0;
      const chunks = [];
      const reader = stream2.getReader();
      let isDone = false;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          byteLengthCounter += (_a2 = value === null || value === void 0 ? void 0 : value.byteLength) !== null && _a2 !== void 0 ? _a2 : 0;
        }
        if (byteLengthCounter >= bytes) {
          break;
        }
        isDone = done;
      }
      reader.releaseLock();
      const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
      let offset = 0;
      for (const chunk of chunks) {
        if (chunk.byteLength > collected.byteLength - offset) {
          collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
          break;
        } else {
          collected.set(chunk, offset);
        }
        offset += chunk.length;
      }
      return collected;
    }
    exports.headStream = headStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/headStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.headStream = void 0;
    var stream_1 = __require("stream");
    var headStream_browser_1 = require_headStream_browser();
    var stream_type_check_1 = require_stream_type_check();
    var headStream2 = (stream2, bytes) => {
      if ((0, stream_type_check_1.isReadableStream)(stream2)) {
        return (0, headStream_browser_1.headStream)(stream2, bytes);
      }
      return new Promise((resolve, reject) => {
        const collector = new Collector();
        collector.limit = bytes;
        stream2.pipe(collector);
        stream2.on("error", (err) => {
          collector.end();
          reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function() {
          const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
          resolve(bytes2);
        });
      });
    };
    exports.headStream = headStream2;
    var Collector = class extends stream_1.Writable {
      constructor() {
        super(...arguments);
        this.buffers = [];
        this.limit = Infinity;
        this.bytesBuffered = 0;
      }
      _write(chunk, encoding, callback) {
        var _a2;
        this.buffers.push(chunk);
        this.bytesBuffered += (_a2 = chunk.byteLength) !== null && _a2 !== void 0 ? _a2 : 0;
        if (this.bytesBuffered >= this.limit) {
          const excess = this.bytesBuffered - this.limit;
          const tailBuffer = this.buffers[this.buffers.length - 1];
          this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
          this.emit("finish");
        }
        callback();
      }
    };
  }
});

// node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs12 = __commonJS({
  "node_modules/@smithy/util-uri-escape/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      escapeUri: () => escapeUri,
      escapeUriPath: () => escapeUriPath
    });
    module.exports = __toCommonJS2(src_exports);
    var escapeUri = /* @__PURE__ */ __name((uri) => (
      // AWS percent-encodes some extra non-standard characters in a URI
      encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode)
    ), "escapeUri");
    var hexEncode = /* @__PURE__ */ __name((c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode");
    var escapeUriPath = /* @__PURE__ */ __name((uri) => uri.split("/").map(escapeUri).join("/"), "escapeUriPath");
  }
});

// node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs13 = __commonJS({
  "node_modules/@smithy/querystring-builder/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      buildQueryString: () => buildQueryString
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_uri_escape = require_dist_cjs12();
    function buildQueryString(query) {
      const parts = [];
      for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = (0, import_util_uri_escape.escapeUri)(key);
        if (Array.isArray(value)) {
          for (let i3 = 0, iLen = value.length; i3 < iLen; i3++) {
            parts.push(`${key}=${(0, import_util_uri_escape.escapeUri)(value[i3])}`);
          }
        } else {
          let qsEntry = key;
          if (value || typeof value === "string") {
            qsEntry += `=${(0, import_util_uri_escape.escapeUri)(value)}`;
          }
          parts.push(qsEntry);
        }
      }
      return parts.join("&");
    }
    __name(buildQueryString, "buildQueryString");
  }
});

// node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs14 = __commonJS({
  "node_modules/@smithy/node-http-handler/dist-cjs/index.js"(exports, module) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      DEFAULT_REQUEST_TIMEOUT: () => DEFAULT_REQUEST_TIMEOUT,
      NodeHttp2Handler: () => NodeHttp2Handler,
      NodeHttpHandler: () => NodeHttpHandler,
      streamCollector: () => streamCollector3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_protocol_http11 = require_dist_cjs2();
    var import_querystring_builder = require_dist_cjs13();
    var import_http = __require("http");
    var import_https = __require("https");
    var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
    var getTransformedHeaders = /* @__PURE__ */ __name((headers) => {
      const transformedHeaders = {};
      for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
      }
      return transformedHeaders;
    }, "getTransformedHeaders");
    var timing = {
      setTimeout: (cb, ms) => setTimeout(cb, ms),
      clearTimeout: (timeoutId) => clearTimeout(timeoutId)
    };
    var DEFER_EVENT_LISTENER_TIME = 1e3;
    var setConnectionTimeout = /* @__PURE__ */ __name((request, reject, timeoutInMs = 0) => {
      if (!timeoutInMs) {
        return -1;
      }
      const registerTimeout = /* @__PURE__ */ __name((offset) => {
        const timeoutId = timing.setTimeout(() => {
          request.destroy();
          reject(
            Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
              name: "TimeoutError"
            })
          );
        }, timeoutInMs - offset);
        const doWithSocket = /* @__PURE__ */ __name((socket) => {
          if (socket?.connecting) {
            socket.on("connect", () => {
              timing.clearTimeout(timeoutId);
            });
          } else {
            timing.clearTimeout(timeoutId);
          }
        }, "doWithSocket");
        if (request.socket) {
          doWithSocket(request.socket);
        } else {
          request.on("socket", doWithSocket);
        }
      }, "registerTimeout");
      if (timeoutInMs < 2e3) {
        registerTimeout(0);
        return 0;
      }
      return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
    }, "setConnectionTimeout");
    var DEFER_EVENT_LISTENER_TIME2 = 3e3;
    var setSocketKeepAlive = /* @__PURE__ */ __name((request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME2) => {
      if (keepAlive !== true) {
        return -1;
      }
      const registerListener = /* @__PURE__ */ __name(() => {
        if (request.socket) {
          request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        } else {
          request.on("socket", (socket) => {
            socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
          });
        }
      }, "registerListener");
      if (deferTimeMs === 0) {
        registerListener();
        return 0;
      }
      return timing.setTimeout(registerListener, deferTimeMs);
    }, "setSocketKeepAlive");
    var DEFER_EVENT_LISTENER_TIME3 = 3e3;
    var setSocketTimeout = /* @__PURE__ */ __name((request, reject, timeoutInMs = DEFAULT_REQUEST_TIMEOUT) => {
      const registerTimeout = /* @__PURE__ */ __name((offset) => {
        const timeout = timeoutInMs - offset;
        const onTimeout = /* @__PURE__ */ __name(() => {
          request.destroy();
          reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
        }, "onTimeout");
        if (request.socket) {
          request.socket.setTimeout(timeout, onTimeout);
          request.on("close", () => request.socket?.removeListener("timeout", onTimeout));
        } else {
          request.setTimeout(timeout, onTimeout);
        }
      }, "registerTimeout");
      if (0 < timeoutInMs && timeoutInMs < 6e3) {
        registerTimeout(0);
        return 0;
      }
      return timing.setTimeout(
        registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME3),
        DEFER_EVENT_LISTENER_TIME3
      );
    }, "setSocketTimeout");
    var import_stream = __require("stream");
    var MIN_WAIT_TIME = 6e3;
    async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
      const headers = request.headers ?? {};
      const expect = headers["Expect"] || headers["expect"];
      let timeoutId = -1;
      let sendBody = true;
      if (expect === "100-continue") {
        sendBody = await Promise.race([
          new Promise((resolve) => {
            timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
          }),
          new Promise((resolve) => {
            httpRequest.on("continue", () => {
              timing.clearTimeout(timeoutId);
              resolve(true);
            });
            httpRequest.on("response", () => {
              timing.clearTimeout(timeoutId);
              resolve(false);
            });
            httpRequest.on("error", () => {
              timing.clearTimeout(timeoutId);
              resolve(false);
            });
          })
        ]);
      }
      if (sendBody) {
        writeBody(httpRequest, request.body);
      }
    }
    __name(writeRequestBody, "writeRequestBody");
    function writeBody(httpRequest, body) {
      if (body instanceof import_stream.Readable) {
        body.pipe(httpRequest);
        return;
      }
      if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
          httpRequest.end(body);
          return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
          httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
          return;
        }
        httpRequest.end(Buffer.from(body));
        return;
      }
      httpRequest.end();
    }
    __name(writeBody, "writeBody");
    var DEFAULT_REQUEST_TIMEOUT = 0;
    var NodeHttpHandler = class _NodeHttpHandler {
      constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
          if (typeof options === "function") {
            options().then((_options) => {
              resolve(this.resolveDefaultConfig(_options));
            }).catch(reject);
          } else {
            resolve(this.resolveDefaultConfig(options));
          }
        });
      }
      static {
        __name(this, "NodeHttpHandler");
      }
      /**
       * @returns the input if it is an HttpHandler of any class,
       * or instantiates a new instance of this handler.
       */
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _NodeHttpHandler(instanceOrOptions);
      }
      /**
       * @internal
       *
       * @param agent - http(s) agent in use by the NodeHttpHandler instance.
       * @param socketWarningTimestamp - last socket usage check timestamp.
       * @param logger - channel for the warning.
       * @returns timestamp of last emitted warning.
       */
      static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
          return socketWarningTimestamp;
        }
        const interval = 15e3;
        if (Date.now() - interval < socketWarningTimestamp) {
          return socketWarningTimestamp;
        }
        if (sockets && requests) {
          for (const origin in sockets) {
            const socketsInUse = sockets[origin]?.length ?? 0;
            const requestsEnqueued = requests[origin]?.length ?? 0;
            if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
              logger?.warn?.(
                `@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`
              );
              return Date.now();
            }
          }
        }
        return socketWarningTimestamp;
      }
      resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
          connectionTimeout,
          requestTimeout: requestTimeout ?? socketTimeout,
          socketAcquisitionWarningTimeout,
          httpAgent: (() => {
            if (httpAgent instanceof import_http.Agent || typeof httpAgent?.destroy === "function") {
              return httpAgent;
            }
            return new import_http.Agent({ keepAlive, maxSockets, ...httpAgent });
          })(),
          httpsAgent: (() => {
            if (httpsAgent instanceof import_https.Agent || typeof httpsAgent?.destroy === "function") {
              return httpsAgent;
            }
            return new import_https.Agent({ keepAlive, maxSockets, ...httpsAgent });
          })(),
          logger: console
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
      }
      async handle(request, { abortSignal } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
          let writeRequestBodyPromise = void 0;
          const timeouts = [];
          const resolve = /* @__PURE__ */ __name(async (arg) => {
            await writeRequestBodyPromise;
            timeouts.forEach(timing.clearTimeout);
            _resolve(arg);
          }, "resolve");
          const reject = /* @__PURE__ */ __name(async (arg) => {
            await writeRequestBodyPromise;
            timeouts.forEach(timing.clearTimeout);
            _reject(arg);
          }, "reject");
          if (!this.config) {
            throw new Error("Node HTTP request handler config is not resolved");
          }
          if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
            return;
          }
          const isSSL = request.protocol === "https:";
          const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
          timeouts.push(
            timing.setTimeout(
              () => {
                this.socketWarningTimestamp = _NodeHttpHandler.checkSocketUsage(
                  agent,
                  this.socketWarningTimestamp,
                  this.config.logger
                );
              },
              this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2e3) + (this.config.connectionTimeout ?? 1e3)
            )
          );
          const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
          let auth = void 0;
          if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}`;
          }
          let path = request.path;
          if (queryString) {
            path += `?${queryString}`;
          }
          if (request.fragment) {
            path += `#${request.fragment}`;
          }
          let hostname = request.hostname ?? "";
          if (hostname[0] === "[" && hostname.endsWith("]")) {
            hostname = request.hostname.slice(1, -1);
          } else {
            hostname = request.hostname;
          }
          const nodeHttpsOptions = {
            headers: request.headers,
            host: hostname,
            method: request.method,
            path,
            port: request.port,
            agent,
            auth
          };
          const requestFunc = isSSL ? import_https.request : import_http.request;
          const req = requestFunc(nodeHttpsOptions, (res) => {
            const httpResponse = new import_protocol_http11.HttpResponse({
              statusCode: res.statusCode || -1,
              reason: res.statusMessage,
              headers: getTransformedHeaders(res.headers),
              body: res
            });
            resolve({ response: httpResponse });
          });
          req.on("error", (err) => {
            if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
              reject(Object.assign(err, { name: "TimeoutError" }));
            } else {
              reject(err);
            }
          });
          if (abortSignal) {
            const onAbort = /* @__PURE__ */ __name(() => {
              req.destroy();
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            }, "onAbort");
            if (typeof abortSignal.addEventListener === "function") {
              const signal = abortSignal;
              signal.addEventListener("abort", onAbort, { once: true });
              req.once("close", () => signal.removeEventListener("abort", onAbort));
            } else {
              abortSignal.onabort = onAbort;
            }
          }
          timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
          timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
          const httpAgent = nodeHttpsOptions.agent;
          if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
            timeouts.push(
              setSocketKeepAlive(req, {
                // @ts-expect-error keepAlive is not public on httpAgent.
                keepAlive: httpAgent.keepAlive,
                // @ts-expect-error keepAliveMsecs is not public on httpAgent.
                keepAliveMsecs: httpAgent.keepAliveMsecs
              })
            );
          }
          writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch((e3) => {
            timeouts.forEach(timing.clearTimeout);
            return _reject(e3);
          });
        });
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          return {
            ...config,
            [key]: value
          };
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
    var import_http22 = __require("http2");
    var import_http2 = __toESM2(__require("http2"));
    var NodeHttp2ConnectionPool = class {
      constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions ?? [];
      }
      static {
        __name(this, "NodeHttp2ConnectionPool");
      }
      poll() {
        if (this.sessions.length > 0) {
          return this.sessions.shift();
        }
      }
      offerLast(session) {
        this.sessions.push(session);
      }
      contains(session) {
        return this.sessions.includes(session);
      }
      remove(session) {
        this.sessions = this.sessions.filter((s3) => s3 !== session);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(connection) {
        for (const session of this.sessions) {
          if (session === connection) {
            if (!session.destroyed) {
              session.destroy();
            }
          }
        }
      }
    };
    var NodeHttp2ConnectionManager = class {
      constructor(config) {
        this.sessionCache = /* @__PURE__ */ new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
          throw new RangeError("maxConcurrency must be greater than zero.");
        }
      }
      static {
        __name(this, "NodeHttp2ConnectionManager");
      }
      lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
          const existingSession = existingPool.poll();
          if (existingSession && !this.config.disableConcurrency) {
            return existingSession;
          }
        }
        const session = import_http2.default.connect(url);
        if (this.config.maxConcurrency) {
          session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
            if (err) {
              throw new Error(
                "Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString()
              );
            }
          });
        }
        session.unref();
        const destroySessionCb = /* @__PURE__ */ __name(() => {
          session.destroy();
          this.deleteSession(url, session);
        }, "destroySessionCb");
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
          session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
      }
      /**
       * Delete a session from the connection pool.
       * @param authority The authority of the session to delete.
       * @param session The session to delete.
       */
      deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
          return;
        }
        if (!existingConnectionPool.contains(session)) {
          return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
      }
      release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
      }
      destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
          for (const session of connectionPool) {
            if (!session.destroyed) {
              session.destroy();
            }
            connectionPool.remove(session);
          }
          this.sessionCache.delete(key);
        }
      }
      setMaxConcurrentStreams(maxConcurrentStreams) {
        if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
          throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
      }
      setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
      }
      getUrlString(request) {
        return request.destination.toString();
      }
    };
    var NodeHttp2Handler = class _NodeHttp2Handler {
      constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
          if (typeof options === "function") {
            options().then((opts) => {
              resolve(opts || {});
            }).catch(reject);
          } else {
            resolve(options || {});
          }
        });
      }
      static {
        __name(this, "NodeHttp2Handler");
      }
      /**
       * @returns the input if it is an HttpHandler of any class,
       * or instantiates a new instance of this handler.
       */
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _NodeHttp2Handler(instanceOrOptions);
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(request, { abortSignal } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
          this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
          if (this.config.maxConcurrentStreams) {
            this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
          }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
          let fulfilled = false;
          let writeRequestBodyPromise = void 0;
          const resolve = /* @__PURE__ */ __name(async (arg) => {
            await writeRequestBodyPromise;
            _resolve(arg);
          }, "resolve");
          const reject = /* @__PURE__ */ __name(async (arg) => {
            await writeRequestBodyPromise;
            _reject(arg);
          }, "reject");
          if (abortSignal?.aborted) {
            fulfilled = true;
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
            return;
          }
          const { hostname, method, port, protocol, query } = request;
          let auth = "";
          if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
          }
          const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
          const requestContext = { destination: new URL(authority) };
          const session = this.connectionManager.lease(requestContext, {
            requestTimeout: this.config?.sessionTimeout,
            disableConcurrentStreams: disableConcurrentStreams || false
          });
          const rejectWithDestroy = /* @__PURE__ */ __name((err) => {
            if (disableConcurrentStreams) {
              this.destroySession(session);
            }
            fulfilled = true;
            reject(err);
          }, "rejectWithDestroy");
          const queryString = (0, import_querystring_builder.buildQueryString)(query || {});
          let path = request.path;
          if (queryString) {
            path += `?${queryString}`;
          }
          if (request.fragment) {
            path += `#${request.fragment}`;
          }
          const req = session.request({
            ...request.headers,
            [import_http22.constants.HTTP2_HEADER_PATH]: path,
            [import_http22.constants.HTTP2_HEADER_METHOD]: method
          });
          session.ref();
          req.on("response", (headers) => {
            const httpResponse = new import_protocol_http11.HttpResponse({
              statusCode: headers[":status"] || -1,
              headers: getTransformedHeaders(headers),
              body: req
            });
            fulfilled = true;
            resolve({ response: httpResponse });
            if (disableConcurrentStreams) {
              session.close();
              this.connectionManager.deleteSession(authority, session);
            }
          });
          if (requestTimeout) {
            req.setTimeout(requestTimeout, () => {
              req.close();
              const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
              timeoutError.name = "TimeoutError";
              rejectWithDestroy(timeoutError);
            });
          }
          if (abortSignal) {
            const onAbort = /* @__PURE__ */ __name(() => {
              req.close();
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              rejectWithDestroy(abortError);
            }, "onAbort");
            if (typeof abortSignal.addEventListener === "function") {
              const signal = abortSignal;
              signal.addEventListener("abort", onAbort, { once: true });
              req.once("close", () => signal.removeEventListener("abort", onAbort));
            } else {
              abortSignal.onabort = onAbort;
            }
          }
          req.on("frameError", (type, code, id) => {
            rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
          });
          req.on("error", rejectWithDestroy);
          req.on("aborted", () => {
            rejectWithDestroy(
              new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`)
            );
          });
          req.on("close", () => {
            session.unref();
            if (disableConcurrentStreams) {
              session.destroy();
            }
            if (!fulfilled) {
              rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
            }
          });
          writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
        });
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          return {
            ...config,
            [key]: value
          };
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      /**
       * Destroys a session.
       * @param session - the session to destroy.
       */
      destroySession(session) {
        if (!session.destroyed) {
          session.destroy();
        }
      }
    };
    var Collector = class extends import_stream.Writable {
      constructor() {
        super(...arguments);
        this.bufferedBytes = [];
      }
      static {
        __name(this, "Collector");
      }
      _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
      }
    };
    var streamCollector3 = /* @__PURE__ */ __name((stream2) => {
      if (isReadableStreamInstance(stream2)) {
        return collectReadableStream(stream2);
      }
      return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream2.pipe(collector);
        stream2.on("error", (err) => {
          collector.end();
          reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function() {
          const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
          resolve(bytes);
        });
      });
    }, "streamCollector");
    var isReadableStreamInstance = /* @__PURE__ */ __name((stream2) => typeof ReadableStream === "function" && stream2 instanceof ReadableStream, "isReadableStreamInstance");
    async function collectReadableStream(stream2) {
      const chunks = [];
      const reader = stream2.getReader();
      let isDone = false;
      let length = 0;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          length += value.length;
        }
        isDone = done;
      }
      const collected = new Uint8Array(length);
      let offset = 0;
      for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
      }
      return collected;
    }
    __name(collectReadableStream, "collectReadableStream");
  }
});

// node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs15 = __commonJS({
  "node_modules/@smithy/fetch-http-handler/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      FetchHttpHandler: () => FetchHttpHandler,
      keepAliveSupport: () => keepAliveSupport,
      streamCollector: () => streamCollector3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_protocol_http11 = require_dist_cjs2();
    var import_querystring_builder = require_dist_cjs13();
    function createRequest(url, requestOptions) {
      return new Request(url, requestOptions);
    }
    __name(createRequest, "createRequest");
    function requestTimeout(timeoutInMs = 0) {
      return new Promise((resolve, reject) => {
        if (timeoutInMs) {
          setTimeout(() => {
            const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
            timeoutError.name = "TimeoutError";
            reject(timeoutError);
          }, timeoutInMs);
        }
      });
    }
    __name(requestTimeout, "requestTimeout");
    var keepAliveSupport = {
      supported: void 0
    };
    var FetchHttpHandler = class _FetchHttpHandler {
      static {
        __name(this, "FetchHttpHandler");
      }
      /**
       * @returns the input if it is an HttpHandler of any class,
       * or instantiates a new instance of this handler.
       */
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _FetchHttpHandler(instanceOrOptions);
      }
      constructor(options) {
        if (typeof options === "function") {
          this.configProvider = options().then((opts) => opts || {});
        } else {
          this.config = options ?? {};
          this.configProvider = Promise.resolve(this.config);
        }
        if (keepAliveSupport.supported === void 0) {
          keepAliveSupport.supported = Boolean(
            typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]")
          );
        }
      }
      destroy() {
      }
      async handle(request, { abortSignal } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        const credentials = this.config.credentials;
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
        const requestOptions = {
          body,
          headers: new Headers(request.headers),
          method,
          credentials
        };
        if (this.config?.cache) {
          requestOptions.cache = this.config.cache;
        }
        if (body) {
          requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
          requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
          requestOptions.keepalive = keepAlive;
        }
        if (typeof this.config.requestInit === "function") {
          Object.assign(requestOptions, this.config.requestInit(request));
        }
        let removeSignalEventListener = /* @__PURE__ */ __name(() => {
        }, "removeSignalEventListener");
        const fetchRequest = createRequest(url, requestOptions);
        const raceOfPromises = [
          fetch(fetchRequest).then((response) => {
            const fetchHeaders = response.headers;
            const transformedHeaders = {};
            for (const pair of fetchHeaders.entries()) {
              transformedHeaders[pair[0]] = pair[1];
            }
            const hasReadableStream = response.body != void 0;
            if (!hasReadableStream) {
              return response.blob().then((body2) => ({
                response: new import_protocol_http11.HttpResponse({
                  headers: transformedHeaders,
                  reason: response.statusText,
                  statusCode: response.status,
                  body: body2
                })
              }));
            }
            return {
              response: new import_protocol_http11.HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: response.body
              })
            };
          }),
          requestTimeout(requestTimeoutInMs)
        ];
        if (abortSignal) {
          raceOfPromises.push(
            new Promise((resolve, reject) => {
              const onAbort = /* @__PURE__ */ __name(() => {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
              }, "onAbort");
              if (typeof abortSignal.addEventListener === "function") {
                const signal = abortSignal;
                signal.addEventListener("abort", onAbort, { once: true });
                removeSignalEventListener = /* @__PURE__ */ __name(() => signal.removeEventListener("abort", onAbort), "removeSignalEventListener");
              } else {
                abortSignal.onabort = onAbort;
              }
            })
          );
        }
        return Promise.race(raceOfPromises).finally(removeSignalEventListener);
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          config[key] = value;
          return config;
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
    var import_util_base643 = require_dist_cjs11();
    var streamCollector3 = /* @__PURE__ */ __name(async (stream2) => {
      if (typeof Blob === "function" && stream2 instanceof Blob || stream2.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== void 0) {
          return new Uint8Array(await stream2.arrayBuffer());
        }
        return collectBlob(stream2);
      }
      return collectStream(stream2);
    }, "streamCollector");
    async function collectBlob(blob) {
      const base64 = await readToBase64(blob);
      const arrayBuffer = (0, import_util_base643.fromBase64)(base64);
      return new Uint8Array(arrayBuffer);
    }
    __name(collectBlob, "collectBlob");
    async function collectStream(stream2) {
      const chunks = [];
      const reader = stream2.getReader();
      let isDone = false;
      let length = 0;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          length += value.length;
        }
        isDone = done;
      }
      const collected = new Uint8Array(length);
      let offset = 0;
      for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
      }
      return collected;
    }
    __name(collectStream, "collectStream");
    function readToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          if (reader.readyState !== 2) {
            return reject(new Error("Reader aborted too early"));
          }
          const result = reader.result ?? "";
          const commaIndex = result.indexOf(",");
          const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
          resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
      });
    }
    __name(readToBase64, "readToBase64");
  }
});

// node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs16 = __commonJS({
  "node_modules/@smithy/util-hex-encoding/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromHex: () => fromHex,
      toHex: () => toHex
    });
    module.exports = __toCommonJS2(src_exports);
    var SHORT_TO_HEX = {};
    var HEX_TO_SHORT = {};
    for (let i3 = 0; i3 < 256; i3++) {
      let encodedByte = i3.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i3] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i3;
    }
    function fromHex(encoded) {
      if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
      }
      const out = new Uint8Array(encoded.length / 2);
      for (let i3 = 0; i3 < encoded.length; i3 += 2) {
        const encodedByte = encoded.slice(i3, i3 + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
          out[i3 / 2] = HEX_TO_SHORT[encodedByte];
        } else {
          throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
      }
      return out;
    }
    __name(fromHex, "fromHex");
    function toHex(bytes) {
      let out = "";
      for (let i3 = 0; i3 < bytes.byteLength; i3++) {
        out += SHORT_TO_HEX[bytes[i3]];
      }
      return out;
    }
    __name(toHex, "toHex");
  }
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sdkStreamMixin = void 0;
    var fetch_http_handler_1 = require_dist_cjs15();
    var util_base64_1 = require_dist_cjs11();
    var util_hex_encoding_1 = require_dist_cjs16();
    var util_utf8_1 = require_dist_cjs10();
    var stream_type_check_1 = require_stream_type_check();
    var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    var sdkStreamMixin2 = (stream2) => {
      var _a2, _b;
      if (!isBlobInstance(stream2) && !(0, stream_type_check_1.isReadableStream)(stream2)) {
        const name = ((_b = (_a2 = stream2 === null || stream2 === void 0 ? void 0 : stream2.__proto__) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.name) || stream2;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, fetch_http_handler_1.streamCollector)(stream2);
      };
      const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
          throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
      };
      return Object.assign(stream2, {
        transformToByteArray,
        transformToString: async (encoding) => {
          const buf = await transformToByteArray();
          if (encoding === "base64") {
            return (0, util_base64_1.toBase64)(buf);
          } else if (encoding === "hex") {
            return (0, util_hex_encoding_1.toHex)(buf);
          } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
            return (0, util_utf8_1.toUtf8)(buf);
          } else if (typeof TextDecoder === "function") {
            return new TextDecoder(encoding).decode(buf);
          } else {
            throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          transformed = true;
          if (isBlobInstance(stream2)) {
            return blobToWebStream(stream2);
          } else if ((0, stream_type_check_1.isReadableStream)(stream2)) {
            return stream2;
          } else {
            throw new Error(`Cannot transform payload to web stream, got ${stream2}`);
          }
        }
      });
    };
    exports.sdkStreamMixin = sdkStreamMixin2;
    var isBlobInstance = (stream2) => typeof Blob === "function" && stream2 instanceof Blob;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sdkStreamMixin = void 0;
    var node_http_handler_1 = require_dist_cjs14();
    var util_buffer_from_1 = require_dist_cjs9();
    var stream_1 = __require("stream");
    var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
    var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    var sdkStreamMixin2 = (stream2) => {
      var _a2, _b;
      if (!(stream2 instanceof stream_1.Readable)) {
        try {
          return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream2);
        } catch (e3) {
          const name = ((_b = (_a2 = stream2 === null || stream2 === void 0 ? void 0 : stream2.__proto__) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.name) || stream2;
          throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream2);
      };
      return Object.assign(stream2, {
        transformToByteArray,
        transformToString: async (encoding) => {
          const buf = await transformToByteArray();
          if (encoding === void 0 || Buffer.isEncoding(encoding)) {
            return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
          } else {
            const decoder = new TextDecoder(encoding);
            return decoder.decode(buf);
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          if (stream2.readableFlowing !== null) {
            throw new Error("The stream has been consumed by other callbacks.");
          }
          if (typeof stream_1.Readable.toWeb !== "function") {
            throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
          }
          transformed = true;
          return stream_1.Readable.toWeb(stream2);
        }
      });
    };
    exports.sdkStreamMixin = sdkStreamMixin2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitStream = void 0;
    async function splitStream2(stream2) {
      if (typeof stream2.stream === "function") {
        stream2 = stream2.stream();
      }
      const readableStream = stream2;
      return readableStream.tee();
    }
    exports.splitStream = splitStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/splitStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitStream = void 0;
    var stream_1 = __require("stream");
    var splitStream_browser_1 = require_splitStream_browser();
    var stream_type_check_1 = require_stream_type_check();
    async function splitStream2(stream2) {
      if ((0, stream_type_check_1.isReadableStream)(stream2) || (0, stream_type_check_1.isBlob)(stream2)) {
        return (0, splitStream_browser_1.splitStream)(stream2);
      }
      const stream1 = new stream_1.PassThrough();
      const stream22 = new stream_1.PassThrough();
      stream2.pipe(stream1);
      stream2.pipe(stream22);
      return [stream1, stream22];
    }
    exports.splitStream = splitStream2;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs17 = __commonJS({
  "node_modules/@smithy/util-stream/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Uint8ArrayBlobAdapter: () => Uint8ArrayBlobAdapter2
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_base643 = require_dist_cjs11();
    var import_util_utf83 = require_dist_cjs10();
    function transformToString(payload, encoding = "utf-8") {
      if (encoding === "base64") {
        return (0, import_util_base643.toBase64)(payload);
      }
      return (0, import_util_utf83.toUtf8)(payload);
    }
    __name(transformToString, "transformToString");
    function transformFromString(str, encoding) {
      if (encoding === "base64") {
        return Uint8ArrayBlobAdapter2.mutate((0, import_util_base643.fromBase64)(str));
      }
      return Uint8ArrayBlobAdapter2.mutate((0, import_util_utf83.fromUtf8)(str));
    }
    __name(transformFromString, "transformFromString");
    var Uint8ArrayBlobAdapter2 = class _Uint8ArrayBlobAdapter extends Uint8Array {
      static {
        __name(this, "Uint8ArrayBlobAdapter");
      }
      /**
       * @param source - such as a string or Stream.
       * @returns a new Uint8ArrayBlobAdapter extending Uint8Array.
       */
      static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
          case "string":
            return transformFromString(source, encoding);
          default:
            throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
      }
      /**
       * @param source - Uint8Array to be mutated.
       * @returns the same Uint8Array but with prototype switched to Uint8ArrayBlobAdapter.
       */
      static mutate(source) {
        Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
        return source;
      }
      /**
       * @param encoding - default 'utf-8'.
       * @returns the blob as string.
       */
      transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
      }
    };
    __reExport(src_exports, require_ChecksumStream(), module.exports);
    __reExport(src_exports, require_createChecksumStream(), module.exports);
    __reExport(src_exports, require_createBufferedReadable(), module.exports);
    __reExport(src_exports, require_getAwsChunkedEncodingStream(), module.exports);
    __reExport(src_exports, require_headStream(), module.exports);
    __reExport(src_exports, require_sdk_stream_mixin(), module.exports);
    __reExport(src_exports, require_splitStream(), module.exports);
    __reExport(src_exports, require_stream_type_check(), module.exports);
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js
var import_util_stream, collectBody2;
var init_collect_stream_body = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js"() {
    import_util_stream = __toESM(require_dist_cjs17());
    collectBody2 = async (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return import_util_stream.Uint8ArrayBlobAdapter.mutate(streamBody);
      }
      if (!streamBody) {
        return import_util_stream.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
      }
      const fromContext = context.streamCollector(streamBody);
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(await fromContext);
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js
function extendedEncodeURIComponent2(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
    return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
  });
}
var init_extended_encode_uri_component = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js"() {
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js
var resolvedPath2;
var init_resolve_path = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js"() {
    init_extended_encode_uri_component();
    resolvedPath2 = (resolvedPath3, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
      if (input != null && input[memberName] !== void 0) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
          throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath3 = resolvedPath3.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent2(segment)).join("/") : extendedEncodeURIComponent2(labelValue));
      } else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
      }
      return resolvedPath3;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var import_protocol_http2, RequestBuilder;
var init_requestBuilder = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js"() {
    import_protocol_http2 = __toESM(require_dist_cjs2());
    init_resolve_path();
    RequestBuilder = class {
      constructor(input, context) {
        this.input = input;
        this.context = context;
        this.query = {};
        this.method = "";
        this.headers = {};
        this.path = "";
        this.body = null;
        this.hostname = "";
        this.resolvePathStack = [];
      }
      async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
          resolvePath(this.path);
        }
        return new import_protocol_http2.HttpRequest({
          protocol,
          hostname: this.hostname || hostname,
          port,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers
        });
      }
      hn(hostname) {
        this.hostname = hostname;
        return this;
      }
      bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
          this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
      }
      p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
          this.path = resolvedPath2(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
      }
      h(headers) {
        this.headers = headers;
        return this;
      }
      q(query) {
        this.query = query;
        return this;
      }
      b(body) {
        this.body = body;
        return this;
      }
      m(method) {
        this.method = method;
        return this;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/index.js
var protocols_exports = {};
__export(protocols_exports, {
  RequestBuilder: () => RequestBuilder,
  collectBody: () => collectBody2,
  extendedEncodeURIComponent: () => extendedEncodeURIComponent2,
  requestBuilder: () => requestBuilder,
  resolvedPath: () => resolvedPath2
});
var init_protocols = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/index.js"() {
    init_collect_stream_body();
    init_extended_encode_uri_component();
    init_requestBuilder();
    init_resolve_path();
  }
});

// node_modules/@smithy/core/dist-es/protocols/requestBuilder.js
var init_requestBuilder2 = __esm({
  "node_modules/@smithy/core/dist-es/protocols/requestBuilder.js"() {
    init_protocols();
  }
});

// node_modules/@smithy/core/dist-es/setFeature.js
function setFeature(context, feature, value) {
  if (!context.__smithy_context) {
    context.__smithy_context = {
      features: {}
    };
  } else if (!context.__smithy_context.features) {
    context.__smithy_context.features = {};
  }
  context.__smithy_context.features[feature] = value;
}
var init_setFeature = __esm({
  "node_modules/@smithy/core/dist-es/setFeature.js"() {
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
var DefaultIdentityProviderConfig;
var init_DefaultIdentityProviderConfig = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js"() {
    DefaultIdentityProviderConfig = class {
      constructor(config) {
        this.authSchemes = /* @__PURE__ */ new Map();
        for (const [key, value] of Object.entries(config)) {
          if (value !== void 0) {
            this.authSchemes.set(key, value);
          }
        }
      }
      getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
var import_protocol_http3, import_types4, HttpApiKeyAuthSigner;
var init_httpApiKeyAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js"() {
    import_protocol_http3 = __toESM(require_dist_cjs2());
    import_types4 = __toESM(require_dist_cjs());
    HttpApiKeyAuthSigner = class {
      async sign(httpRequest, identity, signingProperties) {
        if (!signingProperties) {
          throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        }
        if (!signingProperties.name) {
          throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        }
        if (!signingProperties.in) {
          throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        }
        if (!identity.apiKey) {
          throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        }
        const clonedRequest = import_protocol_http3.HttpRequest.clone(httpRequest);
        if (signingProperties.in === import_types4.HttpApiKeyAuthLocation.QUERY) {
          clonedRequest.query[signingProperties.name] = identity.apiKey;
        } else if (signingProperties.in === import_types4.HttpApiKeyAuthLocation.HEADER) {
          clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity.apiKey}` : identity.apiKey;
        } else {
          throw new Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + signingProperties.in + "`");
        }
        return clonedRequest;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
var import_protocol_http4, HttpBearerAuthSigner;
var init_httpBearerAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js"() {
    import_protocol_http4 = __toESM(require_dist_cjs2());
    HttpBearerAuthSigner = class {
      async sign(httpRequest, identity, signingProperties) {
        const clonedRequest = import_protocol_http4.HttpRequest.clone(httpRequest);
        if (!identity.token) {
          throw new Error("request could not be signed with `token` since the `token` is not defined");
        }
        clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
        return clonedRequest;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
var NoAuthSigner;
var init_noAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js"() {
    NoAuthSigner = class {
      async sign(httpRequest, identity, signingProperties) {
        return httpRequest;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
var init_httpAuthSchemes = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js"() {
    init_httpApiKeyAuth();
    init_httpBearerAuth();
    init_noAuth();
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
var createIsIdentityExpiredFunction, EXPIRATION_MS, isIdentityExpired, doesIdentityRequireRefresh, memoizeIdentityProvider;
var init_memoizeIdentityProvider = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js"() {
    createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
    EXPIRATION_MS = 3e5;
    isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
    doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
    memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
      if (provider === void 0) {
        return void 0;
      }
      const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async (options) => {
        if (!pending) {
          pending = normalizedProvider(options);
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        if (isConstant) {
          return resolved;
        }
        if (!requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider(options);
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
var init_util_identity_and_auth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js"() {
    init_DefaultIdentityProviderConfig();
    init_httpAuthSchemes();
    init_memoizeIdentityProvider();
  }
});

// node_modules/@smithy/core/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,
  EXPIRATION_MS: () => EXPIRATION_MS,
  HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,
  HttpBearerAuthSigner: () => HttpBearerAuthSigner,
  NoAuthSigner: () => NoAuthSigner,
  createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,
  createPaginator: () => createPaginator,
  doesIdentityRequireRefresh: () => doesIdentityRequireRefresh,
  getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,
  getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,
  getHttpSigningPlugin: () => getHttpSigningPlugin,
  getSmithyContext: () => getSmithyContext,
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,
  httpAuthSchemeMiddleware: () => httpAuthSchemeMiddleware,
  httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,
  httpSigningMiddleware: () => httpSigningMiddleware,
  httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,
  isIdentityExpired: () => isIdentityExpired,
  memoizeIdentityProvider: () => memoizeIdentityProvider,
  normalizeProvider: () => normalizeProvider,
  requestBuilder: () => requestBuilder,
  setFeature: () => setFeature
});
var init_dist_es = __esm({
  "node_modules/@smithy/core/dist-es/index.js"() {
    init_getSmithyContext();
    init_middleware_http_auth_scheme();
    init_middleware_http_signing();
    init_normalizeProvider();
    init_createPaginator();
    init_requestBuilder2();
    init_setFeature();
    init_util_identity_and_auth();
  }
});

// node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs18 = __commonJS({
  "node_modules/@smithy/util-endpoints/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      EndpointCache: () => EndpointCache3,
      EndpointError: () => EndpointError2,
      customEndpointFunctions: () => customEndpointFunctions3,
      isIpAddress: () => isIpAddress2,
      isValidHostLabel: () => isValidHostLabel,
      resolveEndpoint: () => resolveEndpoint4
    });
    module.exports = __toCommonJS2(src_exports);
    var EndpointCache3 = class {
      /**
       * @param [size] - desired average maximum capacity. A buffer of 10 additional keys will be allowed
       *                 before keys are dropped.
       * @param [params] - list of params to consider as part of the cache key.
       *
       * If the params list is not populated, no caching will happen.
       * This may be out of order depending on how the object is created and arrives to this class.
       */
      constructor({ size, params }) {
        this.data = /* @__PURE__ */ new Map();
        this.parameters = [];
        this.capacity = size ?? 50;
        if (params) {
          this.parameters = params;
        }
      }
      static {
        __name(this, "EndpointCache");
      }
      /**
       * @param endpointParams - query for endpoint.
       * @param resolver - provider of the value if not present.
       * @returns endpoint corresponding to the query.
       */
      get(endpointParams, resolver) {
        const key = this.hash(endpointParams);
        if (key === false) {
          return resolver();
        }
        if (!this.data.has(key)) {
          if (this.data.size > this.capacity + 10) {
            const keys = this.data.keys();
            let i3 = 0;
            while (true) {
              const { value, done } = keys.next();
              this.data.delete(value);
              if (done || ++i3 > 10) {
                break;
              }
            }
          }
          this.data.set(key, resolver());
        }
        return this.data.get(key);
      }
      size() {
        return this.data.size;
      }
      /**
       * @returns cache key or false if not cachable.
       */
      hash(endpointParams) {
        let buffer = "";
        const { parameters } = this;
        if (parameters.length === 0) {
          return false;
        }
        for (const param of parameters) {
          const val2 = String(endpointParams[param] ?? "");
          if (val2.includes("|;")) {
            return false;
          }
          buffer += val2 + "|;";
        }
        return buffer;
      }
    };
    var IP_V4_REGEX = new RegExp(
      `^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`
    );
    var isIpAddress2 = /* @__PURE__ */ __name((value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]"), "isIpAddress");
    var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    var isValidHostLabel = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
      if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
      }
      const labels = value.split(".");
      for (const label of labels) {
        if (!isValidHostLabel(label)) {
          return false;
        }
      }
      return true;
    }, "isValidHostLabel");
    var customEndpointFunctions3 = {};
    var debugId = "endpoints";
    function toDebugString(input) {
      if (typeof input !== "object" || input == null) {
        return input;
      }
      if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
      }
      if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
      }
      return JSON.stringify(input, null, 2);
    }
    __name(toDebugString, "toDebugString");
    var EndpointError2 = class extends Error {
      static {
        __name(this, "EndpointError");
      }
      constructor(message) {
        super(message);
        this.name = "EndpointError";
      }
    };
    var booleanEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "booleanEquals");
    var getAttrPathList = /* @__PURE__ */ __name((path) => {
      const parts = path.split(".");
      const pathList = [];
      for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
          if (part.indexOf("]") !== part.length - 1) {
            throw new EndpointError2(`Path: '${path}' does not end with ']'`);
          }
          const arrayIndex = part.slice(squareBracketIndex + 1, -1);
          if (Number.isNaN(parseInt(arrayIndex))) {
            throw new EndpointError2(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
          }
          if (squareBracketIndex !== 0) {
            pathList.push(part.slice(0, squareBracketIndex));
          }
          pathList.push(arrayIndex);
        } else {
          pathList.push(part);
        }
      }
      return pathList;
    }, "getAttrPathList");
    var getAttr = /* @__PURE__ */ __name((value, path) => getAttrPathList(path).reduce((acc, index) => {
      if (typeof acc !== "object") {
        throw new EndpointError2(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
      } else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
      }
      return acc[index];
    }, value), "getAttr");
    var isSet = /* @__PURE__ */ __name((value) => value != null, "isSet");
    var not = /* @__PURE__ */ __name((value) => !value, "not");
    var import_types32 = require_dist_cjs();
    var DEFAULT_PORTS = {
      [import_types32.EndpointURLScheme.HTTP]: 80,
      [import_types32.EndpointURLScheme.HTTPS]: 443
    };
    var parseURL = /* @__PURE__ */ __name((value) => {
      const whatwgURL = (() => {
        try {
          if (value instanceof URL) {
            return value;
          }
          if (typeof value === "object" && "hostname" in value) {
            const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
            const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
            url.search = Object.entries(query).map(([k3, v6]) => `${k3}=${v6}`).join("&");
            return url;
          }
          return new URL(value);
        } catch (error) {
          return null;
        }
      })();
      if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
      }
      const urlString = whatwgURL.href;
      const { host, hostname, pathname, protocol, search } = whatwgURL;
      if (search) {
        return null;
      }
      const scheme = protocol.slice(0, -1);
      if (!Object.values(import_types32.EndpointURLScheme).includes(scheme)) {
        return null;
      }
      const isIp = isIpAddress2(hostname);
      const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
      const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
      return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
      };
    }, "parseURL");
    var stringEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "stringEquals");
    var substring = /* @__PURE__ */ __name((input, start, stop, reverse) => {
      if (start >= stop || input.length < stop) {
        return null;
      }
      if (!reverse) {
        return input.substring(start, stop);
      }
      return input.substring(input.length - stop, input.length - start);
    }, "substring");
    var uriEncode = /* @__PURE__ */ __name((value) => encodeURIComponent(value).replace(/[!*'()]/g, (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode");
    var endpointFunctions = {
      booleanEquals,
      getAttr,
      isSet,
      isValidHostLabel,
      not,
      parseURL,
      stringEquals,
      substring,
      uriEncode
    };
    var evaluateTemplate = /* @__PURE__ */ __name((template, options) => {
      const evaluatedTemplateArr = [];
      const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      let currentIndex = 0;
      while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(currentIndex));
          break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex));
          break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
          currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
          const [refName, attrName] = parameterName.split("#");
          evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        } else {
          evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
      }
      return evaluatedTemplateArr.join("");
    }, "evaluateTemplate");
    var getReferenceValue = /* @__PURE__ */ __name(({ ref }, options) => {
      const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      return referenceRecord[ref];
    }, "getReferenceValue");
    var evaluateExpression = /* @__PURE__ */ __name((obj, keyName, options) => {
      if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
      } else if (obj["fn"]) {
        return callFunction(obj, options);
      } else if (obj["ref"]) {
        return getReferenceValue(obj, options);
      }
      throw new EndpointError2(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    }, "evaluateExpression");
    var callFunction = /* @__PURE__ */ __name(({ fn, argv }, options) => {
      const evaluatedArgs = argv.map(
        (arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options)
      );
      const fnSegments = fn.split(".");
      if (fnSegments[0] in customEndpointFunctions3 && fnSegments[1] != null) {
        return customEndpointFunctions3[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
      }
      return endpointFunctions[fn](...evaluatedArgs);
    }, "callFunction");
    var evaluateCondition = /* @__PURE__ */ __name(({ assign, ...fnArgs }, options) => {
      if (assign && assign in options.referenceRecord) {
        throw new EndpointError2(`'${assign}' is already defined in Reference Record.`);
      }
      const value = callFunction(fnArgs, options);
      options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
      return {
        result: value === "" ? true : !!value,
        ...assign != null && { toAssign: { name: assign, value } }
      };
    }, "evaluateCondition");
    var evaluateConditions = /* @__PURE__ */ __name((conditions = [], options) => {
      const conditionsReferenceRecord = {};
      for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...conditionsReferenceRecord
          }
        });
        if (!result) {
          return { result };
        }
        if (toAssign) {
          conditionsReferenceRecord[toAssign.name] = toAssign.value;
          options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
      }
      return { result: true, referenceRecord: conditionsReferenceRecord };
    }, "evaluateConditions");
    var getEndpointHeaders = /* @__PURE__ */ __name((headers, options) => Object.entries(headers).reduce(
      (acc, [headerKey, headerVal]) => ({
        ...acc,
        [headerKey]: headerVal.map((headerValEntry) => {
          const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
          if (typeof processedExpr !== "string") {
            throw new EndpointError2(`Header '${headerKey}' value '${processedExpr}' is not a string`);
          }
          return processedExpr;
        })
      }),
      {}
    ), "getEndpointHeaders");
    var getEndpointProperty = /* @__PURE__ */ __name((property, options) => {
      if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
      }
      switch (typeof property) {
        case "string":
          return evaluateTemplate(property, options);
        case "object":
          if (property === null) {
            throw new EndpointError2(`Unexpected endpoint property: ${property}`);
          }
          return getEndpointProperties(property, options);
        case "boolean":
          return property;
        default:
          throw new EndpointError2(`Unexpected endpoint property type: ${typeof property}`);
      }
    }, "getEndpointProperty");
    var getEndpointProperties = /* @__PURE__ */ __name((properties, options) => Object.entries(properties).reduce(
      (acc, [propertyKey, propertyVal]) => ({
        ...acc,
        [propertyKey]: getEndpointProperty(propertyVal, options)
      }),
      {}
    ), "getEndpointProperties");
    var getEndpointUrl = /* @__PURE__ */ __name((endpointUrl, options) => {
      const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
      if (typeof expression === "string") {
        try {
          return new URL(expression);
        } catch (error) {
          console.error(`Failed to construct URL with ${expression}`, error);
          throw error;
        }
      }
      throw new EndpointError2(`Endpoint URL must be a string, got ${typeof expression}`);
    }, "getEndpointUrl");
    var evaluateEndpointRule = /* @__PURE__ */ __name((endpointRule, options) => {
      const { conditions, endpoint } = endpointRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      };
      const { url, properties, headers } = endpoint;
      options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
      return {
        ...headers != void 0 && {
          headers: getEndpointHeaders(headers, endpointRuleOptions)
        },
        ...properties != void 0 && {
          properties: getEndpointProperties(properties, endpointRuleOptions)
        },
        url: getEndpointUrl(url, endpointRuleOptions)
      };
    }, "evaluateEndpointRule");
    var evaluateErrorRule = /* @__PURE__ */ __name((errorRule, options) => {
      const { conditions, error } = errorRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      throw new EndpointError2(
        evaluateExpression(error, "Error", {
          ...options,
          referenceRecord: { ...options.referenceRecord, ...referenceRecord }
        })
      );
    }, "evaluateErrorRule");
    var evaluateTreeRule = /* @__PURE__ */ __name((treeRule, options) => {
      const { conditions, rules } = treeRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      return evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      });
    }, "evaluateTreeRule");
    var evaluateRules = /* @__PURE__ */ __name((rules, options) => {
      for (const rule of rules) {
        if (rule.type === "endpoint") {
          const endpointOrUndefined = evaluateEndpointRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else if (rule.type === "error") {
          evaluateErrorRule(rule, options);
        } else if (rule.type === "tree") {
          const endpointOrUndefined = evaluateTreeRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else {
          throw new EndpointError2(`Unknown endpoint rule: ${rule}`);
        }
      }
      throw new EndpointError2(`Rules evaluation failed`);
    }, "evaluateRules");
    var resolveEndpoint4 = /* @__PURE__ */ __name((ruleSetObject, options) => {
      const { endpointParams, logger } = options;
      const { parameters, rules } = ruleSetObject;
      options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
      const paramsWithDefault = Object.entries(parameters).filter(([, v6]) => v6.default != null).map(([k3, v6]) => [k3, v6.default]);
      if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
          endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
      }
      const requiredParams = Object.entries(parameters).filter(([, v6]) => v6.required).map(([k3]) => k3);
      for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
          throw new EndpointError2(`Missing required parameter: '${requiredParam}'`);
        }
      }
      const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
      options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
      return endpoint;
    }, "resolveEndpoint");
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs19 = __commonJS({
  "node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      ConditionObject: () => import_util_endpoints5.ConditionObject,
      DeprecatedObject: () => import_util_endpoints5.DeprecatedObject,
      EndpointError: () => import_util_endpoints5.EndpointError,
      EndpointObject: () => import_util_endpoints5.EndpointObject,
      EndpointObjectHeaders: () => import_util_endpoints5.EndpointObjectHeaders,
      EndpointObjectProperties: () => import_util_endpoints5.EndpointObjectProperties,
      EndpointParams: () => import_util_endpoints5.EndpointParams,
      EndpointResolverOptions: () => import_util_endpoints5.EndpointResolverOptions,
      EndpointRuleObject: () => import_util_endpoints5.EndpointRuleObject,
      ErrorRuleObject: () => import_util_endpoints5.ErrorRuleObject,
      EvaluateOptions: () => import_util_endpoints5.EvaluateOptions,
      Expression: () => import_util_endpoints5.Expression,
      FunctionArgv: () => import_util_endpoints5.FunctionArgv,
      FunctionObject: () => import_util_endpoints5.FunctionObject,
      FunctionReturn: () => import_util_endpoints5.FunctionReturn,
      ParameterObject: () => import_util_endpoints5.ParameterObject,
      ReferenceObject: () => import_util_endpoints5.ReferenceObject,
      ReferenceRecord: () => import_util_endpoints5.ReferenceRecord,
      RuleSetObject: () => import_util_endpoints5.RuleSetObject,
      RuleSetRules: () => import_util_endpoints5.RuleSetRules,
      TreeRuleObject: () => import_util_endpoints5.TreeRuleObject,
      awsEndpointFunctions: () => awsEndpointFunctions3,
      getUserAgentPrefix: () => getUserAgentPrefix,
      isIpAddress: () => import_util_endpoints5.isIpAddress,
      partition: () => partition,
      resolveEndpoint: () => import_util_endpoints5.resolveEndpoint,
      setPartitionInfo: () => setPartitionInfo,
      useDefaultPartitionInfo: () => useDefaultPartitionInfo
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_endpoints5 = require_dist_cjs18();
    var isVirtualHostableS3Bucket = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
      if (allowSubDomains) {
        for (const label of value.split(".")) {
          if (!isVirtualHostableS3Bucket(label)) {
            return false;
          }
        }
        return true;
      }
      if (!(0, import_util_endpoints5.isValidHostLabel)(value)) {
        return false;
      }
      if (value.length < 3 || value.length > 63) {
        return false;
      }
      if (value !== value.toLowerCase()) {
        return false;
      }
      if ((0, import_util_endpoints5.isIpAddress)(value)) {
        return false;
      }
      return true;
    }, "isVirtualHostableS3Bucket");
    var ARN_DELIMITER = ":";
    var RESOURCE_DELIMITER = "/";
    var parseArn = /* @__PURE__ */ __name((value) => {
      const segments = value.split(ARN_DELIMITER);
      if (segments.length < 6)
        return null;
      const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
      if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
        return null;
      const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
      return {
        partition: partition2,
        service,
        region,
        accountId,
        resourceId
      };
    }, "parseArn");
    var partitions_default = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }],
      version: "1.1"
    };
    var selectedPartitionsInfo = partitions_default;
    var selectedUserAgentPrefix = "";
    var partition = /* @__PURE__ */ __name((value) => {
      const { partitions } = selectedPartitionsInfo;
      for (const partition2 of partitions) {
        const { regions, outputs } = partition2;
        for (const [region, regionData] of Object.entries(regions)) {
          if (region === value) {
            return {
              ...outputs,
              ...regionData
            };
          }
        }
      }
      for (const partition2 of partitions) {
        const { regionRegex, outputs } = partition2;
        if (new RegExp(regionRegex).test(value)) {
          return {
            ...outputs
          };
        }
      }
      const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
      if (!DEFAULT_PARTITION) {
        throw new Error(
          "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."
        );
      }
      return {
        ...DEFAULT_PARTITION.outputs
      };
    }, "partition");
    var setPartitionInfo = /* @__PURE__ */ __name((partitionsInfo, userAgentPrefix = "") => {
      selectedPartitionsInfo = partitionsInfo;
      selectedUserAgentPrefix = userAgentPrefix;
    }, "setPartitionInfo");
    var useDefaultPartitionInfo = /* @__PURE__ */ __name(() => {
      setPartitionInfo(partitions_default, "");
    }, "useDefaultPartitionInfo");
    var getUserAgentPrefix = /* @__PURE__ */ __name(() => selectedUserAgentPrefix, "getUserAgentPrefix");
    var awsEndpointFunctions3 = {
      isVirtualHostableS3Bucket,
      parseArn,
      partition
    };
    import_util_endpoints5.customEndpointFunctions.aws = awsEndpointFunctions3;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js
var state, emitWarningIfUnsupportedVersion;
var init_emitWarningIfUnsupportedVersion = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js"() {
    state = {
      warningEmitted: false
    };
    emitWarningIfUnsupportedVersion = (version3) => {
      if (version3 && !state.warningEmitted && parseInt(version3.substring(1, version3.indexOf("."))) < 18) {
        state.warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
      }
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js
function setCredentialFeature(credentials, feature, value) {
  if (!credentials.$source) {
    credentials.$source = {};
  }
  credentials.$source[feature] = value;
  return credentials;
}
var init_setCredentialFeature = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js"() {
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js
function setFeature2(context, feature, value) {
  if (!context.__aws_sdk_context) {
    context.__aws_sdk_context = {
      features: {}
    };
  } else if (!context.__aws_sdk_context.features) {
    context.__aws_sdk_context.features = {};
  }
  context.__aws_sdk_context.features[feature] = value;
}
var init_setFeature2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js"() {
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/index.js
var client_exports = {};
__export(client_exports, {
  emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
  setCredentialFeature: () => setCredentialFeature,
  setFeature: () => setFeature2,
  state: () => state
});
var init_client = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/index.js"() {
    init_emitWarningIfUnsupportedVersion();
    init_setCredentialFeature();
    init_setFeature2();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
var import_protocol_http5, getDateHeader;
var init_getDateHeader = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js"() {
    import_protocol_http5 = __toESM(require_dist_cjs2());
    getDateHeader = (response) => import_protocol_http5.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js"() {
    getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js"() {
    init_getSkewCorrectedDate();
    isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js"() {
    init_isClockSkewed();
    getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
      const clockTimeInMs = Date.parse(clockTime);
      if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
      }
      return currentSystemClockOffset;
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js
var init_utils = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js"() {
    init_getDateHeader();
    init_getSkewCorrectedDate();
    init_getUpdatedSystemClockOffset();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var import_protocol_http6, throwSigningPropertyError, validateSigningProperties, AwsSdkSigV4Signer, AWSSDKSigV4Signer;
var init_AwsSdkSigV4Signer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js"() {
    import_protocol_http6 = __toESM(require_dist_cjs2());
    init_utils();
    throwSigningPropertyError = (name, property) => {
      if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
      }
      return property;
    };
    validateSigningProperties = async (signingProperties) => {
      const context = throwSigningPropertyError("context", signingProperties.context);
      const config = throwSigningPropertyError("config", signingProperties.config);
      const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
      const signerFunction = throwSigningPropertyError("signer", config.signer);
      const signer = await signerFunction(authScheme);
      const signingRegion = signingProperties?.signingRegion;
      const signingRegionSet = signingProperties?.signingRegionSet;
      const signingName = signingProperties?.signingName;
      return {
        config,
        signer,
        signingRegion,
        signingRegionSet,
        signingName
      };
    };
    AwsSdkSigV4Signer = class {
      async sign(httpRequest, identity, signingProperties) {
        if (!import_protocol_http6.HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const validatedProps = await validateSigningProperties(signingProperties);
        const { config, signer } = validatedProps;
        let { signingRegion, signingName } = validatedProps;
        const handlerExecutionContext = signingProperties.context;
        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
          const [first, second] = handlerExecutionContext.authSchemes;
          if (first?.name === "sigv4a" && second?.name === "sigv4") {
            signingRegion = second?.signingRegion ?? signingRegion;
            signingName = second?.signingName ?? signingName;
          }
        }
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion,
          signingService: signingName
        });
        return signedRequest;
      }
      errorHandler(signingProperties) {
        return (error) => {
          const serverTime = error.ServerTime ?? getDateHeader(error.$response);
          if (serverTime) {
            const config = throwSigningPropertyError("config", signingProperties.config);
            const initialSystemClockOffset = config.systemClockOffset;
            config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
            const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
            if (clockSkewCorrected && error.$metadata) {
              error.$metadata.clockSkewCorrected = true;
            }
          }
          throw error;
        };
      }
      successHandler(httpResponse, signingProperties) {
        const dateHeader = getDateHeader(httpResponse);
        if (dateHeader) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
        }
      }
    };
    AWSSDKSigV4Signer = AwsSdkSigV4Signer;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
var import_protocol_http7, AwsSdkSigV4ASigner;
var init_AwsSdkSigV4ASigner = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js"() {
    import_protocol_http7 = __toESM(require_dist_cjs2());
    init_utils();
    init_AwsSdkSigV4Signer();
    AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
      async sign(httpRequest, identity, signingProperties) {
        if (!import_protocol_http7.HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
        const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
        const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion: multiRegionOverride,
          signingService: signingName
        });
        return signedRequest;
      }
    };
  }
});

// node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs20 = __commonJS({
  "node_modules/@smithy/property-provider/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CredentialsProviderError: () => CredentialsProviderError,
      ProviderError: () => ProviderError2,
      TokenProviderError: () => TokenProviderError,
      chain: () => chain,
      fromStatic: () => fromStatic,
      memoize: () => memoize
    });
    module.exports = __toCommonJS2(src_exports);
    var ProviderError2 = class _ProviderError extends Error {
      constructor(message, options = true) {
        let logger;
        let tryNextLink = true;
        if (typeof options === "boolean") {
          logger = void 0;
          tryNextLink = options;
        } else if (options != null && typeof options === "object") {
          logger = options.logger;
          tryNextLink = options.tryNextLink ?? true;
        }
        super(message);
        this.name = "ProviderError";
        this.tryNextLink = tryNextLink;
        Object.setPrototypeOf(this, _ProviderError.prototype);
        logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
      }
      static {
        __name(this, "ProviderError");
      }
      /**
       * @deprecated use new operator.
       */
      static from(error, options = true) {
        return Object.assign(new this(error.message, options), error);
      }
    };
    var CredentialsProviderError = class _CredentialsProviderError extends ProviderError2 {
      /**
       * @override
       */
      constructor(message, options = true) {
        super(message, options);
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
      }
      static {
        __name(this, "CredentialsProviderError");
      }
    };
    var TokenProviderError = class _TokenProviderError extends ProviderError2 {
      /**
       * @override
       */
      constructor(message, options = true) {
        super(message, options);
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, _TokenProviderError.prototype);
      }
      static {
        __name(this, "TokenProviderError");
      }
    };
    var chain = /* @__PURE__ */ __name((...providers) => async () => {
      if (providers.length === 0) {
        throw new ProviderError2("No providers in chain");
      }
      let lastProviderError;
      for (const provider of providers) {
        try {
          const credentials = await provider();
          return credentials;
        } catch (err) {
          lastProviderError = err;
          if (err?.tryNextLink) {
            continue;
          }
          throw err;
        }
      }
      throw lastProviderError;
    }, "chain");
    var fromStatic = /* @__PURE__ */ __name((staticValue) => () => Promise.resolve(staticValue), "fromStatic");
    var memoize = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = /* @__PURE__ */ __name(async () => {
        if (!pending) {
          pending = provider();
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      }, "coalesceProvider");
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        if (isConstant) {
          return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider();
          return resolved;
        }
        return resolved;
      };
    }, "memoize");
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js
var import_property_provider, resolveAwsSdkSigV4AConfig, NODE_SIGV4A_CONFIG_OPTIONS;
var init_resolveAwsSdkSigV4AConfig = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js"() {
    init_dist_es();
    import_property_provider = __toESM(require_dist_cjs20());
    resolveAwsSdkSigV4AConfig = (config) => {
      config.sigv4aSigningRegionSet = normalizeProvider(config.sigv4aSigningRegionSet);
      return config;
    };
    NODE_SIGV4A_CONFIG_OPTIONS = {
      environmentVariableSelector(env) {
        if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
          return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_2) => _2.trim());
        }
        throw new import_property_provider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: true
        });
      },
      configFileSelector(profile) {
        if (profile.sigv4a_signing_region_set) {
          return (profile.sigv4a_signing_region_set ?? "").split(",").map((_2) => _2.trim());
        }
        throw new import_property_provider.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: true
        });
      },
      default: void 0
    };
  }
});

// node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs21 = __commonJS({
  "node_modules/@smithy/signature-v4/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      SignatureV4: () => SignatureV42,
      clearCredentialCache: () => clearCredentialCache,
      createScope: () => createScope,
      getCanonicalHeaders: () => getCanonicalHeaders,
      getCanonicalQuery: () => getCanonicalQuery,
      getPayloadHash: () => getPayloadHash,
      getSigningKey: () => getSigningKey,
      moveHeadersToQuery: () => moveHeadersToQuery,
      prepareRequest: () => prepareRequest
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_middleware5 = require_dist_cjs6();
    var import_util_utf84 = require_dist_cjs10();
    var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    var AUTH_HEADER = "authorization";
    var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    var DATE_HEADER = "date";
    var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    var SHA256_HEADER = "x-amz-content-sha256";
    var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    var ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    var PROXY_HEADER_PATTERN = /^proxy-/;
    var SEC_HEADER_PATTERN = /^sec-/;
    var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    var MAX_CACHE_SIZE = 50;
    var KEY_TYPE_IDENTIFIER = "aws4_request";
    var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
    var import_util_hex_encoding = require_dist_cjs16();
    var import_util_utf83 = require_dist_cjs10();
    var signingKeyCache = {};
    var cacheQueue = [];
    var createScope = /* @__PURE__ */ __name((shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`, "createScope");
    var getSigningKey = /* @__PURE__ */ __name(async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${(0, import_util_hex_encoding.toHex)(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    }, "getSigningKey");
    var clearCredentialCache = /* @__PURE__ */ __name(() => {
      cacheQueue.length = 0;
      Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
      });
    }, "clearCredentialCache");
    var hmac = /* @__PURE__ */ __name((ctor, secret, data) => {
      const hash = new ctor(secret);
      hash.update((0, import_util_utf83.toUint8Array)(data));
      return hash.digest();
    }, "hmac");
    var getCanonicalHeaders = /* @__PURE__ */ __name(({ headers }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    }, "getCanonicalHeaders");
    var import_util_uri_escape = require_dist_cjs12();
    var getCanonicalQuery = /* @__PURE__ */ __name(({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query)) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        const encodedKey = (0, import_util_uri_escape.escapeUri)(key);
        keys.push(encodedKey);
        const value = query[key];
        if (typeof value === "string") {
          serialized[encodedKey] = `${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value)}`;
        } else if (Array.isArray(value)) {
          serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value2)}`]), []).sort().join("&");
        }
      }
      return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    }, "getCanonicalQuery");
    var import_is_array_buffer = require_dist_cjs8();
    var import_util_utf822 = require_dist_cjs10();
    var getPayloadHash = /* @__PURE__ */ __name(async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, import_is_array_buffer.isArrayBuffer)(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update((0, import_util_utf822.toUint8Array)(body));
        return (0, import_util_hex_encoding.toHex)(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    }, "getPayloadHash");
    var import_util_utf832 = require_dist_cjs10();
    var HeaderFormatter = class {
      static {
        __name(this, "HeaderFormatter");
      }
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = (0, import_util_utf832.fromUtf8)(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([
              header.value ? 0 : 1
              /* boolFalse */
            ]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(
              0,
              3
              /* short */
            );
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(
              0,
              4
              /* integer */
            );
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(
              0,
              6
              /* byteArray */
            );
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = (0, import_util_utf832.fromUtf8)(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(
              0,
              7
              /* string */
            );
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set((0, import_util_hex_encoding.fromHex)(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
    };
    var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    var Int64 = class _Int64 {
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static {
        __name(this, "Int64");
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i3 = 7, remaining = Math.abs(Math.round(number)); i3 > -1 && remaining > 0; i3--, remaining /= 256) {
          bytes[i3] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      /**
       * Called implicitly by infix arithmetic operators.
       */
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt((0, import_util_hex_encoding.toHex)(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
    function negate(bytes) {
      for (let i3 = 0; i3 < 8; i3++) {
        bytes[i3] ^= 255;
      }
      for (let i3 = 7; i3 > -1; i3--) {
        bytes[i3]++;
        if (bytes[i3] !== 0)
          break;
      }
    }
    __name(negate, "negate");
    var hasHeader = /* @__PURE__ */ __name((soughtHeader, headers) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    }, "hasHeader");
    var import_protocol_http11 = require_dist_cjs2();
    var moveHeadersToQuery = /* @__PURE__ */ __name((request, options = {}) => {
      const { headers, query = {} } = import_protocol_http11.HttpRequest.clone(request);
      for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
          query[name] = headers[name];
          delete headers[name];
        }
      }
      return {
        ...request,
        headers,
        query
      };
    }, "moveHeadersToQuery");
    var prepareRequest = /* @__PURE__ */ __name((request) => {
      request = import_protocol_http11.HttpRequest.clone(request);
      for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request.headers[headerName];
        }
      }
      return request;
    }, "prepareRequest");
    var iso8601 = /* @__PURE__ */ __name((time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601");
    var toDate = /* @__PURE__ */ __name((time) => {
      if (typeof time === "number") {
        return new Date(time * 1e3);
      }
      if (typeof time === "string") {
        if (Number(time)) {
          return new Date(Number(time) * 1e3);
        }
        return new Date(time);
      }
      return time;
    }, "toDate");
    var SignatureV42 = class {
      constructor({
        applyChecksum,
        credentials,
        region,
        service,
        sha256: sha2562,
        uriEscapePath = true
      }) {
        this.headerFormatter = new HeaderFormatter();
        this.service = service;
        this.sha256 = sha2562;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = (0, import_util_middleware5.normalizeProvider)(region);
        this.credentialProvider = (0, import_util_middleware5.normalizeProvider)(credentials);
      }
      static {
        __name(this, "SignatureV4");
      }
      async presign(originalRequest, options = {}) {
        const {
          signingDate = /* @__PURE__ */ new Date(),
          expiresIn = 3600,
          unsignableHeaders,
          unhoistableHeaders,
          signableHeaders,
          hoistableHeaders,
          signingRegion,
          signingService
        } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future"
          );
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
        if (credentials.sessionToken) {
          request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(
          longDate,
          scope,
          this.getSigningKey(credentials, region, shortDate, signingService),
          this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256))
        );
        return request;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else if (toSign.message) {
          return this.signMessage(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = (0, import_util_hex_encoding.toHex)(await hash.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
        const promise = this.signEvent(
          {
            headers: this.headerFormatter.format(signableMessage.message.headers),
            payload: signableMessage.message.body
          },
          {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature
          }
        );
        return promise.then((signature) => {
          return { message: signableMessage.message, signature };
        });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update((0, import_util_utf84.toUint8Array)(stringToSign));
        return (0, import_util_hex_encoding.toHex)(await hash.digest());
      }
      async signRequest(requestToSign, {
        signingDate = /* @__PURE__ */ new Date(),
        signableHeaders,
        unsignableHeaders,
        signingRegion,
        signingService
      } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
          request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(
          longDate,
          scope,
          this.getSigningKey(credentials, region, shortDate, signingService),
          this.createCanonicalRequest(request, canonicalHeaders, payloadHash)
        );
        request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request;
      }
      createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update((0, import_util_utf84.toUint8Array)(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, import_util_hex_encoding.toHex)(hashedRequest)}`;
      }
      getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = (0, import_util_uri_escape.escapeUri)(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update((0, import_util_utf84.toUint8Array)(stringToSign));
        return (0, import_util_hex_encoding.toHex)(await hash.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || // @ts-expect-error: Property 'accessKeyId' does not exist on type 'object'.ts(2339)
        typeof credentials.accessKeyId !== "string" || // @ts-expect-error: Property 'secretAccessKey' does not exist on type 'object'.ts(2339)
        typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
    };
    var formatDate = /* @__PURE__ */ __name((now) => {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    }, "formatDate");
    var getCanonicalHeaderList = /* @__PURE__ */ __name((headers) => Object.keys(headers).sort().join(";"), "getCanonicalHeaderList");
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
var import_signature_v4, resolveAwsSdkSigV4Config, resolveAWSSDKSigV4Config;
var init_resolveAwsSdkSigV4Config = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js"() {
    init_client();
    init_dist_es();
    import_signature_v4 = __toESM(require_dist_cjs21());
    resolveAwsSdkSigV4Config = (config) => {
      let isUserSupplied = false;
      let credentialsProvider;
      if (config.credentials) {
        isUserSupplied = true;
        credentialsProvider = memoizeIdentityProvider(config.credentials, isIdentityExpired, doesIdentityRequireRefresh);
      }
      if (!credentialsProvider) {
        if (config.credentialDefaultProvider) {
          credentialsProvider = normalizeProvider(config.credentialDefaultProvider(Object.assign({}, config, {
            parentClientConfig: config
          })));
        } else {
          credentialsProvider = async () => {
            throw new Error("`credentials` is missing");
          };
        }
      }
      const boundCredentialsProvider = async () => credentialsProvider({ callerClientConfig: config });
      const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256: sha2562 } = config;
      let signer;
      if (config.signer) {
        signer = normalizeProvider(config.signer);
      } else if (config.regionInfoProvider) {
        signer = () => normalizeProvider(config.region)().then(async (region) => [
          await config.regionInfoProvider(region, {
            useFipsEndpoint: await config.useFipsEndpoint(),
            useDualstackEndpoint: await config.useDualstackEndpoint()
          }) || {},
          region
        ]).then(([regionInfo, region]) => {
          const { signingRegion, signingService } = regionInfo;
          config.signingRegion = config.signingRegion || signingRegion || region;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: boundCredentialsProvider,
            region: config.signingRegion,
            service: config.signingName,
            sha256: sha2562,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
          return new SignerCtor(params);
        });
      } else {
        signer = async (authScheme) => {
          authScheme = Object.assign({}, {
            name: "sigv4",
            signingName: config.signingName || config.defaultSigningName,
            signingRegion: await normalizeProvider(config.region)(),
            properties: {}
          }, authScheme);
          const signingRegion = authScheme.signingRegion;
          const signingService = authScheme.signingName;
          config.signingRegion = config.signingRegion || signingRegion;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: boundCredentialsProvider,
            region: config.signingRegion,
            service: config.signingName,
            sha256: sha2562,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
          return new SignerCtor(params);
        };
      }
      return {
        ...config,
        systemClockOffset,
        signingEscapePath,
        credentials: isUserSupplied ? async () => boundCredentialsProvider().then((creds) => setCredentialFeature(creds, "CREDENTIALS_CODE", "e")) : boundCredentialsProvider,
        signer
      };
    };
    resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
var init_aws_sdk = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js"() {
    init_AwsSdkSigV4Signer();
    init_AwsSdkSigV4ASigner();
    init_resolveAwsSdkSigV4AConfig();
    init_resolveAwsSdkSigV4Config();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js
var init_httpAuthSchemes2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js"() {
    init_aws_sdk();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js
var _toStr, _toBool, _toNum;
var init_coercing_serializers = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js"() {
    _toStr = (val2) => {
      if (val2 == null) {
        return val2;
      }
      if (typeof val2 === "number" || typeof val2 === "bigint") {
        const warning = new Error(`Received number ${val2} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val2);
      }
      if (typeof val2 === "boolean") {
        const warning = new Error(`Received boolean ${val2} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val2);
      }
      return val2;
    };
    _toBool = (val2) => {
      if (val2 == null) {
        return val2;
      }
      if (typeof val2 === "number") {
      }
      if (typeof val2 === "string") {
        const lowercase = val2.toLowerCase();
        if (val2 !== "" && lowercase !== "false" && lowercase !== "true") {
          const warning = new Error(`Received string "${val2}" where a boolean was expected.`);
          warning.name = "Warning";
          console.warn(warning);
        }
        return val2 !== "" && lowercase !== "false";
      }
      return val2;
    };
    _toNum = (val2) => {
      if (val2 == null) {
        return val2;
      }
      if (typeof val2 === "boolean") {
      }
      if (typeof val2 === "string") {
        const num = Number(val2);
        if (num.toString() !== val2) {
          const warning = new Error(`Received string "${val2}" where a number was expected.`);
          warning.name = "Warning";
          console.warn(warning);
          return val2;
        }
        return num;
      }
      return val2;
    };
  }
});

// node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs22 = __commonJS({
  "node_modules/@smithy/middleware-stack/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      constructStack: () => constructStack
    });
    module.exports = __toCommonJS2(src_exports);
    var getAllAliases = /* @__PURE__ */ __name((name, aliases) => {
      const _aliases = [];
      if (name) {
        _aliases.push(name);
      }
      if (aliases) {
        for (const alias of aliases) {
          _aliases.push(alias);
        }
      }
      return _aliases;
    }, "getAllAliases");
    var getMiddlewareNameWithAliases = /* @__PURE__ */ __name((name, aliases) => {
      return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    }, "getMiddlewareNameWithAliases");
    var constructStack = /* @__PURE__ */ __name(() => {
      let absoluteEntries = [];
      let relativeEntries = [];
      let identifyOnResolve = false;
      const entriesNameSet = /* @__PURE__ */ new Set();
      const sort = /* @__PURE__ */ __name((entries) => entries.sort(
        (a3, b3) => stepWeights[b3.step] - stepWeights[a3.step] || priorityWeights[b3.priority || "normal"] - priorityWeights[a3.priority || "normal"]
      ), "sort");
      const removeByName = /* @__PURE__ */ __name((toRemove) => {
        let isRemoved = false;
        const filterCb = /* @__PURE__ */ __name((entry) => {
          const aliases = getAllAliases(entry.name, entry.aliases);
          if (aliases.includes(toRemove)) {
            isRemoved = true;
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        }, "filterCb");
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      }, "removeByName");
      const removeByReference = /* @__PURE__ */ __name((toRemove) => {
        let isRemoved = false;
        const filterCb = /* @__PURE__ */ __name((entry) => {
          if (entry.middleware === toRemove) {
            isRemoved = true;
            for (const alias of getAllAliases(entry.name, entry.aliases)) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        }, "filterCb");
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      }, "removeByReference");
      const cloneTo = /* @__PURE__ */ __name((toStack) => {
        absoluteEntries.forEach((entry) => {
          toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
          toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
      }, "cloneTo");
      const expandRelativeMiddlewareList = /* @__PURE__ */ __name((from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        return expandedMiddlewareList;
      }, "expandRelativeMiddlewareList");
      const getMiddlewareList = /* @__PURE__ */ __name((debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
          if (entry.toMiddleware) {
            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
            if (toMiddleware === void 0) {
              if (debug) {
                return;
              }
              throw new Error(
                `${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`
              );
            }
            if (entry.relation === "after") {
              toMiddleware.after.push(entry);
            }
            if (entry.relation === "before") {
              toMiddleware.before.push(entry);
            }
          }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce(
          (wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
          },
          []
        );
        return mainChain;
      }, "getMiddlewareList");
      const stack = {
        add: (middleware, options = {}) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            step: "initialize",
            priority: "normal",
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = absoluteEntries.findIndex(
                  (entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias)
                );
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = absoluteEntries[toOverrideIndex];
                if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                  throw new Error(
                    `"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`
                  );
                }
                absoluteEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = relativeEntries.findIndex(
                  (entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias)
                );
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = relativeEntries[toOverrideIndex];
                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                  throw new Error(
                    `"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`
                  );
                }
                relativeEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
          plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
          if (typeof toRemove === "string")
            return removeByName(toRemove);
          else
            return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
          let isRemoved = false;
          const filterCb = /* @__PURE__ */ __name((entry) => {
            const { tags, name, aliases: _aliases } = entry;
            if (tags && tags.includes(toRemove)) {
              const aliases = getAllAliases(name, _aliases);
              for (const alias of aliases) {
                entriesNameSet.delete(alias);
              }
              isRemoved = true;
              return false;
            }
            return true;
          }, "filterCb");
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        },
        concat: (from) => {
          const cloned = cloneTo(constructStack());
          cloned.use(from);
          cloned.identifyOnResolve(
            identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false)
          );
          return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
          return getMiddlewareList(true).map((mw) => {
            const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
            return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
          });
        },
        identifyOnResolve(toggle) {
          if (typeof toggle === "boolean")
            identifyOnResolve = toggle;
          return identifyOnResolve;
        },
        resolve: (handler2, context) => {
          for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
            handler2 = middleware(handler2, context);
          }
          if (identifyOnResolve) {
            console.log(stack.identify());
          }
          return handler2;
        }
      };
      return stack;
    }, "constructStack");
    var stepWeights = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    };
    var priorityWeights = {
      high: 3,
      normal: 2,
      low: 1
    };
  }
});

// node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs23 = __commonJS({
  "node_modules/@smithy/smithy-client/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Client: () => Client,
      Command: () => Command,
      LazyJsonString: () => LazyJsonString,
      NoOpLogger: () => NoOpLogger3,
      SENSITIVE_STRING: () => SENSITIVE_STRING3,
      ServiceException: () => ServiceException,
      _json: () => _json2,
      collectBody: () => import_protocols2.collectBody,
      convertMap: () => convertMap,
      createAggregatedClient: () => createAggregatedClient3,
      dateToUtcString: () => dateToUtcString,
      decorateServiceException: () => decorateServiceException,
      emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion4,
      expectBoolean: () => expectBoolean,
      expectByte: () => expectByte,
      expectFloat32: () => expectFloat32,
      expectInt: () => expectInt,
      expectInt32: () => expectInt32,
      expectLong: () => expectLong,
      expectNonNull: () => expectNonNull,
      expectNumber: () => expectNumber,
      expectObject: () => expectObject,
      expectShort: () => expectShort,
      expectString: () => expectString,
      expectUnion: () => expectUnion2,
      extendedEncodeURIComponent: () => import_protocols2.extendedEncodeURIComponent,
      getArrayIfSingleItem: () => getArrayIfSingleItem,
      getDefaultClientConfiguration: () => getDefaultClientConfiguration,
      getDefaultExtensionConfiguration: () => getDefaultExtensionConfiguration3,
      getValueFromTextNode: () => getValueFromTextNode2,
      handleFloat: () => handleFloat,
      isSerializableHeaderValue: () => isSerializableHeaderValue,
      limitedParseDouble: () => limitedParseDouble,
      limitedParseFloat: () => limitedParseFloat,
      limitedParseFloat32: () => limitedParseFloat32,
      loadConfigsForDefaultMode: () => loadConfigsForDefaultMode3,
      logger: () => logger,
      map: () => map2,
      parseBoolean: () => parseBoolean,
      parseEpochTimestamp: () => parseEpochTimestamp,
      parseRfc3339DateTime: () => parseRfc3339DateTime,
      parseRfc3339DateTimeWithOffset: () => parseRfc3339DateTimeWithOffset,
      parseRfc7231DateTime: () => parseRfc7231DateTime,
      quoteHeader: () => quoteHeader,
      resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig3,
      resolvedPath: () => import_protocols2.resolvedPath,
      serializeDateTime: () => serializeDateTime,
      serializeFloat: () => serializeFloat,
      splitEvery: () => splitEvery,
      splitHeader: () => splitHeader,
      strictParseByte: () => strictParseByte,
      strictParseDouble: () => strictParseDouble,
      strictParseFloat: () => strictParseFloat,
      strictParseFloat32: () => strictParseFloat32,
      strictParseInt: () => strictParseInt,
      strictParseInt32: () => strictParseInt32,
      strictParseLong: () => strictParseLong,
      strictParseShort: () => strictParseShort,
      take: () => take2,
      throwDefaultError: () => throwDefaultError3,
      withBaseException: () => withBaseException3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_middleware_stack = require_dist_cjs22();
    var Client = class {
      constructor(config) {
        this.config = config;
        this.middlewareStack = (0, import_middleware_stack.constructStack)();
      }
      static {
        __name(this, "Client");
      }
      send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
        let handler2;
        if (useHandlerCache) {
          if (!this.handlers) {
            this.handlers = /* @__PURE__ */ new WeakMap();
          }
          const handlers = this.handlers;
          if (handlers.has(command.constructor)) {
            handler2 = handlers.get(command.constructor);
          } else {
            handler2 = command.resolveMiddleware(this.middlewareStack, this.config, options);
            handlers.set(command.constructor, handler2);
          }
        } else {
          delete this.handlers;
          handler2 = command.resolveMiddleware(this.middlewareStack, this.config, options);
        }
        if (callback) {
          handler2(command).then(
            (result) => callback(null, result.output),
            (err) => callback(err)
          ).catch(
            // prevent any errors thrown in the callback from triggering an
            // unhandled promise rejection
            () => {
            }
          );
        } else {
          return handler2(command).then((result) => result.output);
        }
      }
      destroy() {
        this.config?.requestHandler?.destroy?.();
        delete this.handlers;
      }
    };
    var import_protocols2 = (init_protocols(), __toCommonJS(protocols_exports));
    var import_types5 = require_dist_cjs();
    var Command = class {
      constructor() {
        this.middlewareStack = (0, import_middleware_stack.constructStack)();
      }
      static {
        __name(this, "Command");
      }
      /**
       * Factory for Command ClassBuilder.
       * @internal
       */
      static classBuilder() {
        return new ClassBuilder();
      }
      /**
       * @internal
       */
      resolveMiddlewareWithContext(clientStack, configuration, options, {
        middlewareFn,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        smithyContext,
        additionalContext,
        CommandCtor
      }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
          this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger2 } = configuration;
        const handlerExecutionContext = {
          logger: logger2,
          clientName,
          commandName,
          inputFilterSensitiveLog,
          outputFilterSensitiveLog,
          [import_types5.SMITHY_CONTEXT_KEY]: {
            commandInstance: this,
            ...smithyContext
          },
          ...additionalContext
        };
        const { requestHandler } = configuration;
        return stack.resolve(
          (request) => requestHandler.handle(request.request, options || {}),
          handlerExecutionContext
        );
      }
    };
    var ClassBuilder = class {
      constructor() {
        this._init = () => {
        };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_2) => _2;
        this._outputFilterSensitiveLog = (_2) => _2;
        this._serializer = null;
        this._deserializer = null;
      }
      static {
        __name(this, "ClassBuilder");
      }
      /**
       * Optional init callback.
       */
      init(cb) {
        this._init = cb;
      }
      /**
       * Set the endpoint parameter instructions.
       */
      ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
      }
      /**
       * Add any number of middleware.
       */
      m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
      }
      /**
       * Set the initial handler execution context Smithy field.
       */
      s(service, operation, smithyContext = {}) {
        this._smithyContext = {
          service,
          operation,
          ...smithyContext
        };
        return this;
      }
      /**
       * Set the initial handler execution context.
       */
      c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
      }
      /**
       * Set constant string identifiers for the operation.
       */
      n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
      }
      /**
       * Set the input and output sensistive log filters.
       */
      f(inputFilter = (_2) => _2, outputFilter = (_2) => _2) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
      }
      /**
       * Sets the serializer.
       */
      ser(serializer) {
        this._serializer = serializer;
        return this;
      }
      /**
       * Sets the deserializer.
       */
      de(deserializer) {
        this._deserializer = deserializer;
        return this;
      }
      /**
       * @returns a Command class with the classBuilder properties.
       */
      build() {
        const closure = this;
        let CommandRef;
        return CommandRef = class extends Command {
          /**
           * @public
           */
          constructor(...[input]) {
            super();
            this.serialize = closure._serializer;
            this.deserialize = closure._deserializer;
            this.input = input ?? {};
            closure._init(this);
          }
          static {
            __name(this, "CommandRef");
          }
          /**
           * @public
           */
          static getEndpointParameterInstructions() {
            return closure._ep;
          }
          /**
           * @internal
           */
          resolveMiddleware(stack, configuration, options) {
            return this.resolveMiddlewareWithContext(stack, configuration, options, {
              CommandCtor: CommandRef,
              middlewareFn: closure._middlewareFn,
              clientName: closure._clientName,
              commandName: closure._commandName,
              inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
              outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
              smithyContext: closure._smithyContext,
              additionalContext: closure._additionalContext
            });
          }
        };
      }
    };
    var SENSITIVE_STRING3 = "***SensitiveInformation***";
    var createAggregatedClient3 = /* @__PURE__ */ __name((commands3, Client2) => {
      for (const command of Object.keys(commands3)) {
        const CommandCtor = commands3[command];
        const methodImpl = /* @__PURE__ */ __name(async function(args, optionsOrCb, cb) {
          const command2 = new CommandCtor(args);
          if (typeof optionsOrCb === "function") {
            this.send(command2, optionsOrCb);
          } else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
              throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
            this.send(command2, optionsOrCb || {}, cb);
          } else {
            return this.send(command2, optionsOrCb);
          }
        }, "methodImpl");
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client2.prototype[methodName] = methodImpl;
      }
    }, "createAggregatedClient");
    var parseBoolean = /* @__PURE__ */ __name((value) => {
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(`Unable to parse boolean value "${value}"`);
      }
    }, "parseBoolean");
    var expectBoolean = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "number") {
        if (value === 0 || value === 1) {
          logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
      }
      if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
          logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
          return false;
        }
        if (lower === "true") {
          return true;
        }
      }
      if (typeof value === "boolean") {
        return value;
      }
      throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
    }, "expectBoolean");
    var expectNumber = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          if (String(parsed) !== String(value)) {
            logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
          }
          return parsed;
        }
      }
      if (typeof value === "number") {
        return value;
      }
      throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    }, "expectNumber");
    var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    var expectFloat32 = /* @__PURE__ */ __name((value) => {
      const expected = expectNumber(value);
      if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
          throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
      }
      return expected;
    }, "expectFloat32");
    var expectLong = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
      }
      throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    }, "expectLong");
    var expectInt = expectLong;
    var expectInt32 = /* @__PURE__ */ __name((value) => expectSizedInt(value, 32), "expectInt32");
    var expectShort = /* @__PURE__ */ __name((value) => expectSizedInt(value, 16), "expectShort");
    var expectByte = /* @__PURE__ */ __name((value) => expectSizedInt(value, 8), "expectByte");
    var expectSizedInt = /* @__PURE__ */ __name((value, size) => {
      const expected = expectLong(value);
      if (expected !== void 0 && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
      }
      return expected;
    }, "expectSizedInt");
    var castInt = /* @__PURE__ */ __name((value, size) => {
      switch (size) {
        case 32:
          return Int32Array.of(value)[0];
        case 16:
          return Int16Array.of(value)[0];
        case 8:
          return Int8Array.of(value)[0];
      }
    }, "castInt");
    var expectNonNull = /* @__PURE__ */ __name((value, location) => {
      if (value === null || value === void 0) {
        if (location) {
          throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
      }
      return value;
    }, "expectNonNull");
    var expectObject = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value;
      }
      const receivedType = Array.isArray(value) ? "array" : typeof value;
      throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    }, "expectObject");
    var expectString = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        return value;
      }
      if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
      }
      throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    }, "expectString");
    var expectUnion2 = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      const asObject = expectObject(value);
      const setKeys = Object.entries(asObject).filter(([, v6]) => v6 != null).map(([k3]) => k3);
      if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
      }
      if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
      }
      return asObject;
    }, "expectUnion");
    var strictParseDouble = /* @__PURE__ */ __name((value) => {
      if (typeof value == "string") {
        return expectNumber(parseNumber(value));
      }
      return expectNumber(value);
    }, "strictParseDouble");
    var strictParseFloat = strictParseDouble;
    var strictParseFloat32 = /* @__PURE__ */ __name((value) => {
      if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
      }
      return expectFloat32(value);
    }, "strictParseFloat32");
    var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    var parseNumber = /* @__PURE__ */ __name((value) => {
      const matches = value.match(NUMBER_REGEX);
      if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
      }
      return parseFloat(value);
    }, "parseNumber");
    var limitedParseDouble = /* @__PURE__ */ __name((value) => {
      if (typeof value == "string") {
        return parseFloatString(value);
      }
      return expectNumber(value);
    }, "limitedParseDouble");
    var handleFloat = limitedParseDouble;
    var limitedParseFloat = limitedParseDouble;
    var limitedParseFloat32 = /* @__PURE__ */ __name((value) => {
      if (typeof value == "string") {
        return parseFloatString(value);
      }
      return expectFloat32(value);
    }, "limitedParseFloat32");
    var parseFloatString = /* @__PURE__ */ __name((value) => {
      switch (value) {
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error(`Unable to parse float value: ${value}`);
      }
    }, "parseFloatString");
    var strictParseLong = /* @__PURE__ */ __name((value) => {
      if (typeof value === "string") {
        return expectLong(parseNumber(value));
      }
      return expectLong(value);
    }, "strictParseLong");
    var strictParseInt = strictParseLong;
    var strictParseInt32 = /* @__PURE__ */ __name((value) => {
      if (typeof value === "string") {
        return expectInt32(parseNumber(value));
      }
      return expectInt32(value);
    }, "strictParseInt32");
    var strictParseShort = /* @__PURE__ */ __name((value) => {
      if (typeof value === "string") {
        return expectShort(parseNumber(value));
      }
      return expectShort(value);
    }, "strictParseShort");
    var strictParseByte = /* @__PURE__ */ __name((value) => {
      if (typeof value === "string") {
        return expectByte(parseNumber(value));
      }
      return expectByte(value);
    }, "strictParseByte");
    var stackTraceWarning = /* @__PURE__ */ __name((message) => {
      return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s3) => !s3.includes("stackTraceWarning")).join("\n");
    }, "stackTraceWarning");
    var logger = {
      warn: console.warn
    };
    var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function dateToUtcString(date) {
      const year = date.getUTCFullYear();
      const month = date.getUTCMonth();
      const dayOfWeek = date.getUTCDay();
      const dayOfMonthInt = date.getUTCDate();
      const hoursInt = date.getUTCHours();
      const minutesInt = date.getUTCMinutes();
      const secondsInt = date.getUTCSeconds();
      const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
      const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
      const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
      const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
      return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
    }
    __name(dateToUtcString, "dateToUtcString");
    var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    var parseRfc3339DateTime = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_2, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      const year = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    }, "parseRfc3339DateTime");
    var RFC3339_WITH_OFFSET = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/
    );
    var parseRfc3339DateTimeWithOffset = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339_WITH_OFFSET.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_2, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
      const year = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
      if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
      }
      return date;
    }, "parseRfc3339DateTimeWithOffset");
    var IMF_FIXDATE = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/
    );
    var RFC_850_DATE = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/
    );
    var ASC_TIME = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/
    );
    var parseRfc7231DateTime = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      }
      let match = IMF_FIXDATE.exec(value);
      if (match) {
        const [_2, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(
          strictParseShort(stripLeadingZeroes(yearStr)),
          parseMonthByShortName(monthStr),
          parseDateValue(dayStr, "day", 1, 31),
          { hours, minutes, seconds, fractionalMilliseconds }
        );
      }
      match = RFC_850_DATE.exec(value);
      if (match) {
        const [_2, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(
          buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
          })
        );
      }
      match = ASC_TIME.exec(value);
      if (match) {
        const [_2, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(
          strictParseShort(stripLeadingZeroes(yearStr)),
          parseMonthByShortName(monthStr),
          parseDateValue(dayStr.trimLeft(), "day", 1, 31),
          { hours, minutes, seconds, fractionalMilliseconds }
        );
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    }, "parseRfc7231DateTime");
    var parseEpochTimestamp = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      let valueAsDouble;
      if (typeof value === "number") {
        valueAsDouble = value;
      } else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
      } else if (typeof value === "object" && value.tag === 1) {
        valueAsDouble = value.value;
      } else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      }
      if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      }
      return new Date(Math.round(valueAsDouble * 1e3));
    }, "parseEpochTimestamp");
    var buildDate = /* @__PURE__ */ __name((year, month, day, time) => {
      const adjustedMonth = month - 1;
      validateDayOfMonth(year, adjustedMonth, day);
      return new Date(
        Date.UTC(
          year,
          adjustedMonth,
          day,
          parseDateValue(time.hours, "hour", 0, 23),
          parseDateValue(time.minutes, "minute", 0, 59),
          // seconds can go up to 60 for leap seconds
          parseDateValue(time.seconds, "seconds", 0, 60),
          parseMilliseconds(time.fractionalMilliseconds)
        )
      );
    }, "buildDate");
    var parseTwoDigitYear = /* @__PURE__ */ __name((value) => {
      const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
      const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
      if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
      }
      return valueInThisCentury;
    }, "parseTwoDigitYear");
    var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
    var adjustRfc850Year = /* @__PURE__ */ __name((input) => {
      if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(
          Date.UTC(
            input.getUTCFullYear() - 100,
            input.getUTCMonth(),
            input.getUTCDate(),
            input.getUTCHours(),
            input.getUTCMinutes(),
            input.getUTCSeconds(),
            input.getUTCMilliseconds()
          )
        );
      }
      return input;
    }, "adjustRfc850Year");
    var parseMonthByShortName = /* @__PURE__ */ __name((value) => {
      const monthIdx = MONTHS.indexOf(value);
      if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
      }
      return monthIdx + 1;
    }, "parseMonthByShortName");
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var validateDayOfMonth = /* @__PURE__ */ __name((year, month, day) => {
      let maxDays = DAYS_IN_MONTH[month];
      if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
      }
      if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
      }
    }, "validateDayOfMonth");
    var isLeapYear = /* @__PURE__ */ __name((year) => {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }, "isLeapYear");
    var parseDateValue = /* @__PURE__ */ __name((value, type, lower, upper) => {
      const dateVal = strictParseByte(stripLeadingZeroes(value));
      if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
      }
      return dateVal;
    }, "parseDateValue");
    var parseMilliseconds = /* @__PURE__ */ __name((value) => {
      if (value === null || value === void 0) {
        return 0;
      }
      return strictParseFloat32("0." + value) * 1e3;
    }, "parseMilliseconds");
    var parseOffsetToMilliseconds = /* @__PURE__ */ __name((value) => {
      const directionStr = value[0];
      let direction = 1;
      if (directionStr == "+") {
        direction = 1;
      } else if (directionStr == "-") {
        direction = -1;
      } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
      }
      const hour = Number(value.substring(1, 3));
      const minute = Number(value.substring(4, 6));
      return direction * (hour * 60 + minute) * 60 * 1e3;
    }, "parseOffsetToMilliseconds");
    var stripLeadingZeroes = /* @__PURE__ */ __name((value) => {
      let idx = 0;
      while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
      }
      if (idx === 0) {
        return value;
      }
      return value.slice(idx);
    }, "stripLeadingZeroes");
    var ServiceException = class _ServiceException extends Error {
      static {
        __name(this, "ServiceException");
      }
      constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
      }
      /**
       * Checks if a value is an instance of ServiceException (duck typed)
       */
      static isInstance(value) {
        if (!value)
          return false;
        const candidate = value;
        return _ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
      }
      /**
       * Custom instanceof check to support the operator for ServiceException base class
       */
      static [Symbol.hasInstance](instance) {
        if (!instance)
          return false;
        const candidate = instance;
        if (this === _ServiceException) {
          return _ServiceException.isInstance(instance);
        }
        if (_ServiceException.isInstance(instance)) {
          if (candidate.name && this.name) {
            return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
          }
          return this.prototype.isPrototypeOf(instance);
        }
        return false;
      }
    };
    var decorateServiceException = /* @__PURE__ */ __name((exception, additions = {}) => {
      Object.entries(additions).filter(([, v6]) => v6 !== void 0).forEach(([k3, v6]) => {
        if (exception[k3] == void 0 || exception[k3] === "") {
          exception[k3] = v6;
        }
      });
      const message = exception.message || exception.Message || "UnknownError";
      exception.message = message;
      delete exception.Message;
      return exception;
    }, "decorateServiceException");
    var throwDefaultError3 = /* @__PURE__ */ __name(({ output, parsedBody, exceptionCtor, errorCode }) => {
      const $metadata = deserializeMetadata3(output);
      const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
      const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
      });
      throw decorateServiceException(response, parsedBody);
    }, "throwDefaultError");
    var withBaseException3 = /* @__PURE__ */ __name((ExceptionCtor) => {
      return ({ output, parsedBody, errorCode }) => {
        throwDefaultError3({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
      };
    }, "withBaseException");
    var deserializeMetadata3 = /* @__PURE__ */ __name((output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    }), "deserializeMetadata");
    var loadConfigsForDefaultMode3 = /* @__PURE__ */ __name((mode) => {
      switch (mode) {
        case "standard":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard",
            connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard",
            connectionTimeout: 3e4
          };
        default:
          return {};
      }
    }, "loadConfigsForDefaultMode");
    var warningEmitted = false;
    var emitWarningIfUnsupportedVersion4 = /* @__PURE__ */ __name((version3) => {
      if (version3 && !warningEmitted && parseInt(version3.substring(1, version3.indexOf("."))) < 16) {
        warningEmitted = true;
      }
    }, "emitWarningIfUnsupportedVersion");
    var getChecksumConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
      const checksumAlgorithms = [];
      for (const id in import_types5.AlgorithmId) {
        const algorithmId = import_types5.AlgorithmId[id];
        if (runtimeConfig[algorithmId] === void 0) {
          continue;
        }
        checksumAlgorithms.push({
          algorithmId: () => algorithmId,
          checksumConstructor: () => runtimeConfig[algorithmId]
        });
      }
      return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
          this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms;
        }
      };
    }, "getChecksumConfiguration");
    var resolveChecksumRuntimeConfig = /* @__PURE__ */ __name((clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    }, "resolveChecksumRuntimeConfig");
    var getRetryConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
      let _retryStrategy = runtimeConfig.retryStrategy;
      return {
        setRetryStrategy(retryStrategy) {
          _retryStrategy = retryStrategy;
        },
        retryStrategy() {
          return _retryStrategy;
        }
      };
    }, "getRetryConfiguration");
    var resolveRetryRuntimeConfig = /* @__PURE__ */ __name((retryStrategyConfiguration) => {
      const runtimeConfig = {};
      runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
      return runtimeConfig;
    }, "resolveRetryRuntimeConfig");
    var getDefaultExtensionConfiguration3 = /* @__PURE__ */ __name((runtimeConfig) => {
      return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig)
      };
    }, "getDefaultExtensionConfiguration");
    var getDefaultClientConfiguration = getDefaultExtensionConfiguration3;
    var resolveDefaultRuntimeConfig3 = /* @__PURE__ */ __name((config) => {
      return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config)
      };
    }, "resolveDefaultRuntimeConfig");
    var getArrayIfSingleItem = /* @__PURE__ */ __name((mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray], "getArrayIfSingleItem");
    var getValueFromTextNode2 = /* @__PURE__ */ __name((obj) => {
      const textNodeName = "#text";
      for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
          obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          obj[key] = getValueFromTextNode2(obj[key]);
        }
      }
      return obj;
    }, "getValueFromTextNode");
    var isSerializableHeaderValue = /* @__PURE__ */ __name((value) => {
      return value != null;
    }, "isSerializableHeaderValue");
    var LazyJsonString = /* @__PURE__ */ __name(function LazyJsonString2(val2) {
      const str = Object.assign(new String(val2), {
        deserializeJSON() {
          return JSON.parse(String(val2));
        },
        toString() {
          return String(val2);
        },
        toJSON() {
          return String(val2);
        }
      });
      return str;
    }, "LazyJsonString");
    LazyJsonString.from = (object) => {
      if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) {
        return object;
      } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
        return LazyJsonString(String(object));
      }
      return LazyJsonString(JSON.stringify(object));
    };
    LazyJsonString.fromObject = LazyJsonString.from;
    var NoOpLogger3 = class {
      static {
        __name(this, "NoOpLogger");
      }
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
    function map2(arg0, arg1, arg2) {
      let target;
      let filter;
      let instructions;
      if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
      } else {
        target = arg0;
        if (typeof arg1 === "function") {
          filter = arg1;
          instructions = arg2;
          return mapWithFilter(target, filter, instructions);
        } else {
          instructions = arg1;
        }
      }
      for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
          target[key] = instructions[key];
          continue;
        }
        applyInstruction(target, null, instructions, key);
      }
      return target;
    }
    __name(map2, "map");
    var convertMap = /* @__PURE__ */ __name((target) => {
      const output = {};
      for (const [k3, v6] of Object.entries(target || {})) {
        output[k3] = [, v6];
      }
      return output;
    }, "convertMap");
    var take2 = /* @__PURE__ */ __name((source, instructions) => {
      const out = {};
      for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
      }
      return out;
    }, "take");
    var mapWithFilter = /* @__PURE__ */ __name((target, filter, instructions) => {
      return map2(
        target,
        Object.entries(instructions).reduce(
          (_instructions, [key, value]) => {
            if (Array.isArray(value)) {
              _instructions[key] = value;
            } else {
              if (typeof value === "function") {
                _instructions[key] = [filter, value()];
              } else {
                _instructions[key] = [filter, value];
              }
            }
            return _instructions;
          },
          {}
        )
      );
    }, "mapWithFilter");
    var applyInstruction = /* @__PURE__ */ __name((target, source, instructions, targetKey) => {
      if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
          instruction = [, instruction];
        }
        const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
          target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
      }
      let [filter, value] = instructions[targetKey];
      if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
        const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed) {
          target[targetKey] = _value;
        } else if (customFilterPassed) {
          target[targetKey] = value();
        }
      } else {
        const defaultFilterPassed = filter === void 0 && value != null;
        const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed || customFilterPassed) {
          target[targetKey] = value;
        }
      }
    }, "applyInstruction");
    var nonNullish = /* @__PURE__ */ __name((_2) => _2 != null, "nonNullish");
    var pass = /* @__PURE__ */ __name((_2) => _2, "pass");
    function quoteHeader(part) {
      if (part.includes(",") || part.includes('"')) {
        part = `"${part.replace(/"/g, '\\"')}"`;
      }
      return part;
    }
    __name(quoteHeader, "quoteHeader");
    var serializeFloat = /* @__PURE__ */ __name((value) => {
      if (value !== value) {
        return "NaN";
      }
      switch (value) {
        case Infinity:
          return "Infinity";
        case -Infinity:
          return "-Infinity";
        default:
          return value;
      }
    }, "serializeFloat");
    var serializeDateTime = /* @__PURE__ */ __name((date) => date.toISOString().replace(".000Z", "Z"), "serializeDateTime");
    var _json2 = /* @__PURE__ */ __name((obj) => {
      if (obj == null) {
        return {};
      }
      if (Array.isArray(obj)) {
        return obj.filter((_2) => _2 != null).map(_json2);
      }
      if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
          if (obj[key] == null) {
            continue;
          }
          target[key] = _json2(obj[key]);
        }
        return target;
      }
      return obj;
    }, "_json");
    function splitEvery(value, delimiter, numDelimiters) {
      if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
      }
      const segments = value.split(delimiter);
      if (numDelimiters === 1) {
        return segments;
      }
      const compoundSegments = [];
      let currentSegment = "";
      for (let i3 = 0; i3 < segments.length; i3++) {
        if (currentSegment === "") {
          currentSegment = segments[i3];
        } else {
          currentSegment += delimiter + segments[i3];
        }
        if ((i3 + 1) % numDelimiters === 0) {
          compoundSegments.push(currentSegment);
          currentSegment = "";
        }
      }
      if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
      }
      return compoundSegments;
    }
    __name(splitEvery, "splitEvery");
    var splitHeader = /* @__PURE__ */ __name((value) => {
      const z3 = value.length;
      const values = [];
      let withinQuotes = false;
      let prevChar = void 0;
      let anchor = 0;
      for (let i3 = 0; i3 < z3; ++i3) {
        const char = value[i3];
        switch (char) {
          case `"`:
            if (prevChar !== "\\") {
              withinQuotes = !withinQuotes;
            }
            break;
          case ",":
            if (!withinQuotes) {
              values.push(value.slice(anchor, i3));
              anchor = i3 + 1;
            }
            break;
          default:
        }
        prevChar = char;
      }
      values.push(value.slice(anchor));
      return values.map((v6) => {
        v6 = v6.trim();
        const z22 = v6.length;
        if (z22 < 2) {
          return v6;
        }
        if (v6[0] === `"` && v6[z22 - 1] === `"`) {
          v6 = v6.slice(1, z22 - 1);
        }
        return v6.replace(/\\"/g, '"');
      });
    }, "splitHeader");
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js
var import_smithy_client, awsExpectUnion;
var init_awsExpectUnion = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js"() {
    import_smithy_client = __toESM(require_dist_cjs23());
    awsExpectUnion = (value) => {
      if (value == null) {
        return void 0;
      }
      if (typeof value === "object" && "__type" in value) {
        delete value.__type;
      }
      return (0, import_smithy_client.expectUnion)(value);
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
var import_smithy_client2, collectBodyString;
var init_common = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js"() {
    import_smithy_client2 = __toESM(require_dist_cjs23());
    collectBodyString = (streamBody, context) => (0, import_smithy_client2.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js
var parseJsonBody, parseJsonErrorBody, loadRestJsonErrorCode;
var init_parseJsonBody = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js"() {
    init_common();
    parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        try {
          return JSON.parse(encoded);
        } catch (e3) {
          if (e3?.name === "SyntaxError") {
            Object.defineProperty(e3, "$responseBodyText", {
              value: encoded
            });
          }
          throw e3;
        }
      }
      return {};
    });
    parseJsonErrorBody = async (errorBody, context) => {
      const value = await parseJsonBody(errorBody, context);
      value.message = value.message ?? value.Message;
      return value;
    };
    loadRestJsonErrorCode = (output, data) => {
      const findKey = (object, key) => Object.keys(object).find((k3) => k3.toLowerCase() === key.toLowerCase());
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      const headerKey = findKey(output.headers, "x-amzn-errortype");
      if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
      }
      if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
      }
      if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
      }
    };
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v6) {
      return typeof v6 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a3, arrayMode) {
      if (a3) {
        const keys = Object.keys(a3);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          if (arrayMode === "strict") {
            target[keys[i3]] = [a3[keys[i3]]];
          } else {
            target[keys[i3]] = a3[keys[i3]];
          }
        }
      }
    };
    exports.getValue = function(v6) {
      if (exports.isExist(v6)) {
        return v6;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator2 = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util2 = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
          i3 += 2;
          i3 = readPI(xmlData, i3);
          if (i3.err) return i3;
        } else if (xmlData[i3] === "<") {
          let tagStartPos = i3;
          i3++;
          if (xmlData[i3] === "!") {
            i3 = readCommentAndCDATA(xmlData, i3);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i3] === "/") {
              closingTag = true;
              i3++;
            }
            let tagName = "";
            for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
              tagName += xmlData[i3];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i3--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
            }
            const result = readAttributeStr(xmlData, i3);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
            }
            let attrStr = result.value;
            i3 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i3 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else if (tags.length === 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 !== true) {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid2.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i3++; i3 < xmlData.length; i3++) {
              if (xmlData[i3] === "<") {
                if (xmlData[i3 + 1] === "!") {
                  i3++;
                  i3 = readCommentAndCDATA(xmlData, i3);
                  continue;
                } else if (xmlData[i3 + 1] === "?") {
                  i3 = readPI(xmlData, ++i3);
                  if (i3.err) return i3;
                } else {
                  break;
                }
              } else if (xmlData[i3] === "&") {
                const afterAmp = validateAmpersand(xmlData, i3);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                i3 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                }
              }
            }
            if (xmlData[i3] === "<") {
              i3--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i3])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i3) {
      const start = i3;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] == "?" || xmlData[i3] == " ") {
          const tagname = xmlData.substr(start, i3 - start);
          if (i3 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
          } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
            i3++;
            break;
          } else {
            continue;
          }
        }
      }
      return i3;
    }
    function readCommentAndCDATA(xmlData, i3) {
      if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
        for (i3 += 3; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i3] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      }
      return i3;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i3) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i3];
          } else if (startChar !== xmlData[i3]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i3] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i3];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i3,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util2.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i3 = 0; i3 < matches.length; i3++) {
        if (matches[i3][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] !== void 0 && matches[i3][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
        }
        const attrName = matches[i3][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i3) {
      let re = /\d/;
      if (xmlData[i3] === "x") {
        i3++;
        re = /[\da-fA-F]/;
      }
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === ";")
          return i3;
        if (!xmlData[i3].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i3) {
      i3++;
      if (xmlData[i3] === ";")
        return -1;
      if (xmlData[i3] === "#") {
        i3++;
        return validateNumberAmpersand(xmlData, i3);
      }
      let count = 0;
      for (; i3 < xmlData.length; i3++, count++) {
        if (xmlData[i3].match(/\w/) && count < 20)
          continue;
        if (xmlData[i3] === ";")
          break;
        return -1;
      }
      return i3;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util2.isName(attrName);
    }
    function validateTagName(tagname) {
      return util2.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    var util2 = require_util();
    function readDocType(xmlData, i3) {
      const entities = {};
      if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
        i3 = i3 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i3)) {
              i3 += 7;
              [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i3)) i3 += 8;
            else if (hasBody && isAttlist(xmlData, i3)) i3 += 8;
            else if (hasBody && isNotation(xmlData, i3)) i3 += 9;
            else if (isComment) comment = true;
            else throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i3] === ">") {
            if (comment) {
              if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i3] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i3];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i3 };
    }
    function readEntityExp(xmlData, i3) {
      let entityName2 = "";
      for (; i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
        entityName2 += xmlData[i3];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1) throw new Error("External entites are not supported");
      const startChar = xmlData[i3++];
      let val2 = "";
      for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
        val2 += xmlData[i3];
      }
      return [entityName2, val2, i3];
    }
    function isComment(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-") return true;
      return false;
    }
    function isEntity(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y") return true;
      return false;
    }
    function isElement(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T") return true;
      return false;
    }
    function isAttlist(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T") return true;
      return false;
    }
    function isNotation(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N") return true;
      return false;
    }
    function validateEntityName(name) {
      if (util2.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    var consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string") return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
      else if (str === "0") return 0;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
      } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
        if (notation) {
          if (options.leadingZeros) {
            trimmedStr = (notation[1] || "") + notation[3];
          } else {
            if (notation[2] === "0" && notation[3][0] === ".") {
            } else {
              return str;
            }
          }
          return options.eNotation ? Number(trimmedStr) : str;
        } else {
          return str;
        }
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str;
          else if (options.leadingZeros && leadingZeros === str) return 0;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation) return num;
              else return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "") return num;
              else if (numStr === numTrimmedByZeros) return num;
              else if (sign && numStr === "-" + numTrimmedByZeros) return num;
              else return str;
            }
            if (leadingZeros) {
              return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;
            } else {
              return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;
            }
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    function parse_int(numStr, base) {
      if (parseInt) return parseInt(numStr, base);
      else if (Number.parseInt) return Number.parseInt(numStr, base);
      else if (window && window.parseInt) return window.parseInt(numStr, base);
      else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
    }
    module.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util2 = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i3 = 0; i3 < entKeys.length; i3++) {
        const ent = entKeys[i3];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities) val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util2.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i3 = 0; i3 < len; i3++) {
          const attrName = this.resolveNameSpace(matches[i3][1]);
          let oldVal = matches[i3][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__") aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        const ch = xmlData[i3];
        if (ch === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            let tagData = readTagExp(xmlData, i3, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i3 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i3 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i3 = endIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i3);
            this.docTypeEntities = result.entities;
            i3 = result.i;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i3 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val2 == void 0) val2 = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val2);
            }
            i3 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i3 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i3 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
                i3 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i3 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i3];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0) isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i3; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary) attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i3, errMsg) {
      const closingIndex = xmlData.indexOf(str, i3);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i3) {
      const startIndex = i3;
      let openTagCount = 1;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i3),
                  i: closeIndex
                };
              }
            }
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
            i3 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i3, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i3 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true") return true;
        else if (newval === "false") return false;
        else return toNumber(val2, options);
      } else {
        if (util2.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0) newJpath = property;
        else newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0) text = tagObj[property];
          else text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode) val2[options.textNodeName] = "";
            else val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0) compressedObj[options.textNodeName] = text;
      } else if (text !== void 0) compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@") return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          const atrrName = keys[i3];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator2 = require_validator2();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {};
          const result = validator2.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
        else return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser2;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const tagName = propName(tagObj);
        if (tagName === void 0) continue;
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
          else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr)) continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i3 = 0; i3 < options.entities.length; i3++) {
          const entity = options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a3) {
        return a3;
      },
      attributeValueProcessor: function(attrName, a3) {
        return a3;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val2 += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val2 += "";
          } else if (key[0] === "?") {
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j3 = 0; j3 < arrLen; j3++) {
            const item = jObj[key][j3];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?") val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result = this.j2x(item, level + 1);
                listTagVal += result.val;
                if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                  listTagAttr += result.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j3 = 0; j3 < L; j3++) {
              attrStr += this.buildAttrPairStr(Ks[j3], "" + jObj[key][Ks[j3]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?") return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode) closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i3 = 0; i3 < this.options.entities.length; i3++) {
          const entity = this.options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator2 = require_validator2();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator2,
      XMLBuilder
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
var import_smithy_client3, import_fast_xml_parser, parseXmlBody, parseXmlErrorBody, loadRestXmlErrorCode;
var init_parseXmlBody = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js"() {
    import_smithy_client3 = __toESM(require_dist_cjs23());
    import_fast_xml_parser = __toESM(require_fxp());
    init_common();
    parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        const parser = new import_fast_xml_parser.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: true,
          ignoreAttributes: false,
          ignoreDeclaration: true,
          parseTagValue: false,
          trimValues: false,
          tagValueProcessor: (_2, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        let parsedObj;
        try {
          parsedObj = parser.parse(encoded, true);
        } catch (e3) {
          if (e3 && typeof e3 === "object") {
            Object.defineProperty(e3, "$responseBodyText", {
              value: encoded
            });
          }
          throw e3;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return (0, import_smithy_client3.getValueFromTextNode)(parsedObjToReturn);
      }
      return {};
    });
    parseXmlErrorBody = async (errorBody, context) => {
      const value = await parseXmlBody(errorBody, context);
      if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
      }
      return value;
    };
    loadRestXmlErrorCode = (output, data) => {
      if (data?.Error?.Code !== void 0) {
        return data.Error.Code;
      }
      if (data?.Code !== void 0) {
        return data.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js
var init_protocols2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js"() {
    init_coercing_serializers();
    init_awsExpectUnion();
    init_parseJsonBody();
    init_parseXmlBody();
  }
});

// node_modules/@aws-sdk/core/dist-es/index.js
var dist_es_exports2 = {};
__export(dist_es_exports2, {
  AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
  AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
  AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
  NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
  _toBool: () => _toBool,
  _toNum: () => _toNum,
  _toStr: () => _toStr,
  awsExpectUnion: () => awsExpectUnion,
  emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
  loadRestJsonErrorCode: () => loadRestJsonErrorCode,
  loadRestXmlErrorCode: () => loadRestXmlErrorCode,
  parseJsonBody: () => parseJsonBody,
  parseJsonErrorBody: () => parseJsonErrorBody,
  parseXmlBody: () => parseXmlBody,
  parseXmlErrorBody: () => parseXmlErrorBody,
  resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
  resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
  resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
  setCredentialFeature: () => setCredentialFeature,
  setFeature: () => setFeature2,
  state: () => state,
  validateSigningProperties: () => validateSigningProperties
});
var init_dist_es2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/index.js"() {
    init_client();
    init_httpAuthSchemes2();
    init_protocols2();
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs24 = __commonJS({
  "node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      DEFAULT_UA_APP_ID: () => DEFAULT_UA_APP_ID,
      getUserAgentMiddlewareOptions: () => getUserAgentMiddlewareOptions,
      getUserAgentPlugin: () => getUserAgentPlugin3,
      resolveUserAgentConfig: () => resolveUserAgentConfig3,
      userAgentMiddleware: () => userAgentMiddleware
    });
    module.exports = __toCommonJS2(src_exports);
    var import_core17 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var DEFAULT_UA_APP_ID = void 0;
    function isValidUserAgentAppId(appId) {
      if (appId === void 0) {
        return true;
      }
      return typeof appId === "string" && appId.length <= 50;
    }
    __name(isValidUserAgentAppId, "isValidUserAgentAppId");
    function resolveUserAgentConfig3(input) {
      const normalizedAppIdProvider = (0, import_core17.normalizeProvider)(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
      return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        userAgentAppId: async () => {
          const appId = await normalizedAppIdProvider();
          if (!isValidUserAgentAppId(appId)) {
            const logger = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
            if (typeof appId !== "string") {
              logger?.warn("userAgentAppId must be a string or undefined.");
            } else if (appId.length > 50) {
              logger?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
            }
          }
          return appId;
        }
      };
    }
    __name(resolveUserAgentConfig3, "resolveUserAgentConfig");
    var import_util_endpoints5 = require_dist_cjs19();
    var import_protocol_http11 = require_dist_cjs2();
    var import_core22 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
    async function checkFeatures(context, config, args) {
      const request = args.request;
      if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
        (0, import_core22.setFeature)(context, "PROTOCOL_RPC_V2_CBOR", "M");
      }
      if (typeof config.retryStrategy === "function") {
        const retryStrategy = await config.retryStrategy();
        if (typeof retryStrategy.acquireInitialRetryToken === "function") {
          if (retryStrategy.constructor?.name?.includes("Adaptive")) {
            (0, import_core22.setFeature)(context, "RETRY_MODE_ADAPTIVE", "F");
          } else {
            (0, import_core22.setFeature)(context, "RETRY_MODE_STANDARD", "E");
          }
        } else {
          (0, import_core22.setFeature)(context, "RETRY_MODE_LEGACY", "D");
        }
      }
      if (typeof config.accountIdEndpointMode === "function") {
        const endpointV2 = context.endpointV2;
        if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
          (0, import_core22.setFeature)(context, "ACCOUNT_ID_ENDPOINT", "O");
        }
        switch (await config.accountIdEndpointMode?.()) {
          case "disabled":
            (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
            break;
          case "preferred":
            (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
            break;
          case "required":
            (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
            break;
        }
      }
      const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
      if (identity?.$source) {
        const credentials = identity;
        if (credentials.accountId) {
          (0, import_core22.setFeature)(context, "RESOLVED_ACCOUNT_ID", "T");
        }
        for (const [key, value] of Object.entries(credentials.$source ?? {})) {
          (0, import_core22.setFeature)(context, key, value);
        }
      }
    }
    __name(checkFeatures, "checkFeatures");
    var USER_AGENT = "user-agent";
    var X_AMZ_USER_AGENT = "x-amz-user-agent";
    var SPACE = " ";
    var UA_NAME_SEPARATOR = "/";
    var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    var UA_ESCAPE_CHAR = "-";
    var BYTE_LIMIT = 1024;
    function encodeFeatures(features) {
      let buffer = "";
      for (const key in features) {
        const val2 = features[key];
        if (buffer.length + val2.length + 1 <= BYTE_LIMIT) {
          if (buffer.length) {
            buffer += "," + val2;
          } else {
            buffer += val2;
          }
          continue;
        }
        break;
      }
      return buffer;
    }
    __name(encodeFeatures, "encodeFeatures");
    var userAgentMiddleware = /* @__PURE__ */ __name((options) => (next, context) => async (args) => {
      const { request } = args;
      if (!import_protocol_http11.HttpRequest.isInstance(request)) {
        return next(args);
      }
      const { headers } = request;
      const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
      const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
      await checkFeatures(context, options, args);
      const awsContext = context;
      defaultUserAgent.push(
        `m/${encodeFeatures(
          Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features)
        )}`
      );
      const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
      const appId = await options.userAgentAppId();
      if (appId) {
        defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
      }
      const prefix = (0, import_util_endpoints5.getUserAgentPrefix)();
      const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
      const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent
      ].join(SPACE);
      if (options.runtime !== "browser") {
        if (normalUAValue) {
          headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
      } else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
      }
      return next({
        ...args,
        request
      });
    }, "userAgentMiddleware");
    var escapeUserAgent = /* @__PURE__ */ __name((userAgentPair) => {
      const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
      const version3 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
      const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
      const prefix = name.substring(0, prefixSeparatorIndex);
      let uaName = name.substring(prefixSeparatorIndex + 1);
      if (prefix === "api") {
        uaName = uaName.toLowerCase();
      }
      return [prefix, uaName, version3].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
        switch (index) {
          case 0:
            return item;
          case 1:
            return `${acc}/${item}`;
          default:
            return `${acc}#${item}`;
        }
      }, "");
    }, "escapeUserAgent");
    var getUserAgentMiddlewareOptions = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: true
    };
    var getUserAgentPlugin3 = /* @__PURE__ */ __name((config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
      }
    }), "getUserAgentPlugin");
  }
});

// node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs25 = __commonJS({
  "node_modules/@smithy/util-config-provider/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      SelectorType: () => SelectorType,
      booleanSelector: () => booleanSelector,
      numberSelector: () => numberSelector
    });
    module.exports = __toCommonJS2(src_exports);
    var booleanSelector = /* @__PURE__ */ __name((obj, key, type) => {
      if (!(key in obj))
        return void 0;
      if (obj[key] === "true")
        return true;
      if (obj[key] === "false")
        return false;
      throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
    }, "booleanSelector");
    var numberSelector = /* @__PURE__ */ __name((obj, key, type) => {
      if (!(key in obj))
        return void 0;
      const numberValue = parseInt(obj[key], 10);
      if (Number.isNaN(numberValue)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
      }
      return numberValue;
    }, "numberSelector");
    var SelectorType = /* @__PURE__ */ ((SelectorType2) => {
      SelectorType2["ENV"] = "env";
      SelectorType2["CONFIG"] = "shared config entry";
      return SelectorType2;
    })(SelectorType || {});
  }
});

// node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs26 = __commonJS({
  "node_modules/@smithy/config-resolver/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CONFIG_USE_DUALSTACK_ENDPOINT: () => CONFIG_USE_DUALSTACK_ENDPOINT,
      CONFIG_USE_FIPS_ENDPOINT: () => CONFIG_USE_FIPS_ENDPOINT,
      DEFAULT_USE_DUALSTACK_ENDPOINT: () => DEFAULT_USE_DUALSTACK_ENDPOINT,
      DEFAULT_USE_FIPS_ENDPOINT: () => DEFAULT_USE_FIPS_ENDPOINT,
      ENV_USE_DUALSTACK_ENDPOINT: () => ENV_USE_DUALSTACK_ENDPOINT,
      ENV_USE_FIPS_ENDPOINT: () => ENV_USE_FIPS_ENDPOINT,
      NODE_REGION_CONFIG_FILE_OPTIONS: () => NODE_REGION_CONFIG_FILE_OPTIONS3,
      NODE_REGION_CONFIG_OPTIONS: () => NODE_REGION_CONFIG_OPTIONS3,
      NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS3,
      NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS3,
      REGION_ENV_NAME: () => REGION_ENV_NAME,
      REGION_INI_NAME: () => REGION_INI_NAME,
      getRegionInfo: () => getRegionInfo,
      resolveCustomEndpointsConfig: () => resolveCustomEndpointsConfig,
      resolveEndpointsConfig: () => resolveEndpointsConfig,
      resolveRegionConfig: () => resolveRegionConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_config_provider = require_dist_cjs25();
    var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
    var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
    var DEFAULT_USE_DUALSTACK_ENDPOINT = false;
    var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => (0, import_util_config_provider.booleanSelector)(env, ENV_USE_DUALSTACK_ENDPOINT, import_util_config_provider.SelectorType.ENV),
      configFileSelector: (profile) => (0, import_util_config_provider.booleanSelector)(profile, CONFIG_USE_DUALSTACK_ENDPOINT, import_util_config_provider.SelectorType.CONFIG),
      default: false
    };
    var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
    var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
    var DEFAULT_USE_FIPS_ENDPOINT = false;
    var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => (0, import_util_config_provider.booleanSelector)(env, ENV_USE_FIPS_ENDPOINT, import_util_config_provider.SelectorType.ENV),
      configFileSelector: (profile) => (0, import_util_config_provider.booleanSelector)(profile, CONFIG_USE_FIPS_ENDPOINT, import_util_config_provider.SelectorType.CONFIG),
      default: false
    };
    var import_util_middleware5 = require_dist_cjs6();
    var resolveCustomEndpointsConfig = /* @__PURE__ */ __name((input) => {
      const { endpoint, urlParser } = input;
      return {
        ...input,
        tls: input.tls ?? true,
        endpoint: (0, import_util_middleware5.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: (0, import_util_middleware5.normalizeProvider)(input.useDualstackEndpoint ?? false)
      };
    }, "resolveCustomEndpointsConfig");
    var getEndpointFromRegion = /* @__PURE__ */ __name(async (input) => {
      const { tls = true } = input;
      const region = await input.region();
      const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
      if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
      }
      const useDualstackEndpoint = await input.useDualstackEndpoint();
      const useFipsEndpoint = await input.useFipsEndpoint();
      const { hostname } = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }) ?? {};
      if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
      }
      return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
    }, "getEndpointFromRegion");
    var resolveEndpointsConfig = /* @__PURE__ */ __name((input) => {
      const useDualstackEndpoint = (0, import_util_middleware5.normalizeProvider)(input.useDualstackEndpoint ?? false);
      const { endpoint, useFipsEndpoint, urlParser } = input;
      return {
        ...input,
        tls: input.tls ?? true,
        endpoint: endpoint ? (0, import_util_middleware5.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint
      };
    }, "resolveEndpointsConfig");
    var REGION_ENV_NAME = "AWS_REGION";
    var REGION_INI_NAME = "region";
    var NODE_REGION_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => env[REGION_ENV_NAME],
      configFileSelector: (profile) => profile[REGION_INI_NAME],
      default: () => {
        throw new Error("Region is missing");
      }
    };
    var NODE_REGION_CONFIG_FILE_OPTIONS3 = {
      preferredFile: "credentials"
    };
    var isFipsRegion = /* @__PURE__ */ __name((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");
    var getRealRegion = /* @__PURE__ */ __name((region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");
    var resolveRegionConfig3 = /* @__PURE__ */ __name((input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return {
        ...input,
        region: async () => {
          if (typeof region === "string") {
            return getRealRegion(region);
          }
          const providedRegion = await region();
          return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      };
    }, "resolveRegionConfig");
    var getHostnameFromVariants = /* @__PURE__ */ __name((variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(
      ({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack")
    )?.hostname, "getHostnameFromVariants");
    var getResolvedHostname = /* @__PURE__ */ __name((resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : void 0, "getResolvedHostname");
    var getResolvedPartition = /* @__PURE__ */ __name((region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws", "getResolvedPartition");
    var getResolvedSigningRegion = /* @__PURE__ */ __name((hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
      if (signingRegion) {
        return signingRegion;
      } else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
          return regionRegexmatchArray[0].slice(1, -1);
        }
      }
    }, "getResolvedSigningRegion");
    var getRegionInfo = /* @__PURE__ */ __name((region, {
      useFipsEndpoint = false,
      useDualstackEndpoint = false,
      signingService,
      regionHash,
      partitionHash
    }) => {
      const partition = getResolvedPartition(region, { partitionHash });
      const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
      const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
      const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
      const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);
      const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
      if (hostname === void 0) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
      }
      const signingRegion = getResolvedSigningRegion(hostname, {
        signingRegion: regionHash[resolvedRegion]?.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint
      });
      return {
        partition,
        signingService,
        hostname,
        ...signingRegion && { signingRegion },
        ...regionHash[resolvedRegion]?.signingService && {
          signingService: regionHash[resolvedRegion].signingService
        }
      };
    }, "getRegionInfo");
  }
});

// node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs27 = __commonJS({
  "node_modules/@smithy/middleware-content-length/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      contentLengthMiddleware: () => contentLengthMiddleware,
      contentLengthMiddlewareOptions: () => contentLengthMiddlewareOptions,
      getContentLengthPlugin: () => getContentLengthPlugin3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_protocol_http11 = require_dist_cjs2();
    var CONTENT_LENGTH_HEADER = "content-length";
    function contentLengthMiddleware(bodyLengthChecker) {
      return (next) => async (args) => {
        const request = args.request;
        if (import_protocol_http11.HttpRequest.isInstance(request)) {
          const { body, headers } = request;
          if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
            try {
              const length = bodyLengthChecker(body);
              request.headers = {
                ...request.headers,
                [CONTENT_LENGTH_HEADER]: String(length)
              };
            } catch (error) {
            }
          }
        }
        return next({
          ...args,
          request
        });
      };
    }
    __name(contentLengthMiddleware, "contentLengthMiddleware");
    var contentLengthMiddlewareOptions = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: true
    };
    var getContentLengthPlugin3 = /* @__PURE__ */ __name((options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
      }
    }), "getContentLengthPlugin");
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS({
  "node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHomeDir = void 0;
    var os_1 = __require("os");
    var path_1 = __require("path");
    var homeDirCache = {};
    var getHomeDirCacheKey = () => {
      if (process && process.geteuid) {
        return `${process.geteuid()}`;
      }
      return "DEFAULT";
    };
    var getHomeDir2 = () => {
      const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
      if (HOME)
        return HOME;
      if (USERPROFILE)
        return USERPROFILE;
      if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
      const homeDirCacheKey = getHomeDirCacheKey();
      if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
      return homeDirCache[homeDirCacheKey];
    };
    exports.getHomeDir = getHomeDir2;
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS({
  "node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSSOTokenFilepath = void 0;
    var crypto_1 = __require("crypto");
    var path_1 = __require("path");
    var getHomeDir_1 = require_getHomeDir();
    var getSSOTokenFilepath2 = (id) => {
      const hasher = (0, crypto_1.createHash)("sha1");
      const cacheName = hasher.update(id).digest("hex");
      return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
    };
    exports.getSSOTokenFilepath = getSSOTokenFilepath2;
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS({
  "node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSSOTokenFromFile = void 0;
    var fs_1 = __require("fs");
    var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
    var { readFile } = fs_1.promises;
    var getSSOTokenFromFile2 = async (id) => {
      const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
      const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
      return JSON.parse(ssoTokenText);
    };
    exports.getSSOTokenFromFile = getSSOTokenFromFile2;
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/slurpFile.js
var require_slurpFile = __commonJS({
  "node_modules/@smithy/shared-ini-file-loader/dist-cjs/slurpFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.slurpFile = void 0;
    var fs_1 = __require("fs");
    var { readFile } = fs_1.promises;
    var filePromisesHash = {};
    var slurpFile = (path, options) => {
      if (!filePromisesHash[path] || (options === null || options === void 0 ? void 0 : options.ignoreCache)) {
        filePromisesHash[path] = readFile(path, "utf8");
      }
      return filePromisesHash[path];
    };
    exports.slurpFile = slurpFile;
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs28 = __commonJS({
  "node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CONFIG_PREFIX_SEPARATOR: () => CONFIG_PREFIX_SEPARATOR,
      DEFAULT_PROFILE: () => DEFAULT_PROFILE,
      ENV_PROFILE: () => ENV_PROFILE,
      getProfileName: () => getProfileName,
      loadSharedConfigFiles: () => loadSharedConfigFiles,
      loadSsoSessionData: () => loadSsoSessionData,
      parseKnownFiles: () => parseKnownFiles
    });
    module.exports = __toCommonJS2(src_exports);
    __reExport(src_exports, require_getHomeDir(), module.exports);
    var ENV_PROFILE = "AWS_PROFILE";
    var DEFAULT_PROFILE = "default";
    var getProfileName = /* @__PURE__ */ __name((init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE, "getProfileName");
    __reExport(src_exports, require_getSSOTokenFilepath(), module.exports);
    __reExport(src_exports, require_getSSOTokenFromFile(), module.exports);
    var import_types5 = require_dist_cjs();
    var getConfigData = /* @__PURE__ */ __name((data) => Object.entries(data).filter(([key]) => {
      const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
      if (indexOfSeparator === -1) {
        return false;
      }
      return Object.values(import_types5.IniSectionType).includes(key.substring(0, indexOfSeparator));
    }).reduce(
      (acc, [key, value]) => {
        const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
        const updatedKey = key.substring(0, indexOfSeparator) === import_types5.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
        acc[updatedKey] = value;
        return acc;
      },
      {
        // Populate default profile, if present.
        ...data.default && { default: data.default }
      }
    ), "getConfigData");
    var import_path = __require("path");
    var import_getHomeDir = require_getHomeDir();
    var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
    var getConfigFilepath = /* @__PURE__ */ __name(() => process.env[ENV_CONFIG_PATH] || (0, import_path.join)((0, import_getHomeDir.getHomeDir)(), ".aws", "config"), "getConfigFilepath");
    var import_getHomeDir2 = require_getHomeDir();
    var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
    var getCredentialsFilepath = /* @__PURE__ */ __name(() => process.env[ENV_CREDENTIALS_PATH] || (0, import_path.join)((0, import_getHomeDir2.getHomeDir)(), ".aws", "credentials"), "getCredentialsFilepath");
    var import_getHomeDir3 = require_getHomeDir();
    var prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
    var profileNameBlockList = ["__proto__", "profile __proto__"];
    var parseIni = /* @__PURE__ */ __name((iniData) => {
      const map2 = {};
      let currentSection;
      let currentSubSection;
      for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
          currentSection = void 0;
          currentSubSection = void 0;
          const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
          const matches = prefixKeyRegex.exec(sectionName);
          if (matches) {
            const [, prefix, , name] = matches;
            if (Object.values(import_types5.IniSectionType).includes(prefix)) {
              currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
            }
          } else {
            currentSection = sectionName;
          }
          if (profileNameBlockList.includes(sectionName)) {
            throw new Error(`Found invalid profile name "${sectionName}"`);
          }
        } else if (currentSection) {
          const indexOfEqualsSign = trimmedLine.indexOf("=");
          if (![0, -1].includes(indexOfEqualsSign)) {
            const [name, value] = [
              trimmedLine.substring(0, indexOfEqualsSign).trim(),
              trimmedLine.substring(indexOfEqualsSign + 1).trim()
            ];
            if (value === "") {
              currentSubSection = name;
            } else {
              if (currentSubSection && iniLine.trimStart() === iniLine) {
                currentSubSection = void 0;
              }
              map2[currentSection] = map2[currentSection] || {};
              const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
              map2[currentSection][key] = value;
            }
          }
        }
      }
      return map2;
    }, "parseIni");
    var import_slurpFile = require_slurpFile();
    var swallowError = /* @__PURE__ */ __name(() => ({}), "swallowError");
    var CONFIG_PREFIX_SEPARATOR = ".";
    var loadSharedConfigFiles = /* @__PURE__ */ __name(async (init = {}) => {
      const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
      const homeDir = (0, import_getHomeDir3.getHomeDir)();
      const relativeHomeDirPrefix = "~/";
      let resolvedFilepath = filepath;
      if (filepath.startsWith(relativeHomeDirPrefix)) {
        resolvedFilepath = (0, import_path.join)(homeDir, filepath.slice(2));
      }
      let resolvedConfigFilepath = configFilepath;
      if (configFilepath.startsWith(relativeHomeDirPrefix)) {
        resolvedConfigFilepath = (0, import_path.join)(homeDir, configFilepath.slice(2));
      }
      const parsedFiles = await Promise.all([
        (0, import_slurpFile.slurpFile)(resolvedConfigFilepath, {
          ignoreCache: init.ignoreCache
        }).then(parseIni).then(getConfigData).catch(swallowError),
        (0, import_slurpFile.slurpFile)(resolvedFilepath, {
          ignoreCache: init.ignoreCache
        }).then(parseIni).catch(swallowError)
      ]);
      return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1]
      };
    }, "loadSharedConfigFiles");
    var getSsoSessionData = /* @__PURE__ */ __name((data) => Object.entries(data).filter(([key]) => key.startsWith(import_types5.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {}), "getSsoSessionData");
    var import_slurpFile2 = require_slurpFile();
    var swallowError2 = /* @__PURE__ */ __name(() => ({}), "swallowError");
    var loadSsoSessionData = /* @__PURE__ */ __name(async (init = {}) => (0, import_slurpFile2.slurpFile)(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2), "loadSsoSessionData");
    var mergeConfigFiles = /* @__PURE__ */ __name((...files) => {
      const merged = {};
      for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
          if (merged[key] !== void 0) {
            Object.assign(merged[key], values);
          } else {
            merged[key] = values;
          }
        }
      }
      return merged;
    }, "mergeConfigFiles");
    var parseKnownFiles = /* @__PURE__ */ __name(async (init) => {
      const parsedFiles = await loadSharedConfigFiles(init);
      return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
    }, "parseKnownFiles");
  }
});

// node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs29 = __commonJS({
  "node_modules/@smithy/node-config-provider/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      loadConfig: () => loadConfig
    });
    module.exports = __toCommonJS2(src_exports);
    var import_property_provider2 = require_dist_cjs20();
    function getSelectorName(functionString) {
      try {
        const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
        constants.delete("CONFIG");
        constants.delete("CONFIG_PREFIX_SEPARATOR");
        constants.delete("ENV");
        return [...constants].join(", ");
      } catch (e3) {
        return functionString;
      }
    }
    __name(getSelectorName, "getSelectorName");
    var fromEnv = /* @__PURE__ */ __name((envVarSelector, logger) => async () => {
      try {
        const config = envVarSelector(process.env);
        if (config === void 0) {
          throw new Error();
        }
        return config;
      } catch (e3) {
        throw new import_property_provider2.CredentialsProviderError(
          e3.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`,
          { logger }
        );
      }
    }, "fromEnv");
    var import_shared_ini_file_loader = require_dist_cjs28();
    var fromSharedConfigFiles = /* @__PURE__ */ __name((configSelector, { preferredFile = "config", ...init } = {}) => async () => {
      const profile = (0, import_shared_ini_file_loader.getProfileName)(init);
      const { configFile, credentialsFile } = await (0, import_shared_ini_file_loader.loadSharedConfigFiles)(init);
      const profileFromCredentials = credentialsFile[profile] || {};
      const profileFromConfig = configFile[profile] || {};
      const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
      try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === void 0) {
          throw new Error();
        }
        return configValue;
      } catch (e3) {
        throw new import_property_provider2.CredentialsProviderError(
          e3.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`,
          { logger: init.logger }
        );
      }
    }, "fromSharedConfigFiles");
    var isFunction = /* @__PURE__ */ __name((func) => typeof func === "function", "isFunction");
    var fromStatic = /* @__PURE__ */ __name((defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : (0, import_property_provider2.fromStatic)(defaultValue), "fromStatic");
    var loadConfig = /* @__PURE__ */ __name(({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, import_property_provider2.memoize)(
      (0, import_property_provider2.chain)(
        fromEnv(environmentVariableSelector),
        fromSharedConfigFiles(configFileSelector, configuration),
        fromStatic(defaultValue)
      )
    ), "loadConfig");
  }
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS({
  "node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndpointUrlConfig = void 0;
    var shared_ini_file_loader_1 = require_dist_cjs28();
    var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
    var CONFIG_ENDPOINT_URL = "endpoint_url";
    var getEndpointUrlConfig = (serviceId) => ({
      environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w3) => w3.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
          return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
          return endpointUrl;
        return void 0;
      },
      configFileSelector: (profile, config) => {
        if (config && profile.services) {
          const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (servicesSection) {
            const servicePrefixParts = serviceId.split(" ").map((w3) => w3.toLowerCase());
            const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
            if (endpointUrl2)
              return endpointUrl2;
          }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
          return endpointUrl;
        return void 0;
      },
      default: void 0
    });
    exports.getEndpointUrlConfig = getEndpointUrlConfig;
  }
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS({
  "node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndpointFromConfig = void 0;
    var node_config_provider_1 = require_dist_cjs29();
    var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
    var getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId !== null && serviceId !== void 0 ? serviceId : ""))();
    exports.getEndpointFromConfig = getEndpointFromConfig;
  }
});

// node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs30 = __commonJS({
  "node_modules/@smithy/querystring-parser/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      parseQueryString: () => parseQueryString
    });
    module.exports = __toCommonJS2(src_exports);
    function parseQueryString(querystring) {
      const query = {};
      querystring = querystring.replace(/^\?/, "");
      if (querystring) {
        for (const pair of querystring.split("&")) {
          let [key, value = null] = pair.split("=");
          key = decodeURIComponent(key);
          if (value) {
            value = decodeURIComponent(value);
          }
          if (!(key in query)) {
            query[key] = value;
          } else if (Array.isArray(query[key])) {
            query[key].push(value);
          } else {
            query[key] = [query[key], value];
          }
        }
      }
      return query;
    }
    __name(parseQueryString, "parseQueryString");
  }
});

// node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs31 = __commonJS({
  "node_modules/@smithy/url-parser/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      parseUrl: () => parseUrl3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_querystring_parser = require_dist_cjs30();
    var parseUrl3 = /* @__PURE__ */ __name((url) => {
      if (typeof url === "string") {
        return parseUrl3(new URL(url));
      }
      const { hostname, pathname, port, protocol, search } = url;
      let query;
      if (search) {
        query = (0, import_querystring_parser.parseQueryString)(search);
      }
      return {
        hostname,
        port: port ? parseInt(port) : void 0,
        protocol,
        path: pathname,
        query
      };
    }, "parseUrl");
  }
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs32 = __commonJS({
  "node_modules/@smithy/middleware-endpoint/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      endpointMiddleware: () => endpointMiddleware,
      endpointMiddlewareOptions: () => endpointMiddlewareOptions,
      getEndpointFromInstructions: () => getEndpointFromInstructions,
      getEndpointPlugin: () => getEndpointPlugin4,
      resolveEndpointConfig: () => resolveEndpointConfig3,
      resolveParams: () => resolveParams,
      toEndpointV1: () => toEndpointV1
    });
    module.exports = __toCommonJS2(src_exports);
    var resolveParamsForS3 = /* @__PURE__ */ __name(async (endpointParams) => {
      const bucket = endpointParams?.Bucket || "";
      if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      }
      if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
          throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
      } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
      }
      if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
      }
      return endpointParams;
    }, "resolveParamsForS3");
    var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    var DOTS_PATTERN = /\.\./;
    var isDnsCompatibleBucketName = /* @__PURE__ */ __name((bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName), "isDnsCompatibleBucketName");
    var isArnBucketName = /* @__PURE__ */ __name((bucketName) => {
      const [arn, partition, service, , , bucket] = bucketName.split(":");
      const isArn = arn === "arn" && bucketName.split(":").length >= 6;
      const isValidArn = Boolean(isArn && partition && service && bucket);
      if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
      }
      return isValidArn;
    }, "isArnBucketName");
    var createConfigValueProvider = /* @__PURE__ */ __name((configKey, canonicalEndpointParamKey, config) => {
      const configProvider = /* @__PURE__ */ __name(async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
          return configValue();
        }
        return configValue;
      }, "configProvider");
      if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
          return configValue;
        };
      }
      if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.accountId ?? credentials?.AccountId;
          return configValue;
        };
      }
      if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
          const endpoint = await configProvider();
          if (endpoint && typeof endpoint === "object") {
            if ("url" in endpoint) {
              return endpoint.url.href;
            }
            if ("hostname" in endpoint) {
              const { protocol, hostname, port, path } = endpoint;
              return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
            }
          }
          return endpoint;
        };
      }
      return configProvider;
    }, "createConfigValueProvider");
    var import_getEndpointFromConfig = require_getEndpointFromConfig();
    var import_url_parser3 = require_dist_cjs31();
    var toEndpointV1 = /* @__PURE__ */ __name((endpoint) => {
      if (typeof endpoint === "object") {
        if ("url" in endpoint) {
          return (0, import_url_parser3.parseUrl)(endpoint.url);
        }
        return endpoint;
      }
      return (0, import_url_parser3.parseUrl)(endpoint);
    }, "toEndpointV1");
    var getEndpointFromInstructions = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig, context) => {
      if (!clientConfig.endpoint) {
        let endpointFromConfig;
        if (clientConfig.serviceConfiguredEndpoint) {
          endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
        } else {
          endpointFromConfig = await (0, import_getEndpointFromConfig.getEndpointFromConfig)(clientConfig.serviceId);
        }
        if (endpointFromConfig) {
          clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
      }
      const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
      if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
      }
      const endpoint = clientConfig.endpointProvider(endpointParams, context);
      return endpoint;
    }, "getEndpointFromInstructions");
    var resolveParams = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig) => {
      const endpointParams = {};
      const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
      for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
          case "staticContextParams":
            endpointParams[name] = instruction.value;
            break;
          case "contextParams":
            endpointParams[name] = commandInput[instruction.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
            break;
          case "operationContextParams":
            endpointParams[name] = instruction.get(commandInput);
            break;
          default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
      }
      if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
      }
      if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
      }
      return endpointParams;
    }, "resolveParams");
    var import_core17 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var import_util_middleware5 = require_dist_cjs6();
    var endpointMiddleware = /* @__PURE__ */ __name(({
      config,
      instructions
    }) => {
      return (next, context) => async (args) => {
        if (config.endpoint) {
          (0, import_core17.setFeature)(context, "ENDPOINT_OVERRIDE", "N");
        }
        const endpoint = await getEndpointFromInstructions(
          args.input,
          {
            getEndpointParameterInstructions() {
              return instructions;
            }
          },
          { ...config },
          context
        );
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
          context["signing_region"] = authScheme.signingRegion;
          context["signing_service"] = authScheme.signingName;
          const smithyContext = (0, import_util_middleware5.getSmithyContext)(context);
          const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
          if (httpAuthOption) {
            httpAuthOption.signingProperties = Object.assign(
              httpAuthOption.signingProperties || {},
              {
                signing_region: authScheme.signingRegion,
                signingRegion: authScheme.signingRegion,
                signing_service: authScheme.signingName,
                signingName: authScheme.signingName,
                signingRegionSet: authScheme.signingRegionSet
              },
              authScheme.properties
            );
          }
        }
        return next({
          ...args
        });
      };
    }, "endpointMiddleware");
    var import_middleware_serde5 = require_dist_cjs7();
    var endpointMiddlewareOptions = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: true,
      relation: "before",
      toMiddleware: import_middleware_serde5.serializerMiddlewareOption.name
    };
    var getEndpointPlugin4 = /* @__PURE__ */ __name((config, instructions) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(
          endpointMiddleware({
            config,
            instructions
          }),
          endpointMiddlewareOptions
        );
      }
    }), "getEndpointPlugin");
    var import_getEndpointFromConfig2 = require_getEndpointFromConfig();
    var resolveEndpointConfig3 = /* @__PURE__ */ __name((input) => {
      const tls = input.tls ?? true;
      const { endpoint } = input;
      const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await (0, import_util_middleware5.normalizeProvider)(endpoint)()) : void 0;
      const isCustomEndpoint = !!endpoint;
      const resolvedConfig = {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0, import_util_middleware5.normalizeProvider)(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: (0, import_util_middleware5.normalizeProvider)(input.useFipsEndpoint ?? false)
      };
      let configuredEndpointPromise = void 0;
      resolvedConfig.serviceConfiguredEndpoint = async () => {
        if (input.serviceId && !configuredEndpointPromise) {
          configuredEndpointPromise = (0, import_getEndpointFromConfig2.getEndpointFromConfig)(input.serviceId);
        }
        return configuredEndpointPromise;
      };
      return resolvedConfig;
    }, "resolveEndpointConfig");
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/rng.js
import crypto2 from "crypto";
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i3 = 0; i3 < 256; ++i3) {
      byteToHex.push((i3 + 256).toString(16).slice(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i3 = buf && offset || 0;
  const b3 = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b3[i3++] = tl >>> 24 & 255;
  b3[i3++] = tl >>> 16 & 255;
  b3[i3++] = tl >>> 8 & 255;
  b3[i3++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b3[i3++] = tmh >>> 8 & 255;
  b3[i3++] = tmh & 255;
  b3[i3++] = tmh >>> 24 & 15 | 16;
  b3[i3++] = tmh >>> 16 & 255;
  b3[i3++] = clockseq >>> 8 | 128;
  b3[i3++] = clockseq & 255;
  for (let n3 = 0; n3 < 6; ++n3) {
    b3[i3 + n3] = node[n3];
  }
  return buf || unsafeStringify(b3);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse2;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i3 = 0; i3 < str.length; ++i3) {
    bytes.push(str.charCodeAt(i3));
  }
  return bytes;
}
function v35(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version3;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i3 = 0; i3 < 16; ++i3) {
        buf[offset + i3] = bytes[i3];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/md5.js
import crypto3 from "crypto";
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto3.createHash("md5").update(bytes).digest();
}
var md5_default;
var init_md5 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/native.js
import crypto4 from "crypto";
var native_default;
var init_native = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/native.js"() {
    native_default = {
      randomUUID: crypto4.randomUUID
    };
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/sha1.js
import crypto5 from "crypto";
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto5.createHash("sha1").update(bytes).digest();
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs33 = __commonJS({
  "node_modules/@smithy/service-error-classification/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      isClockSkewCorrectedError: () => isClockSkewCorrectedError,
      isClockSkewError: () => isClockSkewError,
      isRetryableByTrait: () => isRetryableByTrait,
      isServerError: () => isServerError,
      isThrottlingError: () => isThrottlingError,
      isTransientError: () => isTransientError
    });
    module.exports = __toCommonJS2(src_exports);
    var CLOCK_SKEW_ERROR_CODES = [
      "AuthFailure",
      "InvalidSignatureException",
      "RequestExpired",
      "RequestInTheFuture",
      "RequestTimeTooSkewed",
      "SignatureDoesNotMatch"
    ];
    var THROTTLING_ERROR_CODES = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException"
      // DynamoDB
    ];
    var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
    var isRetryableByTrait = /* @__PURE__ */ __name((error) => error.$retryable !== void 0, "isRetryableByTrait");
    var isClockSkewError = /* @__PURE__ */ __name((error) => CLOCK_SKEW_ERROR_CODES.includes(error.name), "isClockSkewError");
    var isClockSkewCorrectedError = /* @__PURE__ */ __name((error) => error.$metadata?.clockSkewCorrected, "isClockSkewCorrectedError");
    var isThrottlingError = /* @__PURE__ */ __name((error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true, "isThrottlingError");
    var isTransientError = /* @__PURE__ */ __name((error, depth = 0) => isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || error.cause !== void 0 && depth <= 10 && isTransientError(error.cause, depth + 1), "isTransientError");
    var isServerError = /* @__PURE__ */ __name((error) => {
      if (error.$metadata?.httpStatusCode !== void 0) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
          return true;
        }
        return false;
      }
      return false;
    }, "isServerError");
  }
});

// node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs34 = __commonJS({
  "node_modules/@smithy/util-retry/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      AdaptiveRetryStrategy: () => AdaptiveRetryStrategy,
      ConfiguredRetryStrategy: () => ConfiguredRetryStrategy,
      DEFAULT_MAX_ATTEMPTS: () => DEFAULT_MAX_ATTEMPTS,
      DEFAULT_RETRY_DELAY_BASE: () => DEFAULT_RETRY_DELAY_BASE,
      DEFAULT_RETRY_MODE: () => DEFAULT_RETRY_MODE3,
      DefaultRateLimiter: () => DefaultRateLimiter,
      INITIAL_RETRY_TOKENS: () => INITIAL_RETRY_TOKENS,
      INVOCATION_ID_HEADER: () => INVOCATION_ID_HEADER,
      MAXIMUM_RETRY_DELAY: () => MAXIMUM_RETRY_DELAY,
      NO_RETRY_INCREMENT: () => NO_RETRY_INCREMENT,
      REQUEST_HEADER: () => REQUEST_HEADER,
      RETRY_COST: () => RETRY_COST,
      RETRY_MODES: () => RETRY_MODES,
      StandardRetryStrategy: () => StandardRetryStrategy,
      THROTTLING_RETRY_DELAY_BASE: () => THROTTLING_RETRY_DELAY_BASE,
      TIMEOUT_RETRY_COST: () => TIMEOUT_RETRY_COST
    });
    module.exports = __toCommonJS2(src_exports);
    var RETRY_MODES = /* @__PURE__ */ ((RETRY_MODES2) => {
      RETRY_MODES2["STANDARD"] = "standard";
      RETRY_MODES2["ADAPTIVE"] = "adaptive";
      return RETRY_MODES2;
    })(RETRY_MODES || {});
    var DEFAULT_MAX_ATTEMPTS = 3;
    var DEFAULT_RETRY_MODE3 = "standard";
    var import_service_error_classification = require_dist_cjs33();
    var DefaultRateLimiter = class _DefaultRateLimiter {
      constructor(options) {
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
      }
      static {
        __name(this, "DefaultRateLimiter");
      }
      static {
        this.setTimeoutFn = setTimeout;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(amount) {
        if (!this.enabled) {
          return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
          const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
          await new Promise((resolve) => _DefaultRateLimiter.setTimeoutFn(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
      }
      refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
          return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
      }
      updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0, import_service_error_classification.isThrottlingError)(response)) {
          const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = rateToUse;
          this.calculateTimeWindow();
          this.lastThrottleTime = this.getCurrentTimeInSeconds();
          calculatedRate = this.cubicThrottle(rateToUse);
          this.enableTokenBucket();
        } else {
          this.calculateTimeWindow();
          calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
      }
      cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
      }
      cubicSuccess(timestamp) {
        return this.getPrecise(
          this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate
        );
      }
      enableTokenBucket() {
        this.enabled = true;
      }
      updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
      }
      updateMeasuredRate() {
        const t3 = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t3 * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
          const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
          this.requestCount = 0;
          this.lastTxRateBucket = timeBucket;
        }
      }
      getPrecise(num) {
        return parseFloat(num.toFixed(8));
      }
    };
    var DEFAULT_RETRY_DELAY_BASE = 100;
    var MAXIMUM_RETRY_DELAY = 20 * 1e3;
    var THROTTLING_RETRY_DELAY_BASE = 500;
    var INITIAL_RETRY_TOKENS = 500;
    var RETRY_COST = 5;
    var TIMEOUT_RETRY_COST = 10;
    var NO_RETRY_INCREMENT = 1;
    var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    var REQUEST_HEADER = "amz-sdk-request";
    var getDefaultRetryBackoffStrategy = /* @__PURE__ */ __name(() => {
      let delayBase = DEFAULT_RETRY_DELAY_BASE;
      const computeNextBackoffDelay = /* @__PURE__ */ __name((attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      }, "computeNextBackoffDelay");
      const setDelayBase = /* @__PURE__ */ __name((delay) => {
        delayBase = delay;
      }, "setDelayBase");
      return {
        computeNextBackoffDelay,
        setDelayBase
      };
    }, "getDefaultRetryBackoffStrategy");
    var createDefaultRetryToken = /* @__PURE__ */ __name(({
      retryDelay,
      retryCount,
      retryCost
    }) => {
      const getRetryCount = /* @__PURE__ */ __name(() => retryCount, "getRetryCount");
      const getRetryDelay = /* @__PURE__ */ __name(() => Math.min(MAXIMUM_RETRY_DELAY, retryDelay), "getRetryDelay");
      const getRetryCost = /* @__PURE__ */ __name(() => retryCost, "getRetryCost");
      return {
        getRetryCount,
        getRetryDelay,
        getRetryCost
      };
    }, "createDefaultRetryToken");
    var StandardRetryStrategy = class {
      constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = "standard";
        this.capacity = INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
      }
      static {
        __name(this, "StandardRetryStrategy");
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
          retryDelay: DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0
        });
      }
      async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
          const errorType = errorInfo.errorType;
          this.retryBackoffStrategy.setDelayBase(
            errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE
          );
          const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
          const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
          const capacityCost = this.getCapacityCost(errorType);
          this.capacity -= capacityCost;
          return createDefaultRetryToken({
            retryDelay,
            retryCount: token.getRetryCount() + 1,
            retryCost: capacityCost
          });
        }
        throw new Error("No retry token available");
      }
      recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
      }
      /**
       * @returns the current available retry capacity.
       *
       * This number decreases when retries are executed and refills when requests or retries succeed.
       */
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch (error) {
          console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
          return DEFAULT_MAX_ATTEMPTS;
        }
      }
      shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
      }
      getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
      }
      isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
      }
    };
    var AdaptiveRetryStrategy = class {
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = "adaptive";
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
      }
      static {
        __name(this, "AdaptiveRetryStrategy");
      }
      async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      }
      recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
      }
    };
    var ConfiguredRetryStrategy = class extends StandardRetryStrategy {
      static {
        __name(this, "ConfiguredRetryStrategy");
      }
      /**
       * @param maxAttempts - the maximum number of retry attempts allowed.
       *                      e.g., if set to 3, then 4 total requests are possible.
       * @param computeNextBackoffDelay - a millisecond delay for each retry or a function that takes the retry attempt
       *                                  and returns the delay.
       *
       * @example exponential backoff.
       * ```js
       * new Client({
       *   retryStrategy: new ConfiguredRetryStrategy(3, (attempt) => attempt ** 2)
       * });
       * ```
       * @example constant delay.
       * ```js
       * new Client({
       *   retryStrategy: new ConfiguredRetryStrategy(3, 2000)
       * });
       * ```
       */
      constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
          this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        } else {
          this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
      }
    };
  }
});

// node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = __commonJS({
  "node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStreamingPayload = void 0;
    var stream_1 = __require("stream");
    var isStreamingPayload = (request) => (request === null || request === void 0 ? void 0 : request.body) instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && (request === null || request === void 0 ? void 0 : request.body) instanceof ReadableStream;
    exports.isStreamingPayload = isStreamingPayload;
  }
});

// node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs35 = __commonJS({
  "node_modules/@smithy/middleware-retry/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      AdaptiveRetryStrategy: () => AdaptiveRetryStrategy,
      CONFIG_MAX_ATTEMPTS: () => CONFIG_MAX_ATTEMPTS,
      CONFIG_RETRY_MODE: () => CONFIG_RETRY_MODE,
      ENV_MAX_ATTEMPTS: () => ENV_MAX_ATTEMPTS,
      ENV_RETRY_MODE: () => ENV_RETRY_MODE,
      NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => NODE_MAX_ATTEMPT_CONFIG_OPTIONS3,
      NODE_RETRY_MODE_CONFIG_OPTIONS: () => NODE_RETRY_MODE_CONFIG_OPTIONS3,
      StandardRetryStrategy: () => StandardRetryStrategy,
      defaultDelayDecider: () => defaultDelayDecider,
      defaultRetryDecider: () => defaultRetryDecider,
      getOmitRetryHeadersPlugin: () => getOmitRetryHeadersPlugin,
      getRetryAfterHint: () => getRetryAfterHint,
      getRetryPlugin: () => getRetryPlugin3,
      omitRetryHeadersMiddleware: () => omitRetryHeadersMiddleware,
      omitRetryHeadersMiddlewareOptions: () => omitRetryHeadersMiddlewareOptions,
      resolveRetryConfig: () => resolveRetryConfig3,
      retryMiddleware: () => retryMiddleware,
      retryMiddlewareOptions: () => retryMiddlewareOptions
    });
    module.exports = __toCommonJS2(src_exports);
    var import_protocol_http11 = require_dist_cjs2();
    var import_uuid = (init_esm_node(), __toCommonJS(esm_node_exports));
    var import_util_retry3 = require_dist_cjs34();
    var getDefaultRetryQuota = /* @__PURE__ */ __name((initialRetryTokens, options) => {
      const MAX_CAPACITY = initialRetryTokens;
      const noRetryIncrement = options?.noRetryIncrement ?? import_util_retry3.NO_RETRY_INCREMENT;
      const retryCost = options?.retryCost ?? import_util_retry3.RETRY_COST;
      const timeoutRetryCost = options?.timeoutRetryCost ?? import_util_retry3.TIMEOUT_RETRY_COST;
      let availableCapacity = initialRetryTokens;
      const getCapacityAmount = /* @__PURE__ */ __name((error) => error.name === "TimeoutError" ? timeoutRetryCost : retryCost, "getCapacityAmount");
      const hasRetryTokens = /* @__PURE__ */ __name((error) => getCapacityAmount(error) <= availableCapacity, "hasRetryTokens");
      const retrieveRetryTokens = /* @__PURE__ */ __name((error) => {
        if (!hasRetryTokens(error)) {
          throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
      }, "retrieveRetryTokens");
      const releaseRetryTokens = /* @__PURE__ */ __name((capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
      }, "releaseRetryTokens");
      return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens
      });
    }, "getDefaultRetryQuota");
    var defaultDelayDecider = /* @__PURE__ */ __name((delayBase, attempts) => Math.floor(Math.min(import_util_retry3.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase)), "defaultDelayDecider");
    var import_service_error_classification = require_dist_cjs33();
    var defaultRetryDecider = /* @__PURE__ */ __name((error) => {
      if (!error) {
        return false;
      }
      return (0, import_service_error_classification.isRetryableByTrait)(error) || (0, import_service_error_classification.isClockSkewError)(error) || (0, import_service_error_classification.isThrottlingError)(error) || (0, import_service_error_classification.isTransientError)(error);
    }, "defaultRetryDecider");
    var asSdkError = /* @__PURE__ */ __name((error) => {
      if (error instanceof Error)
        return error;
      if (error instanceof Object)
        return Object.assign(new Error(), error);
      if (typeof error === "string")
        return new Error(error);
      return new Error(`AWS SDK error wrapper for ${error}`);
    }, "asSdkError");
    var StandardRetryStrategy = class {
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = import_util_retry3.RETRY_MODES.STANDARD;
        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(import_util_retry3.INITIAL_RETRY_TOKENS);
      }
      static {
        __name(this, "StandardRetryStrategy");
      }
      shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
      }
      async getMaxAttempts() {
        let maxAttempts;
        try {
          maxAttempts = await this.maxAttemptsProvider();
        } catch (error) {
          maxAttempts = import_util_retry3.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
      }
      async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (import_protocol_http11.HttpRequest.isInstance(request)) {
          request.headers[import_util_retry3.INVOCATION_ID_HEADER] = (0, import_uuid.v4)();
        }
        while (true) {
          try {
            if (import_protocol_http11.HttpRequest.isInstance(request)) {
              request.headers[import_util_retry3.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            if (options?.beforeRequest) {
              await options.beforeRequest();
            }
            const { response, output } = await next(args);
            if (options?.afterRequest) {
              options.afterRequest(response);
            }
            this.retryQuota.releaseRetryTokens(retryTokenAmount);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalDelay;
            return { response, output };
          } catch (e3) {
            const err = asSdkError(e3);
            attempts++;
            if (this.shouldRetry(err, attempts, maxAttempts)) {
              retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
              const delayFromDecider = this.delayDecider(
                (0, import_service_error_classification.isThrottlingError)(err) ? import_util_retry3.THROTTLING_RETRY_DELAY_BASE : import_util_retry3.DEFAULT_RETRY_DELAY_BASE,
                attempts
              );
              const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
              const delay = Math.max(delayFromResponse || 0, delayFromDecider);
              totalDelay += delay;
              await new Promise((resolve) => setTimeout(resolve, delay));
              continue;
            }
            if (!err.$metadata) {
              err.$metadata = {};
            }
            err.$metadata.attempts = attempts;
            err.$metadata.totalRetryDelay = totalDelay;
            throw err;
          }
        }
      }
    };
    var getDelayFromRetryAfterHeader = /* @__PURE__ */ __name((response) => {
      if (!import_protocol_http11.HttpResponse.isInstance(response))
        return;
      const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1e3;
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate.getTime() - Date.now();
    }, "getDelayFromRetryAfterHeader");
    var AdaptiveRetryStrategy = class extends StandardRetryStrategy {
      static {
        __name(this, "AdaptiveRetryStrategy");
      }
      constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options ?? {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter ?? new import_util_retry3.DefaultRateLimiter();
        this.mode = import_util_retry3.RETRY_MODES.ADAPTIVE;
      }
      async retry(next, args) {
        return super.retry(next, args, {
          beforeRequest: async () => {
            return this.rateLimiter.getSendToken();
          },
          afterRequest: (response) => {
            this.rateLimiter.updateClientSendingRate(response);
          }
        });
      }
    };
    var import_util_middleware5 = require_dist_cjs6();
    var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
    var CONFIG_MAX_ATTEMPTS = "max_attempts";
    var NODE_MAX_ATTEMPT_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => {
        const value = env[ENV_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      default: import_util_retry3.DEFAULT_MAX_ATTEMPTS
    };
    var resolveRetryConfig3 = /* @__PURE__ */ __name((input) => {
      const { retryStrategy } = input;
      const maxAttempts = (0, import_util_middleware5.normalizeProvider)(input.maxAttempts ?? import_util_retry3.DEFAULT_MAX_ATTEMPTS);
      return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
          if (retryStrategy) {
            return retryStrategy;
          }
          const retryMode = await (0, import_util_middleware5.normalizeProvider)(input.retryMode)();
          if (retryMode === import_util_retry3.RETRY_MODES.ADAPTIVE) {
            return new import_util_retry3.AdaptiveRetryStrategy(maxAttempts);
          }
          return new import_util_retry3.StandardRetryStrategy(maxAttempts);
        }
      };
    }, "resolveRetryConfig");
    var ENV_RETRY_MODE = "AWS_RETRY_MODE";
    var CONFIG_RETRY_MODE = "retry_mode";
    var NODE_RETRY_MODE_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
      configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
      default: import_util_retry3.DEFAULT_RETRY_MODE
    };
    var omitRetryHeadersMiddleware = /* @__PURE__ */ __name(() => (next) => async (args) => {
      const { request } = args;
      if (import_protocol_http11.HttpRequest.isInstance(request)) {
        delete request.headers[import_util_retry3.INVOCATION_ID_HEADER];
        delete request.headers[import_util_retry3.REQUEST_HEADER];
      }
      return next(args);
    }, "omitRetryHeadersMiddleware");
    var omitRetryHeadersMiddlewareOptions = {
      name: "omitRetryHeadersMiddleware",
      tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: true
    };
    var getOmitRetryHeadersPlugin = /* @__PURE__ */ __name((options) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
      }
    }), "getOmitRetryHeadersPlugin");
    var import_smithy_client25 = require_dist_cjs23();
    var import_isStreamingPayload = require_isStreamingPayload();
    var retryMiddleware = /* @__PURE__ */ __name((options) => (next, context) => async (args) => {
      let retryStrategy = await options.retryStrategy();
      const maxAttempts = await options.maxAttempts();
      if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = import_protocol_http11.HttpRequest.isInstance(request);
        if (isRequest) {
          request.headers[import_util_retry3.INVOCATION_ID_HEADER] = (0, import_uuid.v4)();
        }
        while (true) {
          try {
            if (isRequest) {
              request.headers[import_util_retry3.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            const { response, output } = await next(args);
            retryStrategy.recordSuccess(retryToken);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalRetryDelay;
            return { response, output };
          } catch (e3) {
            const retryErrorInfo = getRetryErrorInfo(e3);
            lastError = asSdkError(e3);
            if (isRequest && (0, import_isStreamingPayload.isStreamingPayload)(request)) {
              (context.logger instanceof import_smithy_client25.NoOpLogger ? console : context.logger)?.warn(
                "An error was encountered in a non-retryable streaming request."
              );
              throw lastError;
            }
            try {
              retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
            } catch (refreshError) {
              if (!lastError.$metadata) {
                lastError.$metadata = {};
              }
              lastError.$metadata.attempts = attempts + 1;
              lastError.$metadata.totalRetryDelay = totalRetryDelay;
              throw lastError;
            }
            attempts = retryToken.getRetryCount();
            const delay = retryToken.getRetryDelay();
            totalRetryDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      } else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
          context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
      }
    }, "retryMiddleware");
    var isRetryStrategyV2 = /* @__PURE__ */ __name((retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", "isRetryStrategyV2");
    var getRetryErrorInfo = /* @__PURE__ */ __name((error) => {
      const errorInfo = {
        error,
        errorType: getRetryErrorType(error)
      };
      const retryAfterHint = getRetryAfterHint(error.$response);
      if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
      }
      return errorInfo;
    }, "getRetryErrorInfo");
    var getRetryErrorType = /* @__PURE__ */ __name((error) => {
      if ((0, import_service_error_classification.isThrottlingError)(error))
        return "THROTTLING";
      if ((0, import_service_error_classification.isTransientError)(error))
        return "TRANSIENT";
      if ((0, import_service_error_classification.isServerError)(error))
        return "SERVER_ERROR";
      return "CLIENT_ERROR";
    }, "getRetryErrorType");
    var retryMiddlewareOptions = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: true
    };
    var getRetryPlugin3 = /* @__PURE__ */ __name((options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
      }
    }), "getRetryPlugin");
    var getRetryAfterHint = /* @__PURE__ */ __name((response) => {
      if (!import_protocol_http11.HttpResponse.isInstance(response))
        return;
      const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1e3);
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate;
    }, "getRetryAfterHint");
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/auth/httpAuthSchemeProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveHttpAuthSchemeConfig = exports.defaultSecretsManagerHttpAuthSchemeProvider = exports.defaultSecretsManagerHttpAuthSchemeParametersProvider = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var util_middleware_1 = require_dist_cjs6();
    var defaultSecretsManagerHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    exports.defaultSecretsManagerHttpAuthSchemeParametersProvider = defaultSecretsManagerHttpAuthSchemeParametersProvider;
    function createAwsAuthSigv4HttpAuthOption3(authParameters) {
      return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
          name: "secretsmanager",
          region: authParameters.region
        },
        propertiesExtractor: (config, context) => ({
          signingProperties: {
            config,
            context
          }
        })
      };
    }
    var defaultSecretsManagerHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
        }
      }
      return options;
    };
    exports.defaultSecretsManagerHttpAuthSchemeProvider = defaultSecretsManagerHttpAuthSchemeProvider;
    var resolveHttpAuthSchemeConfig3 = (config) => {
      const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
      return {
        ...config_0
      };
    };
    exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig3;
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d3, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __rest(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t3[p3[i3]] = s3[p3[i3]];
    }
  return t3;
}
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f3) {
    if (f3 !== void 0 && typeof f3 !== "function") throw new TypeError("Function expected");
    return f3;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    var context = {};
    for (var p3 in contextIn) context[p3] = p3 === "access" ? {} : contextIn[p3];
    for (var p3 in contextIn.access) context.access[p3] = contextIn.access[p3];
    context.addInitializer = function(f3) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f3 || null));
    };
    var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i3 = 0; i3 < initializers.length; i3++) {
    value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x3) {
  return typeof x3 === "symbol" ? x3 : "".concat(x3);
}
function __setFunctionName(f3, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f3, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f3, y2, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v6) {
      return step([n3, v6]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_2 = 0)), _2) try {
      if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done) return t3;
      if (y2 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f3 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m3, o3) {
  for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p3)) __createBinding(o3, m3, p3);
}
function __values(o3) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
  if (m3) return m3.call(o3);
  if (o3 && typeof o3.length === "number") return {
    next: function() {
      if (o3 && i3 >= o3.length) o3 = void 0;
      return { value: o3 && o3[i3++], done: !o3 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n3) {
  var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m3) return o3;
  var i3 = m3.call(o3), r3, ar = [], e3;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r3 = i3.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i3["return"])) m3.call(i3);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
    ar = ar.concat(__read(arguments[i3]));
  return ar;
}
function __spreadArrays() {
  for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++) s3 += arguments[i3].length;
  for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
    for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
      r3[k3] = a3[j3];
  return r3;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v6) {
  return this instanceof __await ? (this.v = v6, this) : new __await(v6);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i3, q3 = [];
  return i3 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function awaitReturn(f3) {
    return function(v6) {
      return Promise.resolve(v6).then(f3, reject);
    };
  }
  function verb(n3, f3) {
    if (g3[n3]) {
      i3[n3] = function(v6) {
        return new Promise(function(a3, b3) {
          q3.push([n3, v6, a3, b3]) > 1 || resume(n3, v6);
        });
      };
      if (f3) i3[n3] = f3(i3[n3]);
    }
  }
  function resume(n3, v6) {
    try {
      step(g3[n3](v6));
    } catch (e3) {
      settle(q3[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v6) {
    if (f3(v6), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i3, p3;
  return i3 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i3[Symbol.iterator] = function() {
    return this;
  }, i3;
  function verb(n3, f3) {
    i3[n3] = o3[n3] ? function(v6) {
      return (p3 = !p3) ? { value: __await(o3[n3](v6)), done: false } : f3 ? f3(v6) : v6;
    } : f3;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o3[Symbol.asyncIterator], i3;
  return m3 ? m3.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n3) {
    i3[n3] = o3[n3] && function(v6) {
      return new Promise(function(resolve, reject) {
        v6 = o3[n3](v6), settle(resolve, reject, v6.done, v6.value);
      });
    };
  }
  function settle(resolve, reject, d3, v6) {
    Promise.resolve(v6).then(function(v7) {
      resolve({ value: v7, done: d3 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k3 = ownKeys(mod), i3 = 0; i3 < k3.length; i3++) if (k3[i3] !== "default") __createBinding(result, mod, k3[i3]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, state2, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state2.get(receiver);
}
function __classPrivateFieldSet2(receiver, state2, value, kind, f3) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e3) {
        return Promise.reject(e3);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e3) {
    env.error = env.hasError ? new _SuppressedError(e3, env.error, "An error was suppressed during disposal.") : e3;
    env.hasError = true;
  }
  var r3, s3 = 0;
  function next() {
    while (r3 = env.stack.pop()) {
      try {
        if (!r3.async && s3 === 1) return s3 = 0, env.stack.push(r3), Promise.resolve().then(next);
        if (r3.dispose) {
          var result = r3.dispose.call(r3.value);
          if (r3.async) return s3 |= 2, Promise.resolve(result).then(next, function(e3) {
            fail(e3);
            return next();
          });
        } else s3 |= 1;
      } catch (e3) {
        fail(e3);
      }
    }
    if (s3 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m3, tsx, d3, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d3 && (!ext || !cm) ? m3 : d3 + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d3, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
        d4.__proto__ = b4;
      } || function(d4, b4) {
        for (var p3 in b4) if (Object.prototype.hasOwnProperty.call(b4, p3)) d4[p3] = b4[p3];
      };
      return extendStatics(d3, b3);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3)) t3[p3] = s3[p3];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0) k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m3, k3);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k3];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0) k22 = k3;
      o3[k22] = m3[k3];
    };
    __setModuleDefault = Object.create ? function(o3, v6) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v6 });
    } : function(o3, v6) {
      o3["default"] = v6;
    };
    ownKeys = function(o3) {
      ownKeys = Object.getOwnPropertyNames || function(o4) {
        var ar = [];
        for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
        return ar;
      };
      return ownKeys(o3);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e3 = new Error(message);
      return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet: __classPrivateFieldGet2,
      __classPrivateFieldSet: __classPrivateFieldSet2,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@aws-sdk/client-secrets-manager/package.json
var require_package2 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/package.json"(exports, module) {
    module.exports = {
      name: "@aws-sdk/client-secrets-manager",
      description: "AWS SDK for JavaScript Secrets Manager Client for Node.js, Browser and React Native",
      version: "3.772.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-secrets-manager",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo secrets-manager"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.758.0",
        "@aws-sdk/credential-provider-node": "3.772.0",
        "@aws-sdk/middleware-host-header": "3.734.0",
        "@aws-sdk/middleware-logger": "3.734.0",
        "@aws-sdk/middleware-recursion-detection": "3.772.0",
        "@aws-sdk/middleware-user-agent": "3.758.0",
        "@aws-sdk/region-config-resolver": "3.734.0",
        "@aws-sdk/types": "3.734.0",
        "@aws-sdk/util-endpoints": "3.743.0",
        "@aws-sdk/util-user-agent-browser": "3.734.0",
        "@aws-sdk/util-user-agent-node": "3.758.0",
        "@smithy/config-resolver": "^4.0.1",
        "@smithy/core": "^3.1.5",
        "@smithy/fetch-http-handler": "^5.0.1",
        "@smithy/hash-node": "^4.0.1",
        "@smithy/invalid-dependency": "^4.0.1",
        "@smithy/middleware-content-length": "^4.0.1",
        "@smithy/middleware-endpoint": "^4.0.6",
        "@smithy/middleware-retry": "^4.0.7",
        "@smithy/middleware-serde": "^4.0.2",
        "@smithy/middleware-stack": "^4.0.1",
        "@smithy/node-config-provider": "^4.0.1",
        "@smithy/node-http-handler": "^4.0.3",
        "@smithy/protocol-http": "^5.0.1",
        "@smithy/smithy-client": "^4.1.6",
        "@smithy/types": "^4.1.0",
        "@smithy/url-parser": "^4.0.1",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.7",
        "@smithy/util-defaults-mode-node": "^4.0.7",
        "@smithy/util-endpoints": "^3.0.1",
        "@smithy/util-middleware": "^4.0.1",
        "@smithy/util-retry": "^4.0.1",
        "@smithy/util-utf8": "^4.0.0",
        "@types/uuid": "^9.0.1",
        tslib: "^2.6.2",
        uuid: "^9.0.1"
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.2.2"
      },
      engines: {
        node: ">=18.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-secrets-manager",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-secrets-manager"
      }
    };
  }
});

// node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js
var require_dist_cjs36 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      ENV_ACCOUNT_ID: () => ENV_ACCOUNT_ID,
      ENV_CREDENTIAL_SCOPE: () => ENV_CREDENTIAL_SCOPE,
      ENV_EXPIRATION: () => ENV_EXPIRATION,
      ENV_KEY: () => ENV_KEY,
      ENV_SECRET: () => ENV_SECRET,
      ENV_SESSION: () => ENV_SESSION,
      fromEnv: () => fromEnv
    });
    module.exports = __toCommonJS2(src_exports);
    var import_client3 = (init_client(), __toCommonJS(client_exports));
    var import_property_provider2 = require_dist_cjs20();
    var ENV_KEY = "AWS_ACCESS_KEY_ID";
    var ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
    var ENV_SESSION = "AWS_SESSION_TOKEN";
    var ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
    var ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
    var ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
    var fromEnv = /* @__PURE__ */ __name((init) => async () => {
      init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      const accessKeyId = process.env[ENV_KEY];
      const secretAccessKey = process.env[ENV_SECRET];
      const sessionToken = process.env[ENV_SESSION];
      const expiry = process.env[ENV_EXPIRATION];
      const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
      const accountId = process.env[ENV_ACCOUNT_ID];
      if (accessKeyId && secretAccessKey) {
        const credentials = {
          accessKeyId,
          secretAccessKey,
          ...sessionToken && { sessionToken },
          ...expiry && { expiration: new Date(expiry) },
          ...credentialScope && { credentialScope },
          ...accountId && { accountId }
        };
        (0, import_client3.setCredentialFeature)(credentials, "CREDENTIALS_ENV_VARS", "g");
        return credentials;
      }
      throw new import_property_provider2.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
    }, "fromEnv");
  }
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs37 = __commonJS({
  "node_modules/@smithy/credential-provider-imds/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      DEFAULT_MAX_RETRIES: () => DEFAULT_MAX_RETRIES,
      DEFAULT_TIMEOUT: () => DEFAULT_TIMEOUT,
      ENV_CMDS_AUTH_TOKEN: () => ENV_CMDS_AUTH_TOKEN,
      ENV_CMDS_FULL_URI: () => ENV_CMDS_FULL_URI,
      ENV_CMDS_RELATIVE_URI: () => ENV_CMDS_RELATIVE_URI,
      Endpoint: () => Endpoint,
      fromContainerMetadata: () => fromContainerMetadata,
      fromInstanceMetadata: () => fromInstanceMetadata,
      getInstanceMetadataEndpoint: () => getInstanceMetadataEndpoint,
      httpRequest: () => httpRequest,
      providerConfigFromInit: () => providerConfigFromInit
    });
    module.exports = __toCommonJS2(src_exports);
    var import_url8 = __require("url");
    var import_property_provider2 = require_dist_cjs20();
    var import_buffer2 = __require("buffer");
    var import_http = __require("http");
    function httpRequest(options) {
      return new Promise((resolve, reject) => {
        const req = (0, import_http.request)({
          method: "GET",
          ...options,
          // Node.js http module doesn't accept hostname with square brackets
          // Refs: https://github.com/nodejs/node/issues/39738
          hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
        });
        req.on("error", (err) => {
          reject(Object.assign(new import_property_provider2.ProviderError("Unable to connect to instance metadata service"), err));
          req.destroy();
        });
        req.on("timeout", () => {
          reject(new import_property_provider2.ProviderError("TimeoutError from instance metadata service"));
          req.destroy();
        });
        req.on("response", (res) => {
          const { statusCode = 400 } = res;
          if (statusCode < 200 || 300 <= statusCode) {
            reject(
              Object.assign(new import_property_provider2.ProviderError("Error response received from instance metadata service"), { statusCode })
            );
            req.destroy();
          }
          const chunks = [];
          res.on("data", (chunk) => {
            chunks.push(chunk);
          });
          res.on("end", () => {
            resolve(import_buffer2.Buffer.concat(chunks));
            req.destroy();
          });
        });
        req.end();
      });
    }
    __name(httpRequest, "httpRequest");
    var isImdsCredentials = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", "isImdsCredentials");
    var fromImdsCredentials = /* @__PURE__ */ __name((creds) => ({
      accessKeyId: creds.AccessKeyId,
      secretAccessKey: creds.SecretAccessKey,
      sessionToken: creds.Token,
      expiration: new Date(creds.Expiration),
      ...creds.AccountId && { accountId: creds.AccountId }
    }), "fromImdsCredentials");
    var DEFAULT_TIMEOUT = 1e3;
    var DEFAULT_MAX_RETRIES = 0;
    var providerConfigFromInit = /* @__PURE__ */ __name(({
      maxRetries = DEFAULT_MAX_RETRIES,
      timeout = DEFAULT_TIMEOUT
    }) => ({ maxRetries, timeout }), "providerConfigFromInit");
    var retry = /* @__PURE__ */ __name((toRetry, maxRetries) => {
      let promise = toRetry();
      for (let i3 = 0; i3 < maxRetries; i3++) {
        promise = promise.catch(toRetry);
      }
      return promise;
    }, "retry");
    var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var fromContainerMetadata = /* @__PURE__ */ __name((init = {}) => {
      const { timeout, maxRetries } = providerConfigFromInit(init);
      return () => retry(async () => {
        const requestOptions = await getCmdsUri({ logger: init.logger });
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!isImdsCredentials(credsResponse)) {
          throw new import_property_provider2.CredentialsProviderError("Invalid response received from instance metadata service.", {
            logger: init.logger
          });
        }
        return fromImdsCredentials(credsResponse);
      }, maxRetries);
    }, "fromContainerMetadata");
    var requestFromEcsImds = /* @__PURE__ */ __name(async (timeout, options) => {
      if (process.env[ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
          ...options.headers,
          Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
        };
      }
      const buffer = await httpRequest({
        ...options,
        timeout
      });
      return buffer.toString();
    }, "requestFromEcsImds");
    var CMDS_IP = "169.254.170.2";
    var GREENGRASS_HOSTS = {
      localhost: true,
      "127.0.0.1": true
    };
    var GREENGRASS_PROTOCOLS = {
      "http:": true,
      "https:": true
    };
    var getCmdsUri = /* @__PURE__ */ __name(async ({ logger }) => {
      if (process.env[ENV_CMDS_RELATIVE_URI]) {
        return {
          hostname: CMDS_IP,
          path: process.env[ENV_CMDS_RELATIVE_URI]
        };
      }
      if (process.env[ENV_CMDS_FULL_URI]) {
        const parsed = (0, import_url8.parse)(process.env[ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
          throw new import_property_provider2.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
            tryNextLink: false,
            logger
          });
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
          throw new import_property_provider2.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
            tryNextLink: false,
            logger
          });
        }
        return {
          ...parsed,
          port: parsed.port ? parseInt(parsed.port, 10) : void 0
        };
      }
      throw new import_property_provider2.CredentialsProviderError(
        `The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`,
        {
          tryNextLink: false,
          logger
        }
      );
    }, "getCmdsUri");
    var InstanceMetadataV1FallbackError = class _InstanceMetadataV1FallbackError extends import_property_provider2.CredentialsProviderError {
      constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "InstanceMetadataV1FallbackError";
        Object.setPrototypeOf(this, _InstanceMetadataV1FallbackError.prototype);
      }
      static {
        __name(this, "InstanceMetadataV1FallbackError");
      }
    };
    var import_node_config_provider3 = require_dist_cjs29();
    var import_url_parser3 = require_dist_cjs31();
    var Endpoint = /* @__PURE__ */ ((Endpoint2) => {
      Endpoint2["IPv4"] = "http://169.254.169.254";
      Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
      return Endpoint2;
    })(Endpoint || {});
    var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
    var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
    var ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
      default: void 0
    };
    var EndpointMode = /* @__PURE__ */ ((EndpointMode2) => {
      EndpointMode2["IPv4"] = "IPv4";
      EndpointMode2["IPv6"] = "IPv6";
      return EndpointMode2;
    })(EndpointMode || {});
    var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
    var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
    var ENDPOINT_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
      default: "IPv4"
      /* IPv4 */
    };
    var getInstanceMetadataEndpoint = /* @__PURE__ */ __name(async () => (0, import_url_parser3.parseUrl)(await getFromEndpointConfig() || await getFromEndpointModeConfig()), "getInstanceMetadataEndpoint");
    var getFromEndpointConfig = /* @__PURE__ */ __name(async () => (0, import_node_config_provider3.loadConfig)(ENDPOINT_CONFIG_OPTIONS)(), "getFromEndpointConfig");
    var getFromEndpointModeConfig = /* @__PURE__ */ __name(async () => {
      const endpointMode = await (0, import_node_config_provider3.loadConfig)(ENDPOINT_MODE_CONFIG_OPTIONS)();
      switch (endpointMode) {
        case "IPv4":
          return "http://169.254.169.254";
        case "IPv6":
          return "http://[fd00:ec2::254]";
        default:
          throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
      }
    }, "getFromEndpointModeConfig");
    var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
    var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
    var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
    var getExtendedInstanceMetadataCredentials = /* @__PURE__ */ __name((credentials, logger) => {
      const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
      const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
      logger.warn(
        `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL
      );
      const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
      return {
        ...credentials,
        ...originalExpiration ? { originalExpiration } : {},
        expiration: newExpiration
      };
    }, "getExtendedInstanceMetadataCredentials");
    var staticStabilityProvider = /* @__PURE__ */ __name((provider, options = {}) => {
      const logger = options?.logger || console;
      let pastCredentials;
      return async () => {
        let credentials;
        try {
          credentials = await provider();
          if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
            credentials = getExtendedInstanceMetadataCredentials(credentials, logger);
          }
        } catch (e3) {
          if (pastCredentials) {
            logger.warn("Credential renew failed: ", e3);
            credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger);
          } else {
            throw e3;
          }
        }
        pastCredentials = credentials;
        return credentials;
      };
    }, "staticStabilityProvider");
    var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
    var IMDS_TOKEN_PATH = "/latest/api/token";
    var AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
    var PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
    var X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
    var fromInstanceMetadata = /* @__PURE__ */ __name((init = {}) => staticStabilityProvider(getInstanceMetadataProvider(init), { logger: init.logger }), "fromInstanceMetadata");
    var getInstanceMetadataProvider = /* @__PURE__ */ __name((init = {}) => {
      let disableFetchToken = false;
      const { logger, profile } = init;
      const { timeout, maxRetries } = providerConfigFromInit(init);
      const getCredentials = /* @__PURE__ */ __name(async (maxRetries2, options) => {
        const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
        if (isImdsV1Fallback) {
          let fallbackBlockedFromProfile = false;
          let fallbackBlockedFromProcessEnv = false;
          const configValue = await (0, import_node_config_provider3.loadConfig)(
            {
              environmentVariableSelector: (env) => {
                const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
                fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
                if (envValue === void 0) {
                  throw new import_property_provider2.CredentialsProviderError(
                    `${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`,
                    { logger: init.logger }
                  );
                }
                return fallbackBlockedFromProcessEnv;
              },
              configFileSelector: (profile2) => {
                const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
                fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
                return fallbackBlockedFromProfile;
              },
              default: false
            },
            {
              profile
            }
          )();
          if (init.ec2MetadataV1Disabled || configValue) {
            const causes = [];
            if (init.ec2MetadataV1Disabled)
              causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
            if (fallbackBlockedFromProfile)
              causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
            if (fallbackBlockedFromProcessEnv)
              causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
            throw new InstanceMetadataV1FallbackError(
              `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(
                ", "
              )}].`
            );
          }
        }
        const imdsProfile = (await retry(async () => {
          let profile2;
          try {
            profile2 = await getProfile(options);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return profile2;
        }, maxRetries2)).trim();
        return retry(async () => {
          let creds;
          try {
            creds = await getCredentialsFromProfile(imdsProfile, options, init);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return creds;
        }, maxRetries2);
      }, "getCredentials");
      return async () => {
        const endpoint = await getInstanceMetadataEndpoint();
        if (disableFetchToken) {
          logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
          return getCredentials(maxRetries, { ...endpoint, timeout });
        } else {
          let token;
          try {
            token = (await getMetadataToken({ ...endpoint, timeout })).toString();
          } catch (error) {
            if (error?.statusCode === 400) {
              throw Object.assign(error, {
                message: "EC2 Metadata token request returned error"
              });
            } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
              disableFetchToken = true;
            }
            logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
            return getCredentials(maxRetries, { ...endpoint, timeout });
          }
          return getCredentials(maxRetries, {
            ...endpoint,
            headers: {
              [X_AWS_EC2_METADATA_TOKEN]: token
            },
            timeout
          });
        }
      };
    }, "getInstanceMetadataProvider");
    var getMetadataToken = /* @__PURE__ */ __name(async (options) => httpRequest({
      ...options,
      path: IMDS_TOKEN_PATH,
      method: "PUT",
      headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600"
      }
    }), "getMetadataToken");
    var getProfile = /* @__PURE__ */ __name(async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString(), "getProfile");
    var getCredentialsFromProfile = /* @__PURE__ */ __name(async (profile, options, init) => {
      const credentialsResponse = JSON.parse(
        (await httpRequest({
          ...options,
          path: IMDS_PATH + profile
        })).toString()
      );
      if (!isImdsCredentials(credentialsResponse)) {
        throw new import_property_provider2.CredentialsProviderError("Invalid response received from instance metadata service.", {
          logger: init.logger
        });
      }
      return fromImdsCredentials(credentialsResponse);
    }, "getCredentialsFromProfile");
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js
var require_checkUrl = __commonJS({
  "node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkUrl = void 0;
    var property_provider_1 = require_dist_cjs20();
    var ECS_CONTAINER_HOST = "169.254.170.2";
    var EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
    var EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
    var checkUrl = (url, logger) => {
      if (url.protocol === "https:") {
        return;
      }
      if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
        return;
      }
      if (url.hostname.includes("[")) {
        if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
          return;
        }
      } else {
        if (url.hostname === "localhost") {
          return;
        }
        const ipComponents = url.hostname.split(".");
        const inRange = (component) => {
          const num = parseInt(component, 10);
          return 0 <= num && num <= 255;
        };
        if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
          return;
        }
      }
      throw new property_provider_1.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });
    };
    exports.checkUrl = checkUrl;
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js
var require_requestHelpers = __commonJS({
  "node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCredentials = exports.createGetRequest = void 0;
    var property_provider_1 = require_dist_cjs20();
    var protocol_http_1 = require_dist_cjs2();
    var smithy_client_1 = require_dist_cjs23();
    var util_stream_1 = require_dist_cjs17();
    function createGetRequest(url) {
      return new protocol_http_1.HttpRequest({
        protocol: url.protocol,
        hostname: url.hostname,
        port: Number(url.port),
        path: url.pathname,
        query: Array.from(url.searchParams.entries()).reduce((acc, [k3, v6]) => {
          acc[k3] = v6;
          return acc;
        }, {}),
        fragment: url.hash
      });
    }
    exports.createGetRequest = createGetRequest;
    async function getCredentials(response, logger) {
      const stream2 = (0, util_stream_1.sdkStreamMixin)(response.body);
      const str = await stream2.transformToString();
      if (response.statusCode === 200) {
        const parsed = JSON.parse(str);
        if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
          throw new property_provider_1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger });
        }
        return {
          accessKeyId: parsed.AccessKeyId,
          secretAccessKey: parsed.SecretAccessKey,
          sessionToken: parsed.Token,
          expiration: (0, smithy_client_1.parseRfc3339DateTime)(parsed.Expiration)
        };
      }
      if (response.statusCode >= 400 && response.statusCode < 500) {
        let parsedBody = {};
        try {
          parsedBody = JSON.parse(str);
        } catch (e3) {
        }
        throw Object.assign(new property_provider_1.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {
          Code: parsedBody.Code,
          Message: parsedBody.Message
        });
      }
      throw new property_provider_1.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });
    }
    exports.getCredentials = getCredentials;
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js
var require_retry_wrapper = __commonJS({
  "node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryWrapper = void 0;
    var retryWrapper = (toRetry, maxRetries, delayMs) => {
      return async () => {
        for (let i3 = 0; i3 < maxRetries; ++i3) {
          try {
            return await toRetry();
          } catch (e3) {
            await new Promise((resolve) => setTimeout(resolve, delayMs));
          }
        }
        return await toRetry();
      };
    };
    exports.retryWrapper = retryWrapper;
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js
var require_fromHttp = __commonJS({
  "node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromHttp = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var client_1 = (init_client(), __toCommonJS(client_exports));
    var node_http_handler_1 = require_dist_cjs14();
    var property_provider_1 = require_dist_cjs20();
    var promises_1 = tslib_1.__importDefault(__require("fs/promises"));
    var checkUrl_1 = require_checkUrl();
    var requestHelpers_1 = require_requestHelpers();
    var retry_wrapper_1 = require_retry_wrapper();
    var AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2";
    var AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE";
    var AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var fromHttp = (options = {}) => {
      options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let host;
      const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
      const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
      const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
      const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
      const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger ? console.warn : options.logger.warn;
      if (relative && full) {
        warn("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
        warn("awsContainerCredentialsFullUri will take precedence.");
      }
      if (token && tokenFile) {
        warn("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
        warn("awsContainerAuthorizationToken will take precedence.");
      }
      if (full) {
        host = full;
      } else if (relative) {
        host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
      } else {
        throw new property_provider_1.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
      }
      const url = new URL(host);
      (0, checkUrl_1.checkUrl)(url, options.logger);
      const requestHandler = new node_http_handler_1.NodeHttpHandler({
        requestTimeout: options.timeout ?? 1e3,
        connectionTimeout: options.timeout ?? 1e3
      });
      return (0, retry_wrapper_1.retryWrapper)(async () => {
        const request = (0, requestHelpers_1.createGetRequest)(url);
        if (token) {
          request.headers.Authorization = token;
        } else if (tokenFile) {
          request.headers.Authorization = (await promises_1.default.readFile(tokenFile)).toString();
        }
        try {
          const result = await requestHandler.handle(request);
          return (0, requestHelpers_1.getCredentials)(result.response).then((creds) => (0, client_1.setCredentialFeature)(creds, "CREDENTIALS_HTTP", "z"));
        } catch (e3) {
          throw new property_provider_1.CredentialsProviderError(String(e3), { logger: options.logger });
        }
      }, options.maxRetries ?? 3, options.timeout ?? 1e3);
    };
    exports.fromHttp = fromHttp;
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js
var require_dist_cjs38 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromHttp = void 0;
    var fromHttp_1 = require_fromHttp();
    Object.defineProperty(exports, "fromHttp", { enumerable: true, get: function() {
      return fromHttp_1.fromHttp;
    } });
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider2 = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/auth/httpAuthSchemeProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveHttpAuthSchemeConfig = exports.defaultSSOHttpAuthSchemeProvider = exports.defaultSSOHttpAuthSchemeParametersProvider = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var util_middleware_1 = require_dist_cjs6();
    var defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    exports.defaultSSOHttpAuthSchemeParametersProvider = defaultSSOHttpAuthSchemeParametersProvider;
    function createAwsAuthSigv4HttpAuthOption3(authParameters) {
      return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
          name: "awsssoportal",
          region: authParameters.region
        },
        propertiesExtractor: (config, context) => ({
          signingProperties: {
            config,
            context
          }
        })
      };
    }
    function createSmithyApiNoAuthHttpAuthOption3(authParameters) {
      return {
        schemeId: "smithy.api#noAuth"
      };
    }
    var defaultSSOHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "GetRoleCredentials": {
          options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
          break;
        }
        case "ListAccountRoles": {
          options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
          break;
        }
        case "ListAccounts": {
          options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
          break;
        }
        case "Logout": {
          options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
        }
      }
      return options;
    };
    exports.defaultSSOHttpAuthSchemeProvider = defaultSSOHttpAuthSchemeProvider;
    var resolveHttpAuthSchemeConfig3 = (config) => {
      const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
      return {
        ...config_0
      };
    };
    exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig3;
  }
});

// node_modules/@aws-sdk/client-sso/package.json
var require_package3 = __commonJS({
  "node_modules/@aws-sdk/client-sso/package.json"(exports, module) {
    module.exports = {
      name: "@aws-sdk/client-sso",
      description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.772.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-sso",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.758.0",
        "@aws-sdk/middleware-host-header": "3.734.0",
        "@aws-sdk/middleware-logger": "3.734.0",
        "@aws-sdk/middleware-recursion-detection": "3.772.0",
        "@aws-sdk/middleware-user-agent": "3.758.0",
        "@aws-sdk/region-config-resolver": "3.734.0",
        "@aws-sdk/types": "3.734.0",
        "@aws-sdk/util-endpoints": "3.743.0",
        "@aws-sdk/util-user-agent-browser": "3.734.0",
        "@aws-sdk/util-user-agent-node": "3.758.0",
        "@smithy/config-resolver": "^4.0.1",
        "@smithy/core": "^3.1.5",
        "@smithy/fetch-http-handler": "^5.0.1",
        "@smithy/hash-node": "^4.0.1",
        "@smithy/invalid-dependency": "^4.0.1",
        "@smithy/middleware-content-length": "^4.0.1",
        "@smithy/middleware-endpoint": "^4.0.6",
        "@smithy/middleware-retry": "^4.0.7",
        "@smithy/middleware-serde": "^4.0.2",
        "@smithy/middleware-stack": "^4.0.1",
        "@smithy/node-config-provider": "^4.0.1",
        "@smithy/node-http-handler": "^4.0.3",
        "@smithy/protocol-http": "^5.0.1",
        "@smithy/smithy-client": "^4.1.6",
        "@smithy/types": "^4.1.0",
        "@smithy/url-parser": "^4.0.1",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.7",
        "@smithy/util-defaults-mode-node": "^4.0.7",
        "@smithy/util-endpoints": "^3.0.1",
        "@smithy/util-middleware": "^4.0.1",
        "@smithy/util-retry": "^4.0.1",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.2.2"
      },
      engines: {
        node: ">=18.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso"
      }
    };
  }
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs39 = __commonJS({
  "node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      NODE_APP_ID_CONFIG_OPTIONS: () => NODE_APP_ID_CONFIG_OPTIONS3,
      UA_APP_ID_ENV_NAME: () => UA_APP_ID_ENV_NAME,
      UA_APP_ID_INI_NAME: () => UA_APP_ID_INI_NAME,
      createDefaultUserAgentProvider: () => createDefaultUserAgentProvider3,
      crtAvailability: () => crtAvailability,
      defaultUserAgent: () => defaultUserAgent
    });
    module.exports = __toCommonJS2(src_exports);
    var import_os = __require("os");
    var import_process = __require("process");
    var crtAvailability = {
      isCrtAvailable: false
    };
    var isCrtAvailable = /* @__PURE__ */ __name(() => {
      if (crtAvailability.isCrtAvailable) {
        return ["md/crt-avail"];
      }
      return null;
    }, "isCrtAvailable");
    var createDefaultUserAgentProvider3 = /* @__PURE__ */ __name(({ serviceId, clientVersion }) => {
      return async (config) => {
        const sections = [
          // sdk-metadata
          ["aws-sdk-js", clientVersion],
          // ua-metadata
          ["ua", "2.1"],
          // os-metadata
          [`os/${(0, import_os.platform)()}`, (0, import_os.release)()],
          // language-metadata
          // ECMAScript edition doesn't matter in JS, so no version needed.
          ["lang/js"],
          ["md/nodejs", `${import_process.versions.node}`]
        ];
        const crtAvailable = isCrtAvailable();
        if (crtAvailable) {
          sections.push(crtAvailable);
        }
        if (serviceId) {
          sections.push([`api/${serviceId}`, clientVersion]);
        }
        if (import_process.env.AWS_EXECUTION_ENV) {
          sections.push([`exec-env/${import_process.env.AWS_EXECUTION_ENV}`]);
        }
        const appId = await config?.userAgentAppId?.();
        const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        return resolvedUserAgent;
      };
    }, "createDefaultUserAgentProvider");
    var defaultUserAgent = createDefaultUserAgentProvider3;
    var import_middleware_user_agent3 = require_dist_cjs24();
    var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
    var UA_APP_ID_INI_NAME = "sdk_ua_app_id";
    var UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
    var NODE_APP_ID_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env2) => env2[UA_APP_ID_ENV_NAME],
      configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
      default: import_middleware_user_agent3.DEFAULT_UA_APP_ID
    };
  }
});

// node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs40 = __commonJS({
  "node_modules/@smithy/hash-node/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Hash: () => Hash3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_buffer_from = require_dist_cjs9();
    var import_util_utf83 = require_dist_cjs10();
    var import_buffer2 = __require("buffer");
    var import_crypto10 = __require("crypto");
    var Hash3 = class {
      static {
        __name(this, "Hash");
      }
      constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
      }
      update(toHash, encoding) {
        this.hash.update((0, import_util_utf83.toUint8Array)(castSourceData(toHash, encoding)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret ? (0, import_crypto10.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, import_crypto10.createHash)(this.algorithmIdentifier);
      }
    };
    function castSourceData(toCast, encoding) {
      if (import_buffer2.Buffer.isBuffer(toCast)) {
        return toCast;
      }
      if (typeof toCast === "string") {
        return (0, import_util_buffer_from.fromString)(toCast, encoding);
      }
      if (ArrayBuffer.isView(toCast)) {
        return (0, import_util_buffer_from.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
      }
      return (0, import_util_buffer_from.fromArrayBuffer)(toCast);
    }
    __name(castSourceData, "castSourceData");
  }
});

// node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs41 = __commonJS({
  "node_modules/@smithy/util-body-length-node/dist-cjs/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      calculateBodyLength: () => calculateBodyLength3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_fs = __require("fs");
    var calculateBodyLength3 = /* @__PURE__ */ __name((body) => {
      if (!body) {
        return 0;
      }
      if (typeof body === "string") {
        return Buffer.byteLength(body);
      } else if (typeof body.byteLength === "number") {
        return body.byteLength;
      } else if (typeof body.size === "number") {
        return body.size;
      } else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
      } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, import_fs.lstatSync)(body.path).size;
      } else if (typeof body.fd === "number") {
        return (0, import_fs.fstatSync)(body.fd).size;
      }
      throw new Error(`Body Length computation failed for ${body}`);
    }, "calculateBodyLength");
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js
var require_ruleset = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ruleSet = void 0;
    var u3 = "required";
    var v6 = "fn";
    var w3 = "argv";
    var x3 = "ref";
    var a3 = true;
    var b3 = "isSet";
    var c3 = "booleanEquals";
    var d3 = "error";
    var e3 = "endpoint";
    var f3 = "tree";
    var g3 = "PartitionResult";
    var h3 = "getAttr";
    var i3 = { [u3]: false, "type": "String" };
    var j3 = { [u3]: true, "default": false, "type": "Boolean" };
    var k3 = { [x3]: "Endpoint" };
    var l3 = { [v6]: c3, [w3]: [{ [x3]: "UseFIPS" }, true] };
    var m3 = { [v6]: c3, [w3]: [{ [x3]: "UseDualStack" }, true] };
    var n3 = {};
    var o3 = { [v6]: h3, [w3]: [{ [x3]: g3 }, "supportsFIPS"] };
    var p3 = { [x3]: g3 };
    var q3 = { [v6]: c3, [w3]: [true, { [v6]: h3, [w3]: [p3, "supportsDualStack"] }] };
    var r3 = [l3];
    var s3 = [m3];
    var t3 = [{ [x3]: "Region" }];
    var _data3 = { version: "1.0", parameters: { Region: i3, UseDualStack: j3, UseFIPS: j3, Endpoint: i3 }, rules: [{ conditions: [{ [v6]: b3, [w3]: [k3] }], rules: [{ conditions: r3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d3 }, { conditions: s3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d3 }, { endpoint: { url: k3, properties: n3, headers: n3 }, type: e3 }], type: f3 }, { conditions: [{ [v6]: b3, [w3]: t3 }], rules: [{ conditions: [{ [v6]: "aws.partition", [w3]: t3, assign: g3 }], rules: [{ conditions: [l3, m3], rules: [{ conditions: [{ [v6]: c3, [w3]: [a3, o3] }, q3], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d3 }], type: f3 }, { conditions: r3, rules: [{ conditions: [{ [v6]: c3, [w3]: [o3, a3] }], rules: [{ conditions: [{ [v6]: "stringEquals", [w3]: [{ [v6]: h3, [w3]: [p3, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n3, headers: n3 }, type: e3 }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d3 }], type: f3 }, { conditions: s3, rules: [{ conditions: [q3], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d3 }], type: f3 }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }], type: f3 }, { error: "Invalid Configuration: Missing Region", type: d3 }] };
    exports.ruleSet = _data3;
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultEndpointResolver = void 0;
    var util_endpoints_1 = require_dist_cjs19();
    var util_endpoints_2 = require_dist_cjs18();
    var ruleset_1 = require_ruleset();
    var cache3 = new util_endpoints_2.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    var defaultEndpointResolver3 = (endpointParams, context = {}) => {
      return cache3.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    exports.defaultEndpointResolver = defaultEndpointResolver3;
    util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRuntimeConfig = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var core_2 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var smithy_client_1 = require_dist_cjs23();
    var url_parser_1 = require_dist_cjs31();
    var util_base64_1 = require_dist_cjs11();
    var util_utf8_1 = require_dist_cjs10();
    var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
    var endpointResolver_1 = require_endpointResolver();
    var getRuntimeConfig5 = (config) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new core_1.AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new core_2.NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
      };
    };
    exports.getRuntimeConfig = getRuntimeConfig5;
  }
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs42 = __commonJS({
  "node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js"(exports, module) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      resolveDefaultsModeConfig: () => resolveDefaultsModeConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var import_config_resolver5 = require_dist_cjs26();
    var import_node_config_provider3 = require_dist_cjs29();
    var import_property_provider2 = require_dist_cjs20();
    var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
    var AWS_REGION_ENV = "AWS_REGION";
    var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
    var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
    var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
    var IMDS_REGION_PATH = "/latest/meta-data/placement/region";
    var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
    var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
    var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
      },
      configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
      },
      default: "legacy"
    };
    var resolveDefaultsModeConfig3 = /* @__PURE__ */ __name(({
      region = (0, import_node_config_provider3.loadConfig)(import_config_resolver5.NODE_REGION_CONFIG_OPTIONS),
      defaultsMode = (0, import_node_config_provider3.loadConfig)(NODE_DEFAULTS_MODE_CONFIG_OPTIONS)
    } = {}) => (0, import_property_provider2.memoize)(async () => {
      const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
      switch (mode?.toLowerCase()) {
        case "auto":
          return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
          return Promise.resolve(mode?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw new Error(
            `Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`
          );
      }
    }), "resolveDefaultsModeConfig");
    var resolveNodeDefaultsModeAuto = /* @__PURE__ */ __name(async (clientRegion) => {
      if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
          return "standard";
        }
        if (resolvedRegion === inferredRegion) {
          return "in-region";
        } else {
          return "cross-region";
        }
      }
      return "standard";
    }, "resolveNodeDefaultsModeAuto");
    var inferPhysicalRegion = /* @__PURE__ */ __name(async () => {
      if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
      }
      if (!process.env[ENV_IMDS_DISABLED]) {
        try {
          const { getInstanceMetadataEndpoint, httpRequest } = await Promise.resolve().then(() => __toESM2(require_dist_cjs37()));
          const endpoint = await getInstanceMetadataEndpoint();
          return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        } catch (e3) {
        }
      }
    }, "inferPhysicalRegion");
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js
var require_runtimeConfig = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRuntimeConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var package_json_1 = tslib_1.__importDefault(require_package3());
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var util_user_agent_node_1 = require_dist_cjs39();
    var config_resolver_1 = require_dist_cjs26();
    var hash_node_1 = require_dist_cjs40();
    var middleware_retry_1 = require_dist_cjs35();
    var node_config_provider_1 = require_dist_cjs29();
    var node_http_handler_1 = require_dist_cjs14();
    var util_body_length_node_1 = require_dist_cjs41();
    var util_retry_1 = require_dist_cjs34();
    var runtimeConfig_shared_1 = require_runtimeConfig_shared();
    var smithy_client_1 = require_dist_cjs23();
    var util_defaults_mode_node_1 = require_dist_cjs42();
    var smithy_client_2 = require_dist_cjs23();
    var getRuntimeConfig5 = (config) => {
      (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
      const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
      (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
      const profileConfig = { profile: config?.profile };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
        requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
          ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
      };
    };
    exports.getRuntimeConfig = getRuntimeConfig5;
  }
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs43 = __commonJS({
  "node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      NODE_REGION_CONFIG_FILE_OPTIONS: () => NODE_REGION_CONFIG_FILE_OPTIONS3,
      NODE_REGION_CONFIG_OPTIONS: () => NODE_REGION_CONFIG_OPTIONS3,
      REGION_ENV_NAME: () => REGION_ENV_NAME,
      REGION_INI_NAME: () => REGION_INI_NAME,
      getAwsRegionExtensionConfiguration: () => getAwsRegionExtensionConfiguration3,
      resolveAwsRegionExtensionConfiguration: () => resolveAwsRegionExtensionConfiguration3,
      resolveRegionConfig: () => resolveRegionConfig3
    });
    module.exports = __toCommonJS2(src_exports);
    var getAwsRegionExtensionConfiguration3 = /* @__PURE__ */ __name((runtimeConfig) => {
      let runtimeConfigRegion = /* @__PURE__ */ __name(async () => {
        if (runtimeConfig.region === void 0) {
          throw new Error("Region is missing from runtimeConfig");
        }
        const region = runtimeConfig.region;
        if (typeof region === "string") {
          return region;
        }
        return region();
      }, "runtimeConfigRegion");
      return {
        setRegion(region) {
          runtimeConfigRegion = region;
        },
        region() {
          return runtimeConfigRegion;
        }
      };
    }, "getAwsRegionExtensionConfiguration");
    var resolveAwsRegionExtensionConfiguration3 = /* @__PURE__ */ __name((awsRegionExtensionConfiguration) => {
      return {
        region: awsRegionExtensionConfiguration.region()
      };
    }, "resolveAwsRegionExtensionConfiguration");
    var REGION_ENV_NAME = "AWS_REGION";
    var REGION_INI_NAME = "region";
    var NODE_REGION_CONFIG_OPTIONS3 = {
      environmentVariableSelector: (env) => env[REGION_ENV_NAME],
      configFileSelector: (profile) => profile[REGION_INI_NAME],
      default: () => {
        throw new Error("Region is missing");
      }
    };
    var NODE_REGION_CONFIG_FILE_OPTIONS3 = {
      preferredFile: "credentials"
    };
    var isFipsRegion = /* @__PURE__ */ __name((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");
    var getRealRegion = /* @__PURE__ */ __name((region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");
    var resolveRegionConfig3 = /* @__PURE__ */ __name((input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return {
        ...input,
        region: async () => {
          if (typeof region === "string") {
            return getRealRegion(region);
          }
          const providedRegion = await region();
          return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      };
    }, "resolveRegionConfig");
  }
});

// node_modules/@aws-sdk/client-sso/dist-cjs/index.js
var require_dist_cjs44 = __commonJS({
  "node_modules/@aws-sdk/client-sso/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      GetRoleCredentialsCommand: () => GetRoleCredentialsCommand,
      GetRoleCredentialsRequestFilterSensitiveLog: () => GetRoleCredentialsRequestFilterSensitiveLog,
      GetRoleCredentialsResponseFilterSensitiveLog: () => GetRoleCredentialsResponseFilterSensitiveLog,
      InvalidRequestException: () => InvalidRequestException2,
      ListAccountRolesCommand: () => ListAccountRolesCommand,
      ListAccountRolesRequestFilterSensitiveLog: () => ListAccountRolesRequestFilterSensitiveLog,
      ListAccountsCommand: () => ListAccountsCommand,
      ListAccountsRequestFilterSensitiveLog: () => ListAccountsRequestFilterSensitiveLog,
      LogoutCommand: () => LogoutCommand,
      LogoutRequestFilterSensitiveLog: () => LogoutRequestFilterSensitiveLog,
      ResourceNotFoundException: () => ResourceNotFoundException,
      RoleCredentialsFilterSensitiveLog: () => RoleCredentialsFilterSensitiveLog,
      SSO: () => SSO,
      SSOClient: () => SSOClient,
      SSOServiceException: () => SSOServiceException,
      TooManyRequestsException: () => TooManyRequestsException,
      UnauthorizedException: () => UnauthorizedException,
      __Client: () => import_smithy_client25.Client,
      paginateListAccountRoles: () => paginateListAccountRoles,
      paginateListAccounts: () => paginateListAccounts
    });
    module.exports = __toCommonJS2(index_exports);
    var import_middleware_host_header3 = require_dist_cjs3();
    var import_middleware_logger3 = require_dist_cjs4();
    var import_middleware_recursion_detection3 = require_dist_cjs5();
    var import_middleware_user_agent3 = require_dist_cjs24();
    var import_config_resolver5 = require_dist_cjs26();
    var import_core17 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var import_middleware_content_length3 = require_dist_cjs27();
    var import_middleware_endpoint6 = require_dist_cjs32();
    var import_middleware_retry5 = require_dist_cjs35();
    var import_httpAuthSchemeProvider5 = require_httpAuthSchemeProvider2();
    var resolveClientEndpointParameters3 = /* @__PURE__ */ __name((options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal"
      };
    }, "resolveClientEndpointParameters");
    var commonParams3 = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
    var import_runtimeConfig5 = require_runtimeConfig();
    var import_region_config_resolver3 = require_dist_cjs43();
    var import_protocol_http11 = require_dist_cjs2();
    var import_smithy_client25 = require_dist_cjs23();
    var getHttpAuthExtensionConfiguration3 = /* @__PURE__ */ __name((runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    }, "getHttpAuthExtensionConfiguration");
    var resolveHttpAuthRuntimeConfig3 = /* @__PURE__ */ __name((config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    }, "resolveHttpAuthRuntimeConfig");
    var asPartial3 = /* @__PURE__ */ __name((t3) => t3, "asPartial");
    var resolveRuntimeExtensions3 = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
      const extensionConfiguration = {
        ...asPartial3((0, import_region_config_resolver3.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial3((0, import_smithy_client25.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial3((0, import_protocol_http11.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
        ...asPartial3(getHttpAuthExtensionConfiguration3(runtimeConfig))
      };
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return {
        ...runtimeConfig,
        ...(0, import_region_config_resolver3.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, import_smithy_client25.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, import_protocol_http11.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig3(extensionConfiguration)
      };
    }, "resolveRuntimeExtensions");
    var SSOClient = class extends import_smithy_client25.Client {
      static {
        __name(this, "SSOClient");
      }
      /**
       * The resolved configuration of SSOClient class. This is resolved and normalized from the {@link SSOClientConfig | constructor configuration interface}.
       */
      config;
      constructor(...[configuration]) {
        const _config_0 = (0, import_runtimeConfig5.getRuntimeConfig)(configuration || {});
        const _config_1 = resolveClientEndpointParameters3(_config_0);
        const _config_2 = (0, import_middleware_user_agent3.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry5.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver5.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header3.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint6.resolveEndpointConfig)(_config_5);
        const _config_7 = (0, import_httpAuthSchemeProvider5.resolveHttpAuthSchemeConfig)(_config_6);
        const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, import_middleware_user_agent3.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry5.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length3.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header3.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger3.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection3.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(
          (0, import_core17.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: import_httpAuthSchemeProvider5.defaultSSOHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: /* @__PURE__ */ __name(async (config) => new import_core17.DefaultIdentityProviderConfig({
              "aws.auth#sigv4": config.credentials
            }), "identityProviderConfigProvider")
          })
        );
        this.middlewareStack.use((0, import_core17.getHttpSigningPlugin)(this.config));
      }
      /**
       * Destroy underlying resources, like sockets. It's usually not necessary to do this.
       * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
       * Otherwise, sockets might stay open for quite a long time before the server terminates them.
       */
      destroy() {
        super.destroy();
      }
    };
    var import_middleware_serde5 = require_dist_cjs7();
    var SSOServiceException = class _SSOServiceException extends import_smithy_client25.ServiceException {
      static {
        __name(this, "SSOServiceException");
      }
      /**
       * @internal
       */
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOServiceException.prototype);
      }
    };
    var InvalidRequestException2 = class _InvalidRequestException extends SSOServiceException {
      static {
        __name(this, "InvalidRequestException");
      }
      name = "InvalidRequestException";
      $fault = "client";
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
      }
    };
    var ResourceNotFoundException = class _ResourceNotFoundException extends SSOServiceException {
      static {
        __name(this, "ResourceNotFoundException");
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
      }
    };
    var TooManyRequestsException = class _TooManyRequestsException extends SSOServiceException {
      static {
        __name(this, "TooManyRequestsException");
      }
      name = "TooManyRequestsException";
      $fault = "client";
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
      }
    };
    var UnauthorizedException = class _UnauthorizedException extends SSOServiceException {
      static {
        __name(this, "UnauthorizedException");
      }
      name = "UnauthorizedException";
      $fault = "client";
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnauthorizedException.prototype);
      }
    };
    var GetRoleCredentialsRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: import_smithy_client25.SENSITIVE_STRING }
    }), "GetRoleCredentialsRequestFilterSensitiveLog");
    var RoleCredentialsFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.secretAccessKey && { secretAccessKey: import_smithy_client25.SENSITIVE_STRING },
      ...obj.sessionToken && { sessionToken: import_smithy_client25.SENSITIVE_STRING }
    }), "RoleCredentialsFilterSensitiveLog");
    var GetRoleCredentialsResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
    }), "GetRoleCredentialsResponseFilterSensitiveLog");
    var ListAccountRolesRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: import_smithy_client25.SENSITIVE_STRING }
    }), "ListAccountRolesRequestFilterSensitiveLog");
    var ListAccountsRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: import_smithy_client25.SENSITIVE_STRING }
    }), "ListAccountsRequestFilterSensitiveLog");
    var LogoutRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: import_smithy_client25.SENSITIVE_STRING }
    }), "LogoutRequestFilterSensitiveLog");
    var import_core22 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var se_GetRoleCredentialsCommand = /* @__PURE__ */ __name(async (input, context) => {
      const b3 = (0, import_core17.requestBuilder)(input, context);
      const headers = (0, import_smithy_client25.map)({}, import_smithy_client25.isSerializableHeaderValue, {
        [_xasbt]: input[_aT]
      });
      b3.bp("/federation/credentials");
      const query = (0, import_smithy_client25.map)({
        [_rn]: [, (0, import_smithy_client25.expectNonNull)(input[_rN], `roleName`)],
        [_ai]: [, (0, import_smithy_client25.expectNonNull)(input[_aI], `accountId`)]
      });
      let body;
      b3.m("GET").h(headers).q(query).b(body);
      return b3.build();
    }, "se_GetRoleCredentialsCommand");
    var se_ListAccountRolesCommand = /* @__PURE__ */ __name(async (input, context) => {
      const b3 = (0, import_core17.requestBuilder)(input, context);
      const headers = (0, import_smithy_client25.map)({}, import_smithy_client25.isSerializableHeaderValue, {
        [_xasbt]: input[_aT]
      });
      b3.bp("/assignment/roles");
      const query = (0, import_smithy_client25.map)({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_ai]: [, (0, import_smithy_client25.expectNonNull)(input[_aI], `accountId`)]
      });
      let body;
      b3.m("GET").h(headers).q(query).b(body);
      return b3.build();
    }, "se_ListAccountRolesCommand");
    var se_ListAccountsCommand = /* @__PURE__ */ __name(async (input, context) => {
      const b3 = (0, import_core17.requestBuilder)(input, context);
      const headers = (0, import_smithy_client25.map)({}, import_smithy_client25.isSerializableHeaderValue, {
        [_xasbt]: input[_aT]
      });
      b3.bp("/assignment/accounts");
      const query = (0, import_smithy_client25.map)({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()]
      });
      let body;
      b3.m("GET").h(headers).q(query).b(body);
      return b3.build();
    }, "se_ListAccountsCommand");
    var se_LogoutCommand = /* @__PURE__ */ __name(async (input, context) => {
      const b3 = (0, import_core17.requestBuilder)(input, context);
      const headers = (0, import_smithy_client25.map)({}, import_smithy_client25.isSerializableHeaderValue, {
        [_xasbt]: input[_aT]
      });
      b3.bp("/logout");
      let body;
      b3.m("POST").h(headers).b(body);
      return b3.build();
    }, "se_LogoutCommand");
    var de_GetRoleCredentialsCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const contents = (0, import_smithy_client25.map)({
        $metadata: deserializeMetadata3(output)
      });
      const data = (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.expectObject)(await (0, import_core22.parseJsonBody)(output.body, context)), "body");
      const doc = (0, import_smithy_client25.take)(data, {
        roleCredentials: import_smithy_client25._json
      });
      Object.assign(contents, doc);
      return contents;
    }, "de_GetRoleCredentialsCommand");
    var de_ListAccountRolesCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const contents = (0, import_smithy_client25.map)({
        $metadata: deserializeMetadata3(output)
      });
      const data = (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.expectObject)(await (0, import_core22.parseJsonBody)(output.body, context)), "body");
      const doc = (0, import_smithy_client25.take)(data, {
        nextToken: import_smithy_client25.expectString,
        roleList: import_smithy_client25._json
      });
      Object.assign(contents, doc);
      return contents;
    }, "de_ListAccountRolesCommand");
    var de_ListAccountsCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const contents = (0, import_smithy_client25.map)({
        $metadata: deserializeMetadata3(output)
      });
      const data = (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.expectObject)(await (0, import_core22.parseJsonBody)(output.body, context)), "body");
      const doc = (0, import_smithy_client25.take)(data, {
        accountList: import_smithy_client25._json,
        nextToken: import_smithy_client25.expectString
      });
      Object.assign(contents, doc);
      return contents;
    }, "de_ListAccountsCommand");
    var de_LogoutCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const contents = (0, import_smithy_client25.map)({
        $metadata: deserializeMetadata3(output)
      });
      await (0, import_smithy_client25.collectBody)(output.body, context);
      return contents;
    }, "de_LogoutCommand");
    var de_CommandError3 = /* @__PURE__ */ __name(async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await (0, import_core22.parseJsonErrorBody)(output.body, context)
      };
      const errorCode = (0, import_core22.loadRestJsonErrorCode)(output, parsedOutput.body);
      switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await de_InvalidRequestExceptionRes2(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError3({
            output,
            parsedBody,
            errorCode
          });
      }
    }, "de_CommandError");
    var throwDefaultError3 = (0, import_smithy_client25.withBaseException)(SSOServiceException);
    var de_InvalidRequestExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const contents = (0, import_smithy_client25.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client25.take)(data, {
        message: import_smithy_client25.expectString
      });
      Object.assign(contents, doc);
      const exception = new InvalidRequestException2({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, parsedOutput.body);
    }, "de_InvalidRequestExceptionRes");
    var de_ResourceNotFoundExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const contents = (0, import_smithy_client25.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client25.take)(data, {
        message: import_smithy_client25.expectString
      });
      Object.assign(contents, doc);
      const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, parsedOutput.body);
    }, "de_ResourceNotFoundExceptionRes");
    var de_TooManyRequestsExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const contents = (0, import_smithy_client25.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client25.take)(data, {
        message: import_smithy_client25.expectString
      });
      Object.assign(contents, doc);
      const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, parsedOutput.body);
    }, "de_TooManyRequestsExceptionRes");
    var de_UnauthorizedExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const contents = (0, import_smithy_client25.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client25.take)(data, {
        message: import_smithy_client25.expectString
      });
      Object.assign(contents, doc);
      const exception = new UnauthorizedException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, parsedOutput.body);
    }, "de_UnauthorizedExceptionRes");
    var deserializeMetadata3 = /* @__PURE__ */ __name((output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    }), "deserializeMetadata");
    var _aI = "accountId";
    var _aT = "accessToken";
    var _ai = "account_id";
    var _mR = "maxResults";
    var _mr = "max_result";
    var _nT = "nextToken";
    var _nt = "next_token";
    var _rN = "roleName";
    var _rn = "role_name";
    var _xasbt = "x-amz-sso_bearer_token";
    var GetRoleCredentialsCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog).ser(se_GetRoleCredentialsCommand).de(de_GetRoleCredentialsCommand).build() {
      static {
        __name(this, "GetRoleCredentialsCommand");
      }
    };
    var ListAccountRolesCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(ListAccountRolesRequestFilterSensitiveLog, void 0).ser(se_ListAccountRolesCommand).de(de_ListAccountRolesCommand).build() {
      static {
        __name(this, "ListAccountRolesCommand");
      }
    };
    var ListAccountsCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(ListAccountsRequestFilterSensitiveLog, void 0).ser(se_ListAccountsCommand).de(de_ListAccountsCommand).build() {
      static {
        __name(this, "ListAccountsCommand");
      }
    };
    var LogoutCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(LogoutRequestFilterSensitiveLog, void 0).ser(se_LogoutCommand).de(de_LogoutCommand).build() {
      static {
        __name(this, "LogoutCommand");
      }
    };
    var commands3 = {
      GetRoleCredentialsCommand,
      ListAccountRolesCommand,
      ListAccountsCommand,
      LogoutCommand
    };
    var SSO = class extends SSOClient {
      static {
        __name(this, "SSO");
      }
    };
    (0, import_smithy_client25.createAggregatedClient)(commands3, SSO);
    var paginateListAccountRoles = (0, import_core17.createPaginator)(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
    var paginateListAccounts = (0, import_core17.createPaginator)(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sso-oauth",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_util_middleware3, defaultSSOOIDCHttpAuthSchemeParametersProvider, defaultSSOOIDCHttpAuthSchemeProvider, resolveHttpAuthSchemeConfig;
var init_httpAuthSchemeProvider = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthSchemeProvider.js"() {
    init_dist_es2();
    import_util_middleware3 = __toESM(require_dist_cjs6());
    defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, import_util_middleware3.getSmithyContext)(context).operation,
        region: await (0, import_util_middleware3.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "CreateToken": {
          options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
      }
      return options;
    };
    resolveHttpAuthSchemeConfig = (config) => {
      const config_0 = resolveAwsSdkSigV4Config(config);
      return {
        ...config_0
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/EndpointParameters.js
var resolveClientEndpointParameters, commonParams;
var init_EndpointParameters = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/EndpointParameters.js"() {
    resolveClientEndpointParameters = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "sso-oauth"
      };
    };
    commonParams = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/package.json
var package_default;
var init_package = __esm({
  "node_modules/@aws-sdk/nested-clients/package.json"() {
    package_default = {
      name: "@aws-sdk/nested-clients",
      version: "3.772.0",
      description: "Nested clients for AWS SDK packages.",
      main: "./dist-cjs/index.js",
      module: "./dist-es/index.js",
      types: "./dist-types/index.d.ts",
      scripts: {
        build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline nested-clients",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
        test: "yarn g:vitest run",
        "test:watch": "yarn g:vitest watch"
      },
      engines: {
        node: ">=18.0.0"
      },
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.758.0",
        "@aws-sdk/middleware-host-header": "3.734.0",
        "@aws-sdk/middleware-logger": "3.734.0",
        "@aws-sdk/middleware-recursion-detection": "3.772.0",
        "@aws-sdk/middleware-user-agent": "3.758.0",
        "@aws-sdk/region-config-resolver": "3.734.0",
        "@aws-sdk/types": "3.734.0",
        "@aws-sdk/util-endpoints": "3.743.0",
        "@aws-sdk/util-user-agent-browser": "3.734.0",
        "@aws-sdk/util-user-agent-node": "3.758.0",
        "@smithy/config-resolver": "^4.0.1",
        "@smithy/core": "^3.1.5",
        "@smithy/fetch-http-handler": "^5.0.1",
        "@smithy/hash-node": "^4.0.1",
        "@smithy/invalid-dependency": "^4.0.1",
        "@smithy/middleware-content-length": "^4.0.1",
        "@smithy/middleware-endpoint": "^4.0.6",
        "@smithy/middleware-retry": "^4.0.7",
        "@smithy/middleware-serde": "^4.0.2",
        "@smithy/middleware-stack": "^4.0.1",
        "@smithy/node-config-provider": "^4.0.1",
        "@smithy/node-http-handler": "^4.0.3",
        "@smithy/protocol-http": "^5.0.1",
        "@smithy/smithy-client": "^4.1.6",
        "@smithy/types": "^4.1.0",
        "@smithy/url-parser": "^4.0.1",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.7",
        "@smithy/util-defaults-mode-node": "^4.0.7",
        "@smithy/util-endpoints": "^3.0.1",
        "@smithy/util-middleware": "^4.0.1",
        "@smithy/util-retry": "^4.0.1",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.2.2"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "./sso-oidc.d.ts",
        "./sso-oidc.js",
        "./sts.d.ts",
        "./sts.js",
        "dist-*/**"
      ],
      browser: {
        "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
        "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
      },
      "react-native": {},
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "packages/nested-clients"
      },
      exports: {
        "./sso-oidc": {
          module: "./dist-es/submodules/sso-oidc/index.js",
          node: "./dist-cjs/submodules/sso-oidc/index.js",
          import: "./dist-es/submodules/sso-oidc/index.js",
          require: "./dist-cjs/submodules/sso-oidc/index.js",
          types: "./dist-types/submodules/sso-oidc/index.d.ts"
        },
        "./sts": {
          module: "./dist-es/submodules/sts/index.js",
          node: "./dist-cjs/submodules/sts/index.js",
          import: "./dist-es/submodules/sts/index.js",
          require: "./dist-cjs/submodules/sts/index.js",
          types: "./dist-types/submodules/sts/index.d.ts"
        }
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/ruleset.js
var u, v, w, x, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, _data, ruleSet;
var init_ruleset = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/ruleset.js"() {
    u = "required";
    v = "fn";
    w = "argv";
    x = "ref";
    a = true;
    b = "isSet";
    c = "booleanEquals";
    d = "error";
    e = "endpoint";
    f = "tree";
    g = "PartitionResult";
    h = "getAttr";
    i = { [u]: false, "type": "String" };
    j = { [u]: true, "default": false, "type": "Boolean" };
    k = { [x]: "Endpoint" };
    l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
    m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
    n = {};
    o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
    p = { [x]: g };
    q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
    r = [l];
    s = [m];
    t = [{ [x]: "Region" }];
    _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
    ruleSet = _data;
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/endpointResolver.js
var import_util_endpoints, import_util_endpoints2, cache, defaultEndpointResolver;
var init_endpointResolver = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/endpointResolver.js"() {
    import_util_endpoints = __toESM(require_dist_cjs19());
    import_util_endpoints2 = __toESM(require_dist_cjs18());
    init_ruleset();
    cache = new import_util_endpoints2.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    defaultEndpointResolver = (endpointParams, context = {}) => {
      return cache.get(endpointParams, () => (0, import_util_endpoints2.resolveEndpoint)(ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    import_util_endpoints2.customEndpointFunctions.aws = import_util_endpoints.awsEndpointFunctions;
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.shared.js
var import_smithy_client4, import_url_parser, import_util_base64, import_util_utf8, getRuntimeConfig;
var init_runtimeConfig_shared = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.shared.js"() {
    init_dist_es2();
    init_dist_es();
    import_smithy_client4 = __toESM(require_dist_cjs23());
    import_url_parser = __toESM(require_dist_cjs31());
    import_util_base64 = __toESM(require_dist_cjs11());
    import_util_utf8 = __toESM(require_dist_cjs10());
    init_httpAuthSchemeProvider();
    init_endpointResolver();
    getRuntimeConfig = (config) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? import_util_base64.fromBase64,
        base64Encoder: config?.base64Encoder ?? import_util_base64.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new import_smithy_client4.NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO OIDC",
        urlParser: config?.urlParser ?? import_url_parser.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? import_util_utf8.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? import_util_utf8.toUtf8
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.js
var import_util_user_agent_node, import_config_resolver, import_hash_node, import_middleware_retry, import_node_config_provider, import_node_http_handler, import_util_body_length_node, import_util_retry, import_smithy_client5, import_util_defaults_mode_node, import_smithy_client6, getRuntimeConfig2;
var init_runtimeConfig = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.js"() {
    init_package();
    init_dist_es2();
    import_util_user_agent_node = __toESM(require_dist_cjs39());
    import_config_resolver = __toESM(require_dist_cjs26());
    import_hash_node = __toESM(require_dist_cjs40());
    import_middleware_retry = __toESM(require_dist_cjs35());
    import_node_config_provider = __toESM(require_dist_cjs29());
    import_node_http_handler = __toESM(require_dist_cjs14());
    import_util_body_length_node = __toESM(require_dist_cjs41());
    import_util_retry = __toESM(require_dist_cjs34());
    init_runtimeConfig_shared();
    import_smithy_client5 = __toESM(require_dist_cjs23());
    import_util_defaults_mode_node = __toESM(require_dist_cjs42());
    import_smithy_client6 = __toESM(require_dist_cjs23());
    getRuntimeConfig2 = (config) => {
      (0, import_smithy_client6.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, import_util_defaults_mode_node.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(import_smithy_client5.loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig(config);
      emitWarningIfUnsupportedVersion(process.version);
      const profileConfig = { profile: config?.profile };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_util_user_agent_node.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        maxAttempts: config?.maxAttempts ?? (0, import_node_config_provider.loadConfig)(import_middleware_retry.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
        requestHandler: import_node_http_handler.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, import_node_config_provider.loadConfig)({
          ...import_middleware_retry.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || import_util_retry.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? import_hash_node.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? import_node_http_handler.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, import_node_config_provider.loadConfig)(import_util_user_agent_node.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig;
var init_httpAuthExtensionConfiguration = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.js"() {
    getHttpAuthExtensionConfiguration = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeExtensions.js
var import_region_config_resolver, import_protocol_http8, import_smithy_client7, asPartial, resolveRuntimeExtensions;
var init_runtimeExtensions = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeExtensions.js"() {
    import_region_config_resolver = __toESM(require_dist_cjs43());
    import_protocol_http8 = __toESM(require_dist_cjs2());
    import_smithy_client7 = __toESM(require_dist_cjs23());
    init_httpAuthExtensionConfiguration();
    asPartial = (t3) => t3;
    resolveRuntimeExtensions = (runtimeConfig, extensions) => {
      const extensionConfiguration = {
        ...asPartial((0, import_region_config_resolver.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, import_smithy_client7.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, import_protocol_http8.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
      };
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return {
        ...runtimeConfig,
        ...(0, import_region_config_resolver.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, import_smithy_client7.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, import_protocol_http8.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDCClient.js
var import_middleware_host_header, import_middleware_logger, import_middleware_recursion_detection, import_middleware_user_agent, import_config_resolver2, import_middleware_content_length, import_middleware_endpoint, import_middleware_retry2, import_smithy_client8, SSOOIDCClient;
var init_SSOOIDCClient = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDCClient.js"() {
    import_middleware_host_header = __toESM(require_dist_cjs3());
    import_middleware_logger = __toESM(require_dist_cjs4());
    import_middleware_recursion_detection = __toESM(require_dist_cjs5());
    import_middleware_user_agent = __toESM(require_dist_cjs24());
    import_config_resolver2 = __toESM(require_dist_cjs26());
    init_dist_es();
    import_middleware_content_length = __toESM(require_dist_cjs27());
    import_middleware_endpoint = __toESM(require_dist_cjs32());
    import_middleware_retry2 = __toESM(require_dist_cjs35());
    import_smithy_client8 = __toESM(require_dist_cjs23());
    init_httpAuthSchemeProvider();
    init_EndpointParameters();
    init_runtimeConfig();
    init_runtimeExtensions();
    SSOOIDCClient = class extends import_smithy_client8.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig2(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0, import_middleware_user_agent.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry2.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver2.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint.resolveEndpointConfig)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, import_middleware_user_agent.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry2.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/SSOOIDCServiceException.js
var import_smithy_client9, SSOOIDCServiceException;
var init_SSOOIDCServiceException = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/SSOOIDCServiceException.js"() {
    import_smithy_client9 = __toESM(require_dist_cjs23());
    SSOOIDCServiceException = class _SSOOIDCServiceException extends import_smithy_client9.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/models_0.js
var import_smithy_client10, AccessDeniedException, AuthorizationPendingException, CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog, ExpiredTokenException, InternalServerException, InvalidClientException, InvalidGrantException, InvalidRequestException, InvalidScopeException, SlowDownException, UnauthorizedClientException, UnsupportedGrantTypeException;
var init_models_0 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/models_0.js"() {
    import_smithy_client10 = __toESM(require_dist_cjs23());
    init_SSOOIDCServiceException();
    AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    CreateTokenRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.clientSecret && { clientSecret: import_smithy_client10.SENSITIVE_STRING },
      ...obj.refreshToken && { refreshToken: import_smithy_client10.SENSITIVE_STRING },
      ...obj.codeVerifier && { codeVerifier: import_smithy_client10.SENSITIVE_STRING }
    });
    CreateTokenResponseFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: import_smithy_client10.SENSITIVE_STRING },
      ...obj.refreshToken && { refreshToken: import_smithy_client10.SENSITIVE_STRING },
      ...obj.idToken && { idToken: import_smithy_client10.SENSITIVE_STRING }
    });
    ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...opts
        });
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/protocols/Aws_restJson1.js
var import_smithy_client11, se_CreateTokenCommand, de_CreateTokenCommand, de_CommandError, throwDefaultError, de_AccessDeniedExceptionRes, de_AuthorizationPendingExceptionRes, de_ExpiredTokenExceptionRes, de_InternalServerExceptionRes, de_InvalidClientExceptionRes, de_InvalidGrantExceptionRes, de_InvalidRequestExceptionRes, de_InvalidScopeExceptionRes, de_SlowDownExceptionRes, de_UnauthorizedClientExceptionRes, de_UnsupportedGrantTypeExceptionRes, deserializeMetadata;
var init_Aws_restJson1 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/protocols/Aws_restJson1.js"() {
    init_dist_es2();
    init_dist_es();
    import_smithy_client11 = __toESM(require_dist_cjs23());
    init_models_0();
    init_SSOOIDCServiceException();
    se_CreateTokenCommand = async (input, context) => {
      const b3 = requestBuilder(input, context);
      const headers = {
        "content-type": "application/json"
      };
      b3.bp("/token");
      let body;
      body = JSON.stringify((0, import_smithy_client11.take)(input, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: (_2) => (0, import_smithy_client11._json)(_2)
      }));
      b3.m("POST").h(headers).b(body);
      return b3.build();
    };
    de_CreateTokenCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = (0, import_smithy_client11.map)({
        $metadata: deserializeMetadata(output)
      });
      const data = (0, import_smithy_client11.expectNonNull)((0, import_smithy_client11.expectObject)(await parseJsonBody(output.body, context)), "body");
      const doc = (0, import_smithy_client11.take)(data, {
        accessToken: import_smithy_client11.expectString,
        expiresIn: import_smithy_client11.expectInt32,
        idToken: import_smithy_client11.expectString,
        refreshToken: import_smithy_client11.expectString,
        tokenType: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      return contents;
    };
    de_CommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseJsonErrorBody(output.body, context)
      };
      const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await de_InvalidGrantExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError({
            output,
            parsedBody,
            errorCode
          });
      }
    };
    throwDefaultError = (0, import_smithy_client11.withBaseException)(SSOOIDCServiceException);
    de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new AuthorizationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_InternalServerExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_InvalidClientExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new InvalidClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new InvalidGrantException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new InvalidScopeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_SlowDownExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new SlowDownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
      const contents = (0, import_smithy_client11.map)({});
      const data = parsedOutput.body;
      const doc = (0, import_smithy_client11.take)(data, {
        error: import_smithy_client11.expectString,
        error_description: import_smithy_client11.expectString
      });
      Object.assign(contents, doc);
      const exception = new UnsupportedGrantTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
      });
      return (0, import_smithy_client11.decorateServiceException)(exception, parsedOutput.body);
    };
    deserializeMetadata = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/CreateTokenCommand.js
var import_middleware_endpoint2, import_middleware_serde2, import_smithy_client12, CreateTokenCommand;
var init_CreateTokenCommand = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/CreateTokenCommand.js"() {
    import_middleware_endpoint2 = __toESM(require_dist_cjs32());
    import_middleware_serde2 = __toESM(require_dist_cjs7());
    import_smithy_client12 = __toESM(require_dist_cjs23());
    init_EndpointParameters();
    init_models_0();
    init_Aws_restJson1();
    CreateTokenCommand = class extends import_smithy_client12.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde2.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint2.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog).ser(se_CreateTokenCommand).de(de_CreateTokenCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDC.js
var import_smithy_client13, commands, SSOOIDC;
var init_SSOOIDC = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDC.js"() {
    import_smithy_client13 = __toESM(require_dist_cjs23());
    init_CreateTokenCommand();
    init_SSOOIDCClient();
    commands = {
      CreateTokenCommand
    };
    SSOOIDC = class extends SSOOIDCClient {
    };
    (0, import_smithy_client13.createAggregatedClient)(commands, SSOOIDC);
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/index.js
var init_commands = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/index.js"() {
    init_CreateTokenCommand();
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/index.js
var init_models = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/index.js"() {
    init_models_0();
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/index.js
var sso_oidc_exports = {};
__export(sso_oidc_exports, {
  $Command: () => import_smithy_client12.Command,
  AccessDeniedException: () => AccessDeniedException,
  AuthorizationPendingException: () => AuthorizationPendingException,
  CreateTokenCommand: () => CreateTokenCommand,
  CreateTokenRequestFilterSensitiveLog: () => CreateTokenRequestFilterSensitiveLog,
  CreateTokenResponseFilterSensitiveLog: () => CreateTokenResponseFilterSensitiveLog,
  ExpiredTokenException: () => ExpiredTokenException,
  InternalServerException: () => InternalServerException,
  InvalidClientException: () => InvalidClientException,
  InvalidGrantException: () => InvalidGrantException,
  InvalidRequestException: () => InvalidRequestException,
  InvalidScopeException: () => InvalidScopeException,
  SSOOIDC: () => SSOOIDC,
  SSOOIDCClient: () => SSOOIDCClient,
  SSOOIDCServiceException: () => SSOOIDCServiceException,
  SlowDownException: () => SlowDownException,
  UnauthorizedClientException: () => UnauthorizedClientException,
  UnsupportedGrantTypeException: () => UnsupportedGrantTypeException,
  __Client: () => import_smithy_client8.Client
});
var init_sso_oidc = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/index.js"() {
    init_SSOOIDCClient();
    init_SSOOIDC();
    init_commands();
    init_models();
    init_SSOOIDCServiceException();
  }
});

// node_modules/@aws-sdk/token-providers/dist-cjs/index.js
var require_dist_cjs45 = __commonJS({
  "node_modules/@aws-sdk/token-providers/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      fromSso: () => fromSso,
      fromStatic: () => fromStatic,
      nodeProvider: () => nodeProvider
    });
    module.exports = __toCommonJS2(index_exports);
    var EXPIRE_WINDOW_MS = 5 * 60 * 1e3;
    var REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
    var getSsoOidcClient = /* @__PURE__ */ __name(async (ssoRegion, init = {}) => {
      const { SSOOIDCClient: SSOOIDCClient2 } = await Promise.resolve().then(() => __toESM2((init_sso_oidc(), __toCommonJS(sso_oidc_exports))));
      const ssoOidcClient = new SSOOIDCClient2(
        Object.assign({}, init.clientConfig ?? {}, {
          region: ssoRegion ?? init.clientConfig?.region,
          logger: init.clientConfig?.logger ?? init.parentClientConfig?.logger
        })
      );
      return ssoOidcClient;
    }, "getSsoOidcClient");
    var getNewSsoOidcToken = /* @__PURE__ */ __name(async (ssoToken, ssoRegion, init = {}) => {
      const { CreateTokenCommand: CreateTokenCommand2 } = await Promise.resolve().then(() => __toESM2((init_sso_oidc(), __toCommonJS(sso_oidc_exports))));
      const ssoOidcClient = await getSsoOidcClient(ssoRegion, init);
      return ssoOidcClient.send(
        new CreateTokenCommand2({
          clientId: ssoToken.clientId,
          clientSecret: ssoToken.clientSecret,
          refreshToken: ssoToken.refreshToken,
          grantType: "refresh_token"
        })
      );
    }, "getNewSsoOidcToken");
    var import_property_provider2 = require_dist_cjs20();
    var validateTokenExpiry = /* @__PURE__ */ __name((token) => {
      if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new import_property_provider2.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
      }
    }, "validateTokenExpiry");
    var validateTokenKey = /* @__PURE__ */ __name((key, value, forRefresh = false) => {
      if (typeof value === "undefined") {
        throw new import_property_provider2.TokenProviderError(
          `Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`,
          false
        );
      }
    }, "validateTokenKey");
    var import_shared_ini_file_loader = require_dist_cjs28();
    var import_fs = __require("fs");
    var { writeFile } = import_fs.promises;
    var writeSSOTokenToFile = /* @__PURE__ */ __name((id, ssoToken) => {
      const tokenFilepath = (0, import_shared_ini_file_loader.getSSOTokenFilepath)(id);
      const tokenString = JSON.stringify(ssoToken, null, 2);
      return writeFile(tokenFilepath, tokenString);
    }, "writeSSOTokenToFile");
    var lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
    var fromSso = /* @__PURE__ */ __name((_init = {}) => async ({ callerClientConfig } = {}) => {
      const init = {
        ..._init,
        parentClientConfig: {
          ...callerClientConfig,
          ..._init.parentClientConfig
        }
      };
      init.logger?.debug("@aws-sdk/token-providers - fromSso");
      const profiles = await (0, import_shared_ini_file_loader.parseKnownFiles)(init);
      const profileName = (0, import_shared_ini_file_loader.getProfileName)({
        profile: init.profile ?? callerClientConfig?.profile
      });
      const profile = profiles[profileName];
      if (!profile) {
        throw new import_property_provider2.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
      } else if (!profile["sso_session"]) {
        throw new import_property_provider2.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
      }
      const ssoSessionName = profile["sso_session"];
      const ssoSessions = await (0, import_shared_ini_file_loader.loadSsoSessionData)(init);
      const ssoSession = ssoSessions[ssoSessionName];
      if (!ssoSession) {
        throw new import_property_provider2.TokenProviderError(
          `Sso session '${ssoSessionName}' could not be found in shared credentials file.`,
          false
        );
      }
      for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
          throw new import_property_provider2.TokenProviderError(
            `Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`,
            false
          );
        }
      }
      const ssoStartUrl = ssoSession["sso_start_url"];
      const ssoRegion = ssoSession["sso_region"];
      let ssoToken;
      try {
        ssoToken = await (0, import_shared_ini_file_loader.getSSOTokenFromFile)(ssoSessionName);
      } catch (e3) {
        throw new import_property_provider2.TokenProviderError(
          `The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`,
          false
        );
      }
      validateTokenKey("accessToken", ssoToken.accessToken);
      validateTokenKey("expiresAt", ssoToken.expiresAt);
      const { accessToken, expiresAt } = ssoToken;
      const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
      if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
        return existingToken;
      }
      if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
      validateTokenKey("clientId", ssoToken.clientId, true);
      validateTokenKey("clientSecret", ssoToken.clientSecret, true);
      validateTokenKey("refreshToken", ssoToken.refreshToken, true);
      try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init);
        validateTokenKey("accessToken", newSsoOidcToken.accessToken);
        validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
        try {
          await writeSSOTokenToFile(ssoSessionName, {
            ...ssoToken,
            accessToken: newSsoOidcToken.accessToken,
            expiresAt: newTokenExpiration.toISOString(),
            refreshToken: newSsoOidcToken.refreshToken
          });
        } catch (error) {
        }
        return {
          token: newSsoOidcToken.accessToken,
          expiration: newTokenExpiration
        };
      } catch (error) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
    }, "fromSso");
    var fromStatic = /* @__PURE__ */ __name(({ token, logger }) => async () => {
      logger?.debug("@aws-sdk/token-providers - fromStatic");
      if (!token || !token.token) {
        throw new import_property_provider2.TokenProviderError(`Please pass a valid token to fromStatic`, false);
      }
      return token;
    }, "fromStatic");
    var nodeProvider = /* @__PURE__ */ __name((init = {}) => (0, import_property_provider2.memoize)(
      (0, import_property_provider2.chain)(fromSso(init), async () => {
        throw new import_property_provider2.TokenProviderError("Could not load token from any providers", false);
      }),
      (token) => token.expiration !== void 0 && token.expiration.getTime() - Date.now() < 3e5,
      (token) => token.expiration !== void 0
    ), "nodeProvider");
  }
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js
var require_dist_cjs46 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __esm2 = (fn, res) => function __init() {
      return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var loadSso_exports = {};
    __export2(loadSso_exports, {
      GetRoleCredentialsCommand: () => import_client_sso.GetRoleCredentialsCommand,
      SSOClient: () => import_client_sso.SSOClient
    });
    var import_client_sso;
    var init_loadSso = __esm2({
      "src/loadSso.ts"() {
        "use strict";
        import_client_sso = require_dist_cjs44();
      }
    });
    var index_exports = {};
    __export2(index_exports, {
      fromSSO: () => fromSSO,
      isSsoProfile: () => isSsoProfile,
      validateSsoProfile: () => validateSsoProfile
    });
    module.exports = __toCommonJS2(index_exports);
    var isSsoProfile = /* @__PURE__ */ __name((arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string"), "isSsoProfile");
    var import_client3 = (init_client(), __toCommonJS(client_exports));
    var import_token_providers = require_dist_cjs45();
    var import_property_provider2 = require_dist_cjs20();
    var import_shared_ini_file_loader = require_dist_cjs28();
    var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
    var resolveSSOCredentials = /* @__PURE__ */ __name(async ({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      clientConfig,
      parentClientConfig,
      profile,
      logger
    }) => {
      let token;
      const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
      if (ssoSession) {
        try {
          const _token = await (0, import_token_providers.fromSso)({ profile })();
          token = {
            accessToken: _token.token,
            expiresAt: new Date(_token.expiration).toISOString()
          };
        } catch (e3) {
          throw new import_property_provider2.CredentialsProviderError(e3.message, {
            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
            logger
          });
        }
      } else {
        try {
          token = await (0, import_shared_ini_file_loader.getSSOTokenFromFile)(ssoStartUrl);
        } catch (e3) {
          throw new import_property_provider2.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
            logger
          });
        }
      }
      if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
        throw new import_property_provider2.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger
        });
      }
      const { accessToken } = token;
      const { SSOClient: SSOClient2, GetRoleCredentialsCommand: GetRoleCredentialsCommand2 } = await Promise.resolve().then(() => (init_loadSso(), loadSso_exports));
      const sso = ssoClient || new SSOClient2(
        Object.assign({}, clientConfig ?? {}, {
          logger: clientConfig?.logger ?? parentClientConfig?.logger,
          region: clientConfig?.region ?? ssoRegion
        })
      );
      let ssoResp;
      try {
        ssoResp = await sso.send(
          new GetRoleCredentialsCommand2({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken
          })
        );
      } catch (e3) {
        throw new import_property_provider2.CredentialsProviderError(e3, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger
        });
      }
      const {
        roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {}
      } = ssoResp;
      if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new import_property_provider2.CredentialsProviderError("SSO returns an invalid temporary credential.", {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger
        });
      }
      const credentials = {
        accessKeyId,
        secretAccessKey,
        sessionToken,
        expiration: new Date(expiration),
        ...credentialScope && { credentialScope },
        ...accountId && { accountId }
      };
      if (ssoSession) {
        (0, import_client3.setCredentialFeature)(credentials, "CREDENTIALS_SSO", "s");
      } else {
        (0, import_client3.setCredentialFeature)(credentials, "CREDENTIALS_SSO_LEGACY", "u");
      }
      return credentials;
    }, "resolveSSOCredentials");
    var validateSsoProfile = /* @__PURE__ */ __name((profile, logger) => {
      const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
      if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new import_property_provider2.CredentialsProviderError(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(
            ", "
          )}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: false, logger }
        );
      }
      return profile;
    }, "validateSsoProfile");
    var fromSSO = /* @__PURE__ */ __name((init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
      const { ssoClient } = init;
      const profileName = (0, import_shared_ini_file_loader.getProfileName)({
        profile: init.profile ?? callerClientConfig?.profile
      });
      if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await (0, import_shared_ini_file_loader.parseKnownFiles)(init);
        const profile = profiles[profileName];
        if (!profile) {
          throw new import_property_provider2.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init.logger });
        }
        if (!isSsoProfile(profile)) {
          throw new import_property_provider2.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
            logger: init.logger
          });
        }
        if (profile?.sso_session) {
          const ssoSessions = await (0, import_shared_ini_file_loader.loadSsoSessionData)(init);
          const session = ssoSessions[profile.sso_session];
          const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
          if (ssoRegion && ssoRegion !== session.sso_region) {
            throw new import_property_provider2.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
              tryNextLink: false,
              logger: init.logger
            });
          }
          if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
            throw new import_property_provider2.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
              tryNextLink: false,
              logger: init.logger
            });
          }
          profile.sso_region = session.sso_region;
          profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(
          profile,
          init.logger
        );
        return resolveSSOCredentials({
          ssoStartUrl: sso_start_url,
          ssoSession: sso_session,
          ssoAccountId: sso_account_id,
          ssoRegion: sso_region,
          ssoRoleName: sso_role_name,
          ssoClient,
          clientConfig: init.clientConfig,
          parentClientConfig: init.parentClientConfig,
          profile: profileName
        });
      } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new import_property_provider2.CredentialsProviderError(
          'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
          { tryNextLink: false, logger: init.logger }
        );
      } else {
        return resolveSSOCredentials({
          ssoStartUrl,
          ssoSession,
          ssoAccountId,
          ssoRegion,
          ssoRoleName,
          ssoClient,
          clientConfig: init.clientConfig,
          parentClientConfig: init.parentClientConfig,
          profile: profileName
        });
      }
    }, "fromSSO");
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption2(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sts",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_util_middleware4, defaultSTSHttpAuthSchemeParametersProvider, defaultSTSHttpAuthSchemeProvider, resolveStsAuthConfig, resolveHttpAuthSchemeConfig2;
var init_httpAuthSchemeProvider2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthSchemeProvider.js"() {
    init_dist_es2();
    import_util_middleware4 = __toESM(require_dist_cjs6());
    init_STSClient();
    defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, import_util_middleware4.getSmithyContext)(context).operation,
        region: await (0, import_util_middleware4.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultSTSHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "AssumeRoleWithWebIdentity": {
          options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
        }
      }
      return options;
    };
    resolveStsAuthConfig = (input) => ({
      ...input,
      stsClientCtor: STSClient
    });
    resolveHttpAuthSchemeConfig2 = (config) => {
      const config_0 = resolveStsAuthConfig(config);
      const config_1 = resolveAwsSdkSigV4Config(config_0);
      return {
        ...config_1
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2, commonParams2;
var init_EndpointParameters2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/EndpointParameters.js"() {
    resolveClientEndpointParameters2 = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts"
      };
    };
    commonParams2 = {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/ruleset.js
var F, G, H, I, J, a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2, t2, u2, v2, w2, x2, y, z2, A, B, C, D, E, _data2, ruleSet2;
var init_ruleset2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/ruleset.js"() {
    F = "required";
    G = "type";
    H = "fn";
    I = "argv";
    J = "ref";
    a2 = false;
    b2 = true;
    c2 = "booleanEquals";
    d2 = "stringEquals";
    e2 = "sigv4";
    f2 = "sts";
    g2 = "us-east-1";
    h2 = "endpoint";
    i2 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
    j2 = "tree";
    k2 = "error";
    l2 = "getAttr";
    m2 = { [F]: false, [G]: "String" };
    n2 = { [F]: true, "default": false, [G]: "Boolean" };
    o2 = { [J]: "Endpoint" };
    p2 = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
    q2 = { [J]: "Region" };
    r2 = { [H]: "aws.partition", [I]: [q2], "assign": "PartitionResult" };
    s2 = { [J]: "UseFIPS" };
    t2 = { [J]: "UseDualStack" };
    u2 = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": e2, "signingName": f2, "signingRegion": g2 }] }, "headers": {} };
    v2 = {};
    w2 = { "conditions": [{ [H]: d2, [I]: [q2, "aws-global"] }], [h2]: u2, [G]: h2 };
    x2 = { [H]: c2, [I]: [s2, true] };
    y = { [H]: c2, [I]: [t2, true] };
    z2 = { [H]: l2, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] };
    A = { [J]: "PartitionResult" };
    B = { [H]: c2, [I]: [true, { [H]: l2, [I]: [A, "supportsDualStack"] }] };
    C = [{ [H]: "isSet", [I]: [o2] }];
    D = [x2];
    E = [y];
    _data2 = { version: "1.0", parameters: { Region: m2, UseDualStack: n2, UseFIPS: n2, Endpoint: m2, UseGlobalEndpoint: n2 }, rules: [{ conditions: [{ [H]: c2, [I]: [{ [J]: "UseGlobalEndpoint" }, b2] }, { [H]: "not", [I]: C }, p2, r2, { [H]: c2, [I]: [s2, a2] }, { [H]: c2, [I]: [t2, a2] }], rules: [{ conditions: [{ [H]: d2, [I]: [q2, "ap-northeast-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-south-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-southeast-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-southeast-2"] }], endpoint: u2, [G]: h2 }, w2, { conditions: [{ [H]: d2, [I]: [q2, "ca-central-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-central-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-north-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-2"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-3"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "sa-east-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, g2] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-east-2"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-west-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-west-2"] }], endpoint: u2, [G]: h2 }, { endpoint: { url: i2, properties: { authSchemes: [{ name: e2, signingName: f2, signingRegion: "{Region}" }] }, headers: v2 }, [G]: h2 }], [G]: j2 }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k2 }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k2 }, { endpoint: { url: o2, properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { conditions: [p2], rules: [{ conditions: [r2], rules: [{ conditions: [x2, y], rules: [{ conditions: [{ [H]: c2, [I]: [b2, z2] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k2 }], [G]: j2 }, { conditions: D, rules: [{ conditions: [{ [H]: c2, [I]: [z2, b2] }], rules: [{ conditions: [{ [H]: d2, [I]: [{ [H]: l2, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v2, headers: v2 }, [G]: h2 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k2 }], [G]: j2 }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k2 }], [G]: j2 }, w2, { endpoint: { url: i2, properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }], [G]: j2 }, { error: "Invalid Configuration: Missing Region", [G]: k2 }] };
    ruleSet2 = _data2;
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/endpointResolver.js
var import_util_endpoints3, import_util_endpoints4, cache2, defaultEndpointResolver2;
var init_endpointResolver2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/endpointResolver.js"() {
    import_util_endpoints3 = __toESM(require_dist_cjs19());
    import_util_endpoints4 = __toESM(require_dist_cjs18());
    init_ruleset2();
    cache2 = new import_util_endpoints4.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    });
    defaultEndpointResolver2 = (endpointParams, context = {}) => {
      return cache2.get(endpointParams, () => (0, import_util_endpoints4.resolveEndpoint)(ruleSet2, {
        endpointParams,
        logger: context.logger
      }));
    };
    import_util_endpoints4.customEndpointFunctions.aws = import_util_endpoints3.awsEndpointFunctions;
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.shared.js
var import_smithy_client14, import_url_parser2, import_util_base642, import_util_utf82, getRuntimeConfig3;
var init_runtimeConfig_shared2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.shared.js"() {
    init_dist_es2();
    init_dist_es();
    import_smithy_client14 = __toESM(require_dist_cjs23());
    import_url_parser2 = __toESM(require_dist_cjs31());
    import_util_base642 = __toESM(require_dist_cjs11());
    import_util_utf82 = __toESM(require_dist_cjs10());
    init_httpAuthSchemeProvider2();
    init_endpointResolver2();
    getRuntimeConfig3 = (config) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: config?.base64Decoder ?? import_util_base642.fromBase64,
        base64Encoder: config?.base64Encoder ?? import_util_base642.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new import_smithy_client14.NoOpLogger(),
        serviceId: config?.serviceId ?? "STS",
        urlParser: config?.urlParser ?? import_url_parser2.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? import_util_utf82.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? import_util_utf82.toUtf8
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.js
var import_util_user_agent_node2, import_config_resolver3, import_hash_node2, import_middleware_retry3, import_node_config_provider2, import_node_http_handler2, import_util_body_length_node2, import_util_retry2, import_smithy_client15, import_util_defaults_mode_node2, import_smithy_client16, getRuntimeConfig4;
var init_runtimeConfig2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.js"() {
    init_package();
    init_dist_es2();
    import_util_user_agent_node2 = __toESM(require_dist_cjs39());
    import_config_resolver3 = __toESM(require_dist_cjs26());
    init_dist_es();
    import_hash_node2 = __toESM(require_dist_cjs40());
    import_middleware_retry3 = __toESM(require_dist_cjs35());
    import_node_config_provider2 = __toESM(require_dist_cjs29());
    import_node_http_handler2 = __toESM(require_dist_cjs14());
    import_util_body_length_node2 = __toESM(require_dist_cjs41());
    import_util_retry2 = __toESM(require_dist_cjs34());
    init_runtimeConfig_shared2();
    import_smithy_client15 = __toESM(require_dist_cjs23());
    import_util_defaults_mode_node2 = __toESM(require_dist_cjs42());
    import_smithy_client16 = __toESM(require_dist_cjs23());
    getRuntimeConfig4 = (config) => {
      (0, import_smithy_client16.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, import_util_defaults_mode_node2.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(import_smithy_client15.loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig3(config);
      emitWarningIfUnsupportedVersion(process.version);
      const profileConfig = { profile: config?.profile };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node2.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_util_user_agent_node2.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config.credentialDefaultProvider(idProps?.__config || {})()),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        maxAttempts: config?.maxAttempts ?? (0, import_node_config_provider2.loadConfig)(import_middleware_retry3.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver3.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
        requestHandler: import_node_http_handler2.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, import_node_config_provider2.loadConfig)({
          ...import_middleware_retry3.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || import_util_retry2.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? import_hash_node2.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? import_node_http_handler2.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, import_node_config_provider2.loadConfig)(import_util_user_agent_node2.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration2, resolveHttpAuthRuntimeConfig2;
var init_httpAuthExtensionConfiguration2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthExtensionConfiguration.js"() {
    getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig2 = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeExtensions.js
var import_region_config_resolver2, import_protocol_http9, import_smithy_client17, asPartial2, resolveRuntimeExtensions2;
var init_runtimeExtensions2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeExtensions.js"() {
    import_region_config_resolver2 = __toESM(require_dist_cjs43());
    import_protocol_http9 = __toESM(require_dist_cjs2());
    import_smithy_client17 = __toESM(require_dist_cjs23());
    init_httpAuthExtensionConfiguration2();
    asPartial2 = (t3) => t3;
    resolveRuntimeExtensions2 = (runtimeConfig, extensions) => {
      const extensionConfiguration = {
        ...asPartial2((0, import_region_config_resolver2.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial2((0, import_smithy_client17.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial2((0, import_protocol_http9.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
        ...asPartial2(getHttpAuthExtensionConfiguration2(runtimeConfig))
      };
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return {
        ...runtimeConfig,
        ...(0, import_region_config_resolver2.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, import_smithy_client17.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, import_protocol_http9.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig2(extensionConfiguration)
      };
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STSClient.js
var import_middleware_host_header2, import_middleware_logger2, import_middleware_recursion_detection2, import_middleware_user_agent2, import_config_resolver4, import_middleware_content_length2, import_middleware_endpoint3, import_middleware_retry4, import_smithy_client18, STSClient;
var init_STSClient = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STSClient.js"() {
    import_middleware_host_header2 = __toESM(require_dist_cjs3());
    import_middleware_logger2 = __toESM(require_dist_cjs4());
    import_middleware_recursion_detection2 = __toESM(require_dist_cjs5());
    import_middleware_user_agent2 = __toESM(require_dist_cjs24());
    import_config_resolver4 = __toESM(require_dist_cjs26());
    init_dist_es();
    import_middleware_content_length2 = __toESM(require_dist_cjs27());
    import_middleware_endpoint3 = __toESM(require_dist_cjs32());
    import_middleware_retry4 = __toESM(require_dist_cjs35());
    import_smithy_client18 = __toESM(require_dist_cjs23());
    init_httpAuthSchemeProvider2();
    init_EndpointParameters2();
    init_runtimeConfig2();
    init_runtimeExtensions2();
    STSClient = class extends import_smithy_client18.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig4(configuration || {});
        const _config_1 = resolveClientEndpointParameters2(_config_0);
        const _config_2 = (0, import_middleware_user_agent2.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry4.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver4.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header2.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint3.resolveEndpointConfig)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig2(_config_6);
        const _config_8 = resolveRuntimeExtensions2(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, import_middleware_user_agent2.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry4.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length2.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header2.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger2.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection2.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultSTSHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/STSServiceException.js
var import_smithy_client19, STSServiceException;
var init_STSServiceException = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/STSServiceException.js"() {
    import_smithy_client19 = __toESM(require_dist_cjs23());
    STSServiceException = class _STSServiceException extends import_smithy_client19.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _STSServiceException.prototype);
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/models_0.js
var import_smithy_client20, CredentialsFilterSensitiveLog, AssumeRoleResponseFilterSensitiveLog, ExpiredTokenException2, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, IDPRejectedClaimException, InvalidIdentityTokenException, AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog, IDPCommunicationErrorException;
var init_models_02 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/models_0.js"() {
    import_smithy_client20 = __toESM(require_dist_cjs23());
    init_STSServiceException();
    CredentialsFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SecretAccessKey && { SecretAccessKey: import_smithy_client20.SENSITIVE_STRING }
    });
    AssumeRoleResponseFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
    });
    ExpiredTokenException2 = class _ExpiredTokenException extends STSServiceException {
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
      }
    };
    MalformedPolicyDocumentException = class _MalformedPolicyDocumentException extends STSServiceException {
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
      }
    };
    PackedPolicyTooLargeException = class _PackedPolicyTooLargeException extends STSServiceException {
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
      }
    };
    RegionDisabledException = class _RegionDisabledException extends STSServiceException {
      name = "RegionDisabledException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _RegionDisabledException.prototype);
      }
    };
    IDPRejectedClaimException = class _IDPRejectedClaimException extends STSServiceException {
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
      }
    };
    InvalidIdentityTokenException = class _InvalidIdentityTokenException extends STSServiceException {
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
      }
    };
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.WebIdentityToken && { WebIdentityToken: import_smithy_client20.SENSITIVE_STRING }
    });
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
    });
    IDPCommunicationErrorException = class _IDPCommunicationErrorException extends STSServiceException {
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/protocols/Aws_query.js
var import_protocol_http10, import_smithy_client21, se_AssumeRoleCommand, se_AssumeRoleWithWebIdentityCommand, de_AssumeRoleCommand, de_AssumeRoleWithWebIdentityCommand, de_CommandError2, de_ExpiredTokenExceptionRes2, de_IDPCommunicationErrorExceptionRes, de_IDPRejectedClaimExceptionRes, de_InvalidIdentityTokenExceptionRes, de_MalformedPolicyDocumentExceptionRes, de_PackedPolicyTooLargeExceptionRes, de_RegionDisabledExceptionRes, se_AssumeRoleRequest, se_AssumeRoleWithWebIdentityRequest, se_policyDescriptorListType, se_PolicyDescriptorType, se_ProvidedContext, se_ProvidedContextsListType, se_Tag, se_tagKeyListType, se_tagListType, de_AssumedRoleUser, de_AssumeRoleResponse, de_AssumeRoleWithWebIdentityResponse, de_Credentials, de_ExpiredTokenException, de_IDPCommunicationErrorException, de_IDPRejectedClaimException, de_InvalidIdentityTokenException, de_MalformedPolicyDocumentException, de_PackedPolicyTooLargeException, de_RegionDisabledException, deserializeMetadata2, throwDefaultError2, buildHttpRpcRequest, SHARED_HEADERS, _, _A, _AKI, _AR, _ARI, _ARU, _ARWWI, _Ar, _Au, _C, _CA, _DS, _E, _EI, _K, _P, _PA, _PAr, _PC, _PI, _PPS, _Pr, _RA, _RSN, _SAK, _SFWIT, _SI, _SN, _ST, _T, _TC, _TTK, _V, _Va, _WIT, _a, _m, buildFormUrlencodedString, loadQueryErrorCode;
var init_Aws_query = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/protocols/Aws_query.js"() {
    init_dist_es2();
    import_protocol_http10 = __toESM(require_dist_cjs2());
    import_smithy_client21 = __toESM(require_dist_cjs23());
    init_models_02();
    init_STSServiceException();
    se_AssumeRoleCommand = async (input, context) => {
      const headers = SHARED_HEADERS;
      let body;
      body = buildFormUrlencodedString({
        ...se_AssumeRoleRequest(input, context),
        [_A]: _AR,
        [_V]: _
      });
      return buildHttpRpcRequest(context, headers, "/", void 0, body);
    };
    se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
      const headers = SHARED_HEADERS;
      let body;
      body = buildFormUrlencodedString({
        ...se_AssumeRoleWithWebIdentityRequest(input, context),
        [_A]: _ARWWI,
        [_V]: _
      });
      return buildHttpRpcRequest(context, headers, "/", void 0, body);
    };
    de_AssumeRoleCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError2(output, context);
      }
      const data = await parseXmlBody(output.body, context);
      let contents = {};
      contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
      const response = {
        $metadata: deserializeMetadata2(output),
        ...contents
      };
      return response;
    };
    de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError2(output, context);
      }
      const data = await parseXmlBody(output.body, context);
      let contents = {};
      contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
      const response = {
        $metadata: deserializeMetadata2(output),
        ...contents
      };
      return response;
    };
    de_CommandError2 = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseXmlErrorBody(output.body, context)
      };
      const errorCode = loadQueryErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await de_ExpiredTokenExceptionRes2(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError2({
            output,
            parsedBody: parsedBody.Error,
            errorCode
          });
      }
    };
    de_ExpiredTokenExceptionRes2 = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_ExpiredTokenException(body.Error, context);
      const exception = new ExpiredTokenException2({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_IDPCommunicationErrorException(body.Error, context);
      const exception = new IDPCommunicationErrorException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_IDPRejectedClaimException(body.Error, context);
      const exception = new IDPRejectedClaimException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_InvalidIdentityTokenException(body.Error, context);
      const exception = new InvalidIdentityTokenException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
      const exception = new MalformedPolicyDocumentException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
      const exception = new PackedPolicyTooLargeException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = de_RegionDisabledException(body.Error, context);
      const exception = new RegionDisabledException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client21.decorateServiceException)(exception, body);
    };
    se_AssumeRoleRequest = (input, context) => {
      const entries = {};
      if (input[_RA] != null) {
        entries[_RA] = input[_RA];
      }
      if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
      }
      if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
          entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `PolicyArns.${key}`;
          entries[loc] = value;
        });
      }
      if (input[_P] != null) {
        entries[_P] = input[_P];
      }
      if (input[_DS] != null) {
        entries[_DS] = input[_DS];
      }
      if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
          entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `Tags.${key}`;
          entries[loc] = value;
        });
      }
      if (input[_TTK] != null) {
        const memberEntries = se_tagKeyListType(input[_TTK], context);
        if (input[_TTK]?.length === 0) {
          entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `TransitiveTagKeys.${key}`;
          entries[loc] = value;
        });
      }
      if (input[_EI] != null) {
        entries[_EI] = input[_EI];
      }
      if (input[_SN] != null) {
        entries[_SN] = input[_SN];
      }
      if (input[_TC] != null) {
        entries[_TC] = input[_TC];
      }
      if (input[_SI] != null) {
        entries[_SI] = input[_SI];
      }
      if (input[_PC] != null) {
        const memberEntries = se_ProvidedContextsListType(input[_PC], context);
        if (input[_PC]?.length === 0) {
          entries.ProvidedContexts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `ProvidedContexts.${key}`;
          entries[loc] = value;
        });
      }
      return entries;
    };
    se_AssumeRoleWithWebIdentityRequest = (input, context) => {
      const entries = {};
      if (input[_RA] != null) {
        entries[_RA] = input[_RA];
      }
      if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
      }
      if (input[_WIT] != null) {
        entries[_WIT] = input[_WIT];
      }
      if (input[_PI] != null) {
        entries[_PI] = input[_PI];
      }
      if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
          entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `PolicyArns.${key}`;
          entries[loc] = value;
        });
      }
      if (input[_P] != null) {
        entries[_P] = input[_P];
      }
      if (input[_DS] != null) {
        entries[_DS] = input[_DS];
      }
      return entries;
    };
    se_policyDescriptorListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        const memberEntries = se_PolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
          entries[`member.${counter}.${key}`] = value;
        });
        counter++;
      }
      return entries;
    };
    se_PolicyDescriptorType = (input, context) => {
      const entries = {};
      if (input[_a] != null) {
        entries[_a] = input[_a];
      }
      return entries;
    };
    se_ProvidedContext = (input, context) => {
      const entries = {};
      if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
      }
      if (input[_CA] != null) {
        entries[_CA] = input[_CA];
      }
      return entries;
    };
    se_ProvidedContextsListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        const memberEntries = se_ProvidedContext(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
          entries[`member.${counter}.${key}`] = value;
        });
        counter++;
      }
      return entries;
    };
    se_Tag = (input, context) => {
      const entries = {};
      if (input[_K] != null) {
        entries[_K] = input[_K];
      }
      if (input[_Va] != null) {
        entries[_Va] = input[_Va];
      }
      return entries;
    };
    se_tagKeyListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
      }
      return entries;
    };
    se_tagListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
          entries[`member.${counter}.${key}`] = value;
        });
        counter++;
      }
      return entries;
    };
    de_AssumedRoleUser = (output, context) => {
      const contents = {};
      if (output[_ARI] != null) {
        contents[_ARI] = (0, import_smithy_client21.expectString)(output[_ARI]);
      }
      if (output[_Ar] != null) {
        contents[_Ar] = (0, import_smithy_client21.expectString)(output[_Ar]);
      }
      return contents;
    };
    de_AssumeRoleResponse = (output, context) => {
      const contents = {};
      if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
      }
      if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
      }
      if (output[_PPS] != null) {
        contents[_PPS] = (0, import_smithy_client21.strictParseInt32)(output[_PPS]);
      }
      if (output[_SI] != null) {
        contents[_SI] = (0, import_smithy_client21.expectString)(output[_SI]);
      }
      return contents;
    };
    de_AssumeRoleWithWebIdentityResponse = (output, context) => {
      const contents = {};
      if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
      }
      if (output[_SFWIT] != null) {
        contents[_SFWIT] = (0, import_smithy_client21.expectString)(output[_SFWIT]);
      }
      if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
      }
      if (output[_PPS] != null) {
        contents[_PPS] = (0, import_smithy_client21.strictParseInt32)(output[_PPS]);
      }
      if (output[_Pr] != null) {
        contents[_Pr] = (0, import_smithy_client21.expectString)(output[_Pr]);
      }
      if (output[_Au] != null) {
        contents[_Au] = (0, import_smithy_client21.expectString)(output[_Au]);
      }
      if (output[_SI] != null) {
        contents[_SI] = (0, import_smithy_client21.expectString)(output[_SI]);
      }
      return contents;
    };
    de_Credentials = (output, context) => {
      const contents = {};
      if (output[_AKI] != null) {
        contents[_AKI] = (0, import_smithy_client21.expectString)(output[_AKI]);
      }
      if (output[_SAK] != null) {
        contents[_SAK] = (0, import_smithy_client21.expectString)(output[_SAK]);
      }
      if (output[_ST] != null) {
        contents[_ST] = (0, import_smithy_client21.expectString)(output[_ST]);
      }
      if (output[_E] != null) {
        contents[_E] = (0, import_smithy_client21.expectNonNull)((0, import_smithy_client21.parseRfc3339DateTimeWithOffset)(output[_E]));
      }
      return contents;
    };
    de_ExpiredTokenException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_IDPCommunicationErrorException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_IDPRejectedClaimException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_InvalidIdentityTokenException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_MalformedPolicyDocumentException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_PackedPolicyTooLargeException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    de_RegionDisabledException = (output, context) => {
      const contents = {};
      if (output[_m] != null) {
        contents[_m] = (0, import_smithy_client21.expectString)(output[_m]);
      }
      return contents;
    };
    deserializeMetadata2 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    throwDefaultError2 = (0, import_smithy_client21.withBaseException)(STSServiceException);
    buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
      };
      if (resolvedHostname !== void 0) {
        contents.hostname = resolvedHostname;
      }
      if (body !== void 0) {
        contents.body = body;
      }
      return new import_protocol_http10.HttpRequest(contents);
    };
    SHARED_HEADERS = {
      "content-type": "application/x-www-form-urlencoded"
    };
    _ = "2011-06-15";
    _A = "Action";
    _AKI = "AccessKeyId";
    _AR = "AssumeRole";
    _ARI = "AssumedRoleId";
    _ARU = "AssumedRoleUser";
    _ARWWI = "AssumeRoleWithWebIdentity";
    _Ar = "Arn";
    _Au = "Audience";
    _C = "Credentials";
    _CA = "ContextAssertion";
    _DS = "DurationSeconds";
    _E = "Expiration";
    _EI = "ExternalId";
    _K = "Key";
    _P = "Policy";
    _PA = "PolicyArns";
    _PAr = "ProviderArn";
    _PC = "ProvidedContexts";
    _PI = "ProviderId";
    _PPS = "PackedPolicySize";
    _Pr = "Provider";
    _RA = "RoleArn";
    _RSN = "RoleSessionName";
    _SAK = "SecretAccessKey";
    _SFWIT = "SubjectFromWebIdentityToken";
    _SI = "SourceIdentity";
    _SN = "SerialNumber";
    _ST = "SessionToken";
    _T = "Tags";
    _TC = "TokenCode";
    _TTK = "TransitiveTagKeys";
    _V = "Version";
    _Va = "Value";
    _WIT = "WebIdentityToken";
    _a = "arn";
    _m = "message";
    buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => (0, import_smithy_client21.extendedEncodeURIComponent)(key) + "=" + (0, import_smithy_client21.extendedEncodeURIComponent)(value)).join("&");
    loadQueryErrorCode = (output, data) => {
      if (data.Error?.Code !== void 0) {
        return data.Error.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleCommand.js
var import_middleware_endpoint4, import_middleware_serde3, import_smithy_client22, AssumeRoleCommand;
var init_AssumeRoleCommand = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleCommand.js"() {
    import_middleware_endpoint4 = __toESM(require_dist_cjs32());
    import_middleware_serde3 = __toESM(require_dist_cjs7());
    import_smithy_client22 = __toESM(require_dist_cjs23());
    init_EndpointParameters2();
    init_models_02();
    init_Aws_query();
    AssumeRoleCommand = class extends import_smithy_client22.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde3.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint4.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, AssumeRoleResponseFilterSensitiveLog).ser(se_AssumeRoleCommand).de(de_AssumeRoleCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.js
var import_middleware_endpoint5, import_middleware_serde4, import_smithy_client23, AssumeRoleWithWebIdentityCommand;
var init_AssumeRoleWithWebIdentityCommand = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.js"() {
    import_middleware_endpoint5 = __toESM(require_dist_cjs32());
    import_middleware_serde4 = __toESM(require_dist_cjs7());
    import_smithy_client23 = __toESM(require_dist_cjs23());
    init_EndpointParameters2();
    init_models_02();
    init_Aws_query();
    AssumeRoleWithWebIdentityCommand = class extends import_smithy_client23.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde4.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint5.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog).ser(se_AssumeRoleWithWebIdentityCommand).de(de_AssumeRoleWithWebIdentityCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STS.js
var import_smithy_client24, commands2, STS;
var init_STS = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STS.js"() {
    import_smithy_client24 = __toESM(require_dist_cjs23());
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
    init_STSClient();
    commands2 = {
      AssumeRoleCommand,
      AssumeRoleWithWebIdentityCommand
    };
    STS = class extends STSClient {
    };
    (0, import_smithy_client24.createAggregatedClient)(commands2, STS);
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/index.js
var init_commands2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/index.js"() {
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/index.js
var init_models2 = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/index.js"() {
    init_models_02();
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION, getAccountIdFromAssumedRoleUser, resolveRegion, getDefaultRoleAssumer, getDefaultRoleAssumerWithWebIdentity, isH2;
var init_defaultStsRoleAssumers = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultStsRoleAssumers.js"() {
    init_client();
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
    ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
    getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
      if (typeof assumedRoleUser?.Arn === "string") {
        const arnComponents = assumedRoleUser.Arn.split(":");
        if (arnComponents.length > 4 && arnComponents[4] !== "") {
          return arnComponents[4];
        }
      }
      return void 0;
    };
    resolveRegion = async (_region, _parentRegion, credentialProviderLogger) => {
      const region = typeof _region === "function" ? await _region() : _region;
      const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
      credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
      return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
    };
    getDefaultRoleAssumer = (stsOptions, STSClient2) => {
      let stsClient;
      let closureSourceCreds;
      return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
          const { logger = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
          const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
          const isCompatibleRequestHandler = !isH2(requestHandler);
          stsClient = new STSClient2({
            profile: stsOptions?.parentClientConfig?.profile,
            credentialDefaultProvider: () => async () => closureSourceCreds,
            region: resolvedRegion,
            requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
            logger
          });
        }
        const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
        const credentials = {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration,
          ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
          ...accountId && { accountId }
        };
        setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
        return credentials;
      };
    };
    getDefaultRoleAssumerWithWebIdentity = (stsOptions, STSClient2) => {
      let stsClient;
      return async (params) => {
        if (!stsClient) {
          const { logger = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
          const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
          const isCompatibleRequestHandler = !isH2(requestHandler);
          stsClient = new STSClient2({
            profile: stsOptions?.parentClientConfig?.profile,
            region: resolvedRegion,
            requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
            logger
          });
        }
        const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
        const credentials = {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration,
          ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
          ...accountId && { accountId }
        };
        if (accountId) {
          setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
        }
        setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
        return credentials;
      };
    };
    isH2 = (requestHandler) => {
      return requestHandler?.metadata?.handlerProtocol === "h2";
    };
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultRoleAssumers.js
var getCustomizableStsClientCtor, getDefaultRoleAssumer2, getDefaultRoleAssumerWithWebIdentity2, decorateDefaultCredentialProvider;
var init_defaultRoleAssumers = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultRoleAssumers.js"() {
    init_defaultStsRoleAssumers();
    init_STSClient();
    getCustomizableStsClientCtor = (baseCtor, customizations) => {
      if (!customizations)
        return baseCtor;
      else
        return class CustomizableSTSClient extends baseCtor {
          constructor(config) {
            super(config);
            for (const customization of customizations) {
              this.middlewareStack.use(customization);
            }
          }
        };
    };
    getDefaultRoleAssumer2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    getDefaultRoleAssumerWithWebIdentity2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    decorateDefaultCredentialProvider = (provider) => (input) => provider({
      roleAssumer: getDefaultRoleAssumer2(input),
      roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
      ...input
    });
  }
});

// node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/index.js
var sts_exports = {};
__export(sts_exports, {
  AssumeRoleCommand: () => AssumeRoleCommand,
  AssumeRoleResponseFilterSensitiveLog: () => AssumeRoleResponseFilterSensitiveLog,
  AssumeRoleWithWebIdentityCommand: () => AssumeRoleWithWebIdentityCommand,
  AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
  AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
  CredentialsFilterSensitiveLog: () => CredentialsFilterSensitiveLog,
  ExpiredTokenException: () => ExpiredTokenException2,
  IDPCommunicationErrorException: () => IDPCommunicationErrorException,
  IDPRejectedClaimException: () => IDPRejectedClaimException,
  InvalidIdentityTokenException: () => InvalidIdentityTokenException,
  MalformedPolicyDocumentException: () => MalformedPolicyDocumentException,
  PackedPolicyTooLargeException: () => PackedPolicyTooLargeException,
  RegionDisabledException: () => RegionDisabledException,
  STS: () => STS,
  STSClient: () => STSClient,
  STSServiceException: () => STSServiceException,
  __Client: () => import_smithy_client18.Client,
  decorateDefaultCredentialProvider: () => decorateDefaultCredentialProvider,
  getDefaultRoleAssumer: () => getDefaultRoleAssumer2,
  getDefaultRoleAssumerWithWebIdentity: () => getDefaultRoleAssumerWithWebIdentity2
});
var init_sts = __esm({
  "node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/index.js"() {
    init_STSClient();
    init_STS();
    init_commands2();
    init_models2();
    init_defaultRoleAssumers();
    init_STSServiceException();
  }
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js
var require_dist_cjs47 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromProcess: () => fromProcess
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_ini_file_loader = require_dist_cjs28();
    var import_property_provider2 = require_dist_cjs20();
    var import_child_process = __require("child_process");
    var import_util = __require("util");
    var import_client3 = (init_client(), __toCommonJS(client_exports));
    var getValidatedProcessCredentials = /* @__PURE__ */ __name((profileName, data, profiles) => {
      if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
      }
      if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
      }
      if (data.Expiration) {
        const currentTime = /* @__PURE__ */ new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
          throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
      }
      let accountId = data.AccountId;
      if (!accountId && profiles?.[profileName]?.aws_account_id) {
        accountId = profiles[profileName].aws_account_id;
      }
      const credentials = {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...data.SessionToken && { sessionToken: data.SessionToken },
        ...data.Expiration && { expiration: new Date(data.Expiration) },
        ...data.CredentialScope && { credentialScope: data.CredentialScope },
        ...accountId && { accountId }
      };
      (0, import_client3.setCredentialFeature)(credentials, "CREDENTIALS_PROCESS", "w");
      return credentials;
    }, "getValidatedProcessCredentials");
    var resolveProcessCredentials = /* @__PURE__ */ __name(async (profileName, profiles, logger) => {
      const profile = profiles[profileName];
      if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== void 0) {
          const execPromise = (0, import_util.promisify)(import_child_process.exec);
          try {
            const { stdout } = await execPromise(credentialProcess);
            let data;
            try {
              data = JSON.parse(stdout.trim());
            } catch {
              throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
            }
            return getValidatedProcessCredentials(profileName, data, profiles);
          } catch (error) {
            throw new import_property_provider2.CredentialsProviderError(error.message, { logger });
          }
        } else {
          throw new import_property_provider2.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger });
        }
      } else {
        throw new import_property_provider2.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
          logger
        });
      }
    }, "resolveProcessCredentials");
    var fromProcess = /* @__PURE__ */ __name((init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      const profiles = await (0, import_shared_ini_file_loader.parseKnownFiles)(init);
      return resolveProcessCredentials(
        (0, import_shared_ini_file_loader.getProfileName)({
          profile: init.profile ?? callerClientConfig?.profile
        }),
        profiles,
        init.logger
      );
    }, "fromProcess");
  }
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js
var require_fromWebToken = __commonJS({
  "node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0) k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m3, k3);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k3];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0) k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o3, v6) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v6 });
    } : function(o3, v6) {
      o3["default"] = v6;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod) if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3)) __createBinding2(result, mod, k3);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromWebToken = void 0;
    var fromWebToken2 = (init) => async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
      const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
      let { roleAssumerWithWebIdentity } = init;
      if (!roleAssumerWithWebIdentity) {
        const { getDefaultRoleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3 } = await Promise.resolve().then(() => __importStar2((init_sts(), __toCommonJS(sts_exports))));
        roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity3({
          ...init.clientConfig,
          credentialProviderLogger: init.logger,
          parentClientConfig: {
            ...awsIdentityProperties?.callerClientConfig,
            ...init.parentClientConfig
          }
        }, init.clientPlugins);
      }
      return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds
      });
    };
    exports.fromWebToken = fromWebToken2;
  }
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js
var require_fromTokenFile = __commonJS({
  "node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTokenFile = void 0;
    var client_1 = (init_client(), __toCommonJS(client_exports));
    var property_provider_1 = require_dist_cjs20();
    var fs_1 = __require("fs");
    var fromWebToken_1 = require_fromWebToken();
    var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
    var ENV_ROLE_ARN = "AWS_ROLE_ARN";
    var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
    var fromTokenFile2 = (init = {}) => async () => {
      init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
      const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
      const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
      if (!webIdentityTokenFile || !roleArn) {
        throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified", {
          logger: init.logger
        });
      }
      const credentials = await (0, fromWebToken_1.fromWebToken)({
        ...init,
        webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName
      })();
      if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
        (0, client_1.setCredentialFeature)(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      }
      return credentials;
    };
    exports.fromTokenFile = fromTokenFile2;
  }
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js
var require_dist_cjs48 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    module.exports = __toCommonJS2(index_exports);
    __reExport(index_exports, require_fromTokenFile(), module.exports);
    __reExport(index_exports, require_fromWebToken(), module.exports);
  }
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js
var require_dist_cjs49 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      fromIni: () => fromIni
    });
    module.exports = __toCommonJS2(index_exports);
    var import_shared_ini_file_loader = require_dist_cjs28();
    var import_client3 = (init_client(), __toCommonJS(client_exports));
    var import_property_provider2 = require_dist_cjs20();
    var resolveCredentialSource = /* @__PURE__ */ __name((credentialSource, profileName, logger) => {
      const sourceProvidersMap = {
        EcsContainer: /* @__PURE__ */ __name(async (options) => {
          const { fromHttp } = await Promise.resolve().then(() => __toESM2(require_dist_cjs38()));
          const { fromContainerMetadata } = await Promise.resolve().then(() => __toESM2(require_dist_cjs37()));
          logger?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
          return async () => (0, import_property_provider2.chain)(fromHttp(options ?? {}), fromContainerMetadata(options))().then(setNamedProvider);
        }, "EcsContainer"),
        Ec2InstanceMetadata: /* @__PURE__ */ __name(async (options) => {
          logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          const { fromInstanceMetadata } = await Promise.resolve().then(() => __toESM2(require_dist_cjs37()));
          return async () => fromInstanceMetadata(options)().then(setNamedProvider);
        }, "Ec2InstanceMetadata"),
        Environment: /* @__PURE__ */ __name(async (options) => {
          logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          const { fromEnv } = await Promise.resolve().then(() => __toESM2(require_dist_cjs36()));
          return async () => fromEnv(options)().then(setNamedProvider);
        }, "Environment")
      };
      if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource];
      } else {
        throw new import_property_provider2.CredentialsProviderError(
          `Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
          { logger }
        );
      }
    }, "resolveCredentialSource");
    var setNamedProvider = /* @__PURE__ */ __name((creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider");
    var isAssumeRoleProfile = /* @__PURE__ */ __name((arg, { profile = "default", logger } = {}) => {
      return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile, logger }) || isCredentialSourceProfile(arg, { profile, logger }));
    }, "isAssumeRoleProfile");
    var isAssumeRoleWithSourceProfile = /* @__PURE__ */ __name((arg, { profile, logger }) => {
      const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
      if (withSourceProfile) {
        logger?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
      }
      return withSourceProfile;
    }, "isAssumeRoleWithSourceProfile");
    var isCredentialSourceProfile = /* @__PURE__ */ __name((arg, { profile, logger }) => {
      const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
      if (withProviderProfile) {
        logger?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
      }
      return withProviderProfile;
    }, "isCredentialSourceProfile");
    var resolveAssumeRoleCredentials = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}) => {
      options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      const profileData = profiles[profileName];
      const { source_profile, region } = profileData;
      if (!options.roleAssumer) {
        const { getDefaultRoleAssumer: getDefaultRoleAssumer3 } = await Promise.resolve().then(() => __toESM2((init_sts(), __toCommonJS(sts_exports))));
        options.roleAssumer = getDefaultRoleAssumer3(
          {
            ...options.clientConfig,
            credentialProviderLogger: options.logger,
            parentClientConfig: {
              ...options?.parentClientConfig,
              region: region ?? options?.parentClientConfig?.region
            }
          },
          options.clientPlugins
        );
      }
      if (source_profile && source_profile in visitedProfiles) {
        throw new import_property_provider2.CredentialsProviderError(
          `Detected a cycle attempting to resolve credentials for profile ${(0, import_shared_ini_file_loader.getProfileName)(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "),
          { logger: options.logger }
        );
      }
      options.logger?.debug(
        `@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`
      );
      const sourceCredsProvider = source_profile ? resolveProfileData(
        source_profile,
        profiles,
        options,
        {
          ...visitedProfiles,
          [source_profile]: true
        },
        isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})
      ) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
      if (isCredentialSourceWithoutRoleArn(profileData)) {
        return sourceCredsProvider.then((creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      } else {
        const params = {
          RoleArn: profileData.role_arn,
          RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
          ExternalId: profileData.external_id,
          DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
        };
        const { mfa_serial } = profileData;
        if (mfa_serial) {
          if (!options.mfaCodeProvider) {
            throw new import_property_provider2.CredentialsProviderError(
              `Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`,
              { logger: options.logger, tryNextLink: false }
            );
          }
          params.SerialNumber = mfa_serial;
          params.TokenCode = await options.mfaCodeProvider(mfa_serial);
        }
        const sourceCreds = await sourceCredsProvider;
        return options.roleAssumer(sourceCreds, params).then(
          (creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")
        );
      }
    }, "resolveAssumeRoleCredentials");
    var isCredentialSourceWithoutRoleArn = /* @__PURE__ */ __name((section) => {
      return !section.role_arn && !!section.credential_source;
    }, "isCredentialSourceWithoutRoleArn");
    var isProcessProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", "isProcessProfile");
    var resolveProcessCredentials = /* @__PURE__ */ __name(async (options, profile) => Promise.resolve().then(() => __toESM2(require_dist_cjs47())).then(
      ({ fromProcess }) => fromProcess({
        ...options,
        profile
      })().then((creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_PROCESS", "v"))
    ), "resolveProcessCredentials");
    var resolveSsoCredentials = /* @__PURE__ */ __name(async (profile, profileData, options = {}) => {
      const { fromSSO } = await Promise.resolve().then(() => __toESM2(require_dist_cjs46()));
      return fromSSO({
        profile,
        logger: options.logger,
        parentClientConfig: options.parentClientConfig,
        clientConfig: options.clientConfig
      })().then((creds) => {
        if (profileData.sso_session) {
          return (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_SSO", "r");
        } else {
          return (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
        }
      });
    }, "resolveSsoCredentials");
    var isSsoProfile = /* @__PURE__ */ __name((arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string"), "isSsoProfile");
    var isStaticCredsProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1, "isStaticCredsProfile");
    var resolveStaticCredentials = /* @__PURE__ */ __name(async (profile, options) => {
      options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      const credentials = {
        accessKeyId: profile.aws_access_key_id,
        secretAccessKey: profile.aws_secret_access_key,
        sessionToken: profile.aws_session_token,
        ...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
        ...profile.aws_account_id && { accountId: profile.aws_account_id }
      };
      return (0, import_client3.setCredentialFeature)(credentials, "CREDENTIALS_PROFILE", "n");
    }, "resolveStaticCredentials");
    var isWebIdentityProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, "isWebIdentityProfile");
    var resolveWebIdentityCredentials = /* @__PURE__ */ __name(async (profile, options) => Promise.resolve().then(() => __toESM2(require_dist_cjs48())).then(
      ({ fromTokenFile: fromTokenFile2 }) => fromTokenFile2({
        webIdentityTokenFile: profile.web_identity_token_file,
        roleArn: profile.role_arn,
        roleSessionName: profile.role_session_name,
        roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
        logger: options.logger,
        parentClientConfig: options.parentClientConfig
      })().then((creds) => (0, import_client3.setCredentialFeature)(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))
    ), "resolveWebIdentityCredentials");
    var resolveProfileData = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
      const data = profiles[profileName];
      if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data, options);
      }
      if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data, { profile: profileName, logger: options.logger })) {
        return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
      }
      if (isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data, options);
      }
      if (isWebIdentityProfile(data)) {
        return resolveWebIdentityCredentials(data, options);
      }
      if (isProcessProfile(data)) {
        return resolveProcessCredentials(options, profileName);
      }
      if (isSsoProfile(data)) {
        return await resolveSsoCredentials(profileName, data, options);
      }
      throw new import_property_provider2.CredentialsProviderError(
        `Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`,
        { logger: options.logger }
      );
    }, "resolveProfileData");
    var fromIni = /* @__PURE__ */ __name((_init = {}) => async ({ callerClientConfig } = {}) => {
      const init = {
        ..._init,
        parentClientConfig: {
          ...callerClientConfig,
          ..._init.parentClientConfig
        }
      };
      init.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      const profiles = await (0, import_shared_ini_file_loader.parseKnownFiles)(init);
      return resolveProfileData(
        (0, import_shared_ini_file_loader.getProfileName)({
          profile: _init.profile ?? callerClientConfig?.profile
        }),
        profiles,
        init
      );
    }, "fromIni");
  }
});

// node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js
var require_dist_cjs50 = __commonJS({
  "node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      credentialsTreatedAsExpired: () => credentialsTreatedAsExpired,
      credentialsWillNeedRefresh: () => credentialsWillNeedRefresh,
      defaultProvider: () => defaultProvider
    });
    module.exports = __toCommonJS2(index_exports);
    var import_credential_provider_env = require_dist_cjs36();
    var import_shared_ini_file_loader = require_dist_cjs28();
    var import_property_provider2 = require_dist_cjs20();
    var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
    var remoteProvider = /* @__PURE__ */ __name(async (init) => {
      const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await Promise.resolve().then(() => __toESM2(require_dist_cjs37()));
      if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        const { fromHttp } = await Promise.resolve().then(() => __toESM2(require_dist_cjs38()));
        return (0, import_property_provider2.chain)(fromHttp(init), fromContainerMetadata(init));
      }
      if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
        return async () => {
          throw new import_property_provider2.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
        };
      }
      init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
      return fromInstanceMetadata(init);
    }, "remoteProvider");
    var multipleCredentialSourceWarningEmitted = false;
    var defaultProvider = /* @__PURE__ */ __name((init = {}) => (0, import_property_provider2.memoize)(
      (0, import_property_provider2.chain)(
        async () => {
          const profile = init.profile ?? process.env[import_shared_ini_file_loader.ENV_PROFILE];
          if (profile) {
            const envStaticCredentialsAreSet = process.env[import_credential_provider_env.ENV_KEY] && process.env[import_credential_provider_env.ENV_SECRET];
            if (envStaticCredentialsAreSet) {
              if (!multipleCredentialSourceWarningEmitted) {
                const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn : console.warn;
                warnFn(
                  `@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`
                );
                multipleCredentialSourceWarningEmitted = true;
              }
            }
            throw new import_property_provider2.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
              logger: init.logger,
              tryNextLink: true
            });
          }
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
          return (0, import_credential_provider_env.fromEnv)(init)();
        },
        async () => {
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
          const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
          if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
            throw new import_property_provider2.CredentialsProviderError(
              "Skipping SSO provider in default chain (inputs do not include SSO fields).",
              { logger: init.logger }
            );
          }
          const { fromSSO } = await Promise.resolve().then(() => __toESM2(require_dist_cjs46()));
          return fromSSO(init)();
        },
        async () => {
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
          const { fromIni } = await Promise.resolve().then(() => __toESM2(require_dist_cjs49()));
          return fromIni(init)();
        },
        async () => {
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
          const { fromProcess } = await Promise.resolve().then(() => __toESM2(require_dist_cjs47()));
          return fromProcess(init)();
        },
        async () => {
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
          const { fromTokenFile: fromTokenFile2 } = await Promise.resolve().then(() => __toESM2(require_dist_cjs48()));
          return fromTokenFile2(init)();
        },
        async () => {
          init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
          return (await remoteProvider(init))();
        },
        async () => {
          throw new import_property_provider2.CredentialsProviderError("Could not load credentials from any providers", {
            tryNextLink: false,
            logger: init.logger
          });
        }
      ),
      credentialsTreatedAsExpired,
      credentialsWillNeedRefresh
    ), "defaultProvider");
    var credentialsWillNeedRefresh = /* @__PURE__ */ __name((credentials) => credentials?.expiration !== void 0, "credentialsWillNeedRefresh");
    var credentialsTreatedAsExpired = /* @__PURE__ */ __name((credentials) => credentials?.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5, "credentialsTreatedAsExpired");
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/ruleset.js
var require_ruleset2 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/ruleset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ruleSet = void 0;
    var y2 = "required";
    var z3 = "fn";
    var A2 = "argv";
    var B2 = "ref";
    var C2 = "properties";
    var D2 = "headers";
    var a3 = true;
    var b3 = "isSet";
    var c3 = "booleanEquals";
    var d3 = "error";
    var e3 = "endpoint";
    var f3 = "tree";
    var g3 = "PartitionResult";
    var h3 = "stringEquals";
    var i3 = { [y2]: false, "type": "String" };
    var j3 = { [y2]: true, "default": false, "type": "Boolean" };
    var k3 = { [B2]: "Endpoint" };
    var l3 = { [z3]: c3, [A2]: [{ [B2]: "UseFIPS" }, true] };
    var m3 = { [z3]: c3, [A2]: [{ [B2]: "UseDualStack" }, true] };
    var n3 = {};
    var o3 = { [z3]: "getAttr", [A2]: [{ [B2]: g3 }, "supportsFIPS"] };
    var p3 = { [z3]: c3, [A2]: [true, { [z3]: "getAttr", [A2]: [{ [B2]: g3 }, "supportsDualStack"] }] };
    var q3 = { [z3]: "getAttr", [A2]: [{ [B2]: g3 }, "name"] };
    var r3 = { "url": "https://secretsmanager-fips.{Region}.amazonaws.com", [C2]: {}, [D2]: {} };
    var s3 = { "url": "https://secretsmanager.{Region}.amazonaws.com", [C2]: {}, [D2]: {} };
    var t3 = [l3];
    var u3 = [m3];
    var v6 = [{ [B2]: "Region" }];
    var w3 = [{ [z3]: h3, [A2]: ["aws", q3] }];
    var x3 = [{ [z3]: h3, [A2]: ["aws-us-gov", q3] }];
    var _data3 = { version: "1.0", parameters: { Region: i3, UseDualStack: j3, UseFIPS: j3, Endpoint: i3 }, rules: [{ conditions: [{ [z3]: b3, [A2]: [k3] }], rules: [{ conditions: t3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d3 }, { conditions: u3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d3 }, { endpoint: { url: k3, [C2]: n3, [D2]: n3 }, type: e3 }], type: f3 }, { conditions: [{ [z3]: b3, [A2]: v6 }], rules: [{ conditions: [{ [z3]: "aws.partition", [A2]: v6, assign: g3 }], rules: [{ conditions: [l3, m3], rules: [{ conditions: [{ [z3]: c3, [A2]: [a3, o3] }, p3], rules: [{ conditions: w3, endpoint: r3, type: e3 }, { conditions: x3, endpoint: r3, type: e3 }, { endpoint: { url: "https://secretsmanager-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [C2]: n3, [D2]: n3 }, type: e3 }], type: f3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d3 }], type: f3 }, { conditions: t3, rules: [{ conditions: [{ [z3]: c3, [A2]: [o3, a3] }], rules: [{ endpoint: { url: "https://secretsmanager-fips.{Region}.{PartitionResult#dnsSuffix}", [C2]: n3, [D2]: n3 }, type: e3 }], type: f3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d3 }], type: f3 }, { conditions: u3, rules: [{ conditions: [p3], rules: [{ conditions: w3, endpoint: s3, type: e3 }, { conditions: [{ [z3]: h3, [A2]: ["aws-cn", q3] }], endpoint: { url: "https://secretsmanager.{Region}.amazonaws.com.cn", [C2]: n3, [D2]: n3 }, type: e3 }, { conditions: x3, endpoint: s3, type: e3 }, { endpoint: { url: "https://secretsmanager.{Region}.{PartitionResult#dualStackDnsSuffix}", [C2]: n3, [D2]: n3 }, type: e3 }], type: f3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d3 }], type: f3 }, { endpoint: { url: "https://secretsmanager.{Region}.{PartitionResult#dnsSuffix}", [C2]: n3, [D2]: n3 }, type: e3 }], type: f3 }], type: f3 }, { error: "Invalid Configuration: Missing Region", type: d3 }] };
    exports.ruleSet = _data3;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/endpointResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultEndpointResolver = void 0;
    var util_endpoints_1 = require_dist_cjs19();
    var util_endpoints_2 = require_dist_cjs18();
    var ruleset_1 = require_ruleset2();
    var cache3 = new util_endpoints_2.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    var defaultEndpointResolver3 = (endpointParams, context = {}) => {
      return cache3.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    exports.defaultEndpointResolver = defaultEndpointResolver3;
    util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRuntimeConfig = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var smithy_client_1 = require_dist_cjs23();
    var url_parser_1 = require_dist_cjs31();
    var util_base64_1 = require_dist_cjs11();
    var util_utf8_1 = require_dist_cjs10();
    var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
    var endpointResolver_1 = require_endpointResolver2();
    var getRuntimeConfig5 = (config) => {
      return {
        apiVersion: "2017-10-17",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSecretsManagerHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new core_1.AwsSdkSigV4Signer()
          }
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "Secrets Manager",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
      };
    };
    exports.getRuntimeConfig = getRuntimeConfig5;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.js
var require_runtimeConfig2 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRuntimeConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var package_json_1 = tslib_1.__importDefault(require_package2());
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var credential_provider_node_1 = require_dist_cjs50();
    var util_user_agent_node_1 = require_dist_cjs39();
    var config_resolver_1 = require_dist_cjs26();
    var hash_node_1 = require_dist_cjs40();
    var middleware_retry_1 = require_dist_cjs35();
    var node_config_provider_1 = require_dist_cjs29();
    var node_http_handler_1 = require_dist_cjs14();
    var util_body_length_node_1 = require_dist_cjs41();
    var util_retry_1 = require_dist_cjs34();
    var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
    var smithy_client_1 = require_dist_cjs23();
    var util_defaults_mode_node_1 = require_dist_cjs42();
    var smithy_client_2 = require_dist_cjs23();
    var getRuntimeConfig5 = (config) => {
      (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
      const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
      (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
      const profileConfig = { profile: config?.profile };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_1.defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
        requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
          ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
      };
    };
    exports.getRuntimeConfig = getRuntimeConfig5;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/rng.js
import crypto6 from "crypto";
function rng2() {
  if (poolPtr2 > rnds8Pool2.length - 16) {
    crypto6.randomFillSync(rnds8Pool2);
    poolPtr2 = 0;
  }
  return rnds8Pool2.slice(poolPtr2, poolPtr2 += 16);
}
var rnds8Pool2, poolPtr2;
var init_rng2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool2 = new Uint8Array(256);
    poolPtr2 = rnds8Pool2.length;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/regex.js
var regex_default2;
var init_regex2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2;
var init_validate2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex2();
    validate_default2 = validate2;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify2(arr, offset = 0) {
  return byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]];
}
function stringify2(arr, offset = 0) {
  const uuid = unsafeStringify2(arr, offset);
  if (!validate_default2(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex2, stringify_default2;
var init_stringify2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate2();
    byteToHex2 = [];
    for (let i3 = 0; i3 < 256; ++i3) {
      byteToHex2.push((i3 + 256).toString(16).slice(1));
    }
    stringify_default2 = stringify2;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v1.js
function v12(options, buf, offset) {
  let i3 = buf && offset || 0;
  const b3 = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId2;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq2;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng2)();
    if (node == null) {
      node = _nodeId2 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq2 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs2 + 1;
  const dt = msecs - _lastMSecs2 + (nsecs - _lastNSecs2) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs2) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs2 = msecs;
  _lastNSecs2 = nsecs;
  _clockseq2 = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b3[i3++] = tl >>> 24 & 255;
  b3[i3++] = tl >>> 16 & 255;
  b3[i3++] = tl >>> 8 & 255;
  b3[i3++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b3[i3++] = tmh >>> 8 & 255;
  b3[i3++] = tmh & 255;
  b3[i3++] = tmh >>> 24 & 15 | 16;
  b3[i3++] = tmh >>> 16 & 255;
  b3[i3++] = clockseq >>> 8 | 128;
  b3[i3++] = clockseq & 255;
  for (let n3 = 0; n3 < 6; ++n3) {
    b3[i3 + n3] = node[n3];
  }
  return buf || unsafeStringify2(b3);
}
var _nodeId2, _clockseq2, _lastMSecs2, _lastNSecs2, v1_default2;
var init_v12 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng2();
    init_stringify2();
    _lastMSecs2 = 0;
    _lastNSecs2 = 0;
    v1_default2 = v12;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/parse.js
function parse3(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default2;
var init_parse2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate2();
    parse_default2 = parse3;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i3 = 0; i3 < str.length; ++i3) {
    bytes.push(str.charCodeAt(i3));
  }
  return bytes;
}
function v352(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default2(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version3;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i3 = 0; i3 < 16; ++i3) {
        buf[offset + i3] = bytes[i3];
      }
      return buf;
    }
    return unsafeStringify2(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS2;
  generateUUID.URL = URL3;
  return generateUUID;
}
var DNS2, URL3;
var init_v352 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify2();
    init_parse2();
    DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/md5.js
import crypto7 from "crypto";
function md52(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto7.createHash("md5").update(bytes).digest();
}
var md5_default2;
var init_md52 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/md5.js"() {
    md5_default2 = md52;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v3.js
var v32, v3_default2;
var init_v32 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v3.js"() {
    init_v352();
    init_md52();
    v32 = v352("v3", 48, md5_default2);
    v3_default2 = v32;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/native.js
import crypto8 from "crypto";
var native_default2;
var init_native2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/native.js"() {
    native_default2 = {
      randomUUID: crypto8.randomUUID
    };
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v4.js
function v42(options, buf, offset) {
  if (native_default2.randomUUID && !buf && !options) {
    return native_default2.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
var v4_default2;
var init_v42 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native2();
    init_rng2();
    init_stringify2();
    v4_default2 = v42;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/sha1.js
import crypto9 from "crypto";
function sha12(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto9.createHash("sha1").update(bytes).digest();
}
var sha1_default2;
var init_sha12 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default2 = sha12;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v5.js
var v52, v5_default2;
var init_v52 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v352();
    init_sha12();
    v52 = v352("v5", 80, sha1_default2);
    v5_default2 = v52;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/nil.js
var nil_default2;
var init_nil2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default2 = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/version.js
function version2(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default2;
var init_version2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/version.js"() {
    init_validate2();
    version_default2 = version2;
  }
});

// node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports2 = {};
__export(esm_node_exports2, {
  NIL: () => nil_default2,
  parse: () => parse_default2,
  stringify: () => stringify_default2,
  v1: () => v1_default2,
  v3: () => v3_default2,
  v4: () => v4_default2,
  v5: () => v5_default2,
  validate: () => validate_default2,
  version: () => version_default2
});
var init_esm_node2 = __esm({
  "node_modules/@aws-sdk/client-secrets-manager/node_modules/uuid/dist/esm-node/index.js"() {
    init_v12();
    init_v32();
    init_v42();
    init_v52();
    init_nil2();
    init_version2();
    init_validate2();
    init_stringify2();
    init_parse2();
  }
});

// node_modules/@aws-sdk/client-secrets-manager/dist-cjs/index.js
var require_dist_cjs51 = __commonJS({
  "node_modules/@aws-sdk/client-secrets-manager/dist-cjs/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      BatchGetSecretValueCommand: () => BatchGetSecretValueCommand,
      BatchGetSecretValueResponseFilterSensitiveLog: () => BatchGetSecretValueResponseFilterSensitiveLog,
      CancelRotateSecretCommand: () => CancelRotateSecretCommand,
      CreateSecretCommand: () => CreateSecretCommand,
      CreateSecretRequestFilterSensitiveLog: () => CreateSecretRequestFilterSensitiveLog,
      DecryptionFailure: () => DecryptionFailure,
      DeleteResourcePolicyCommand: () => DeleteResourcePolicyCommand,
      DeleteSecretCommand: () => DeleteSecretCommand,
      DescribeSecretCommand: () => DescribeSecretCommand,
      EncryptionFailure: () => EncryptionFailure,
      FilterNameStringType: () => FilterNameStringType,
      GetRandomPasswordCommand: () => GetRandomPasswordCommand,
      GetRandomPasswordResponseFilterSensitiveLog: () => GetRandomPasswordResponseFilterSensitiveLog,
      GetResourcePolicyCommand: () => GetResourcePolicyCommand,
      GetSecretValueCommand: () => GetSecretValueCommand2,
      GetSecretValueResponseFilterSensitiveLog: () => GetSecretValueResponseFilterSensitiveLog,
      InternalServiceError: () => InternalServiceError,
      InvalidNextTokenException: () => InvalidNextTokenException,
      InvalidParameterException: () => InvalidParameterException,
      InvalidRequestException: () => InvalidRequestException2,
      LimitExceededException: () => LimitExceededException,
      ListSecretVersionIdsCommand: () => ListSecretVersionIdsCommand,
      ListSecretsCommand: () => ListSecretsCommand,
      MalformedPolicyDocumentException: () => MalformedPolicyDocumentException2,
      PreconditionNotMetException: () => PreconditionNotMetException,
      PublicPolicyException: () => PublicPolicyException,
      PutResourcePolicyCommand: () => PutResourcePolicyCommand,
      PutSecretValueCommand: () => PutSecretValueCommand,
      PutSecretValueRequestFilterSensitiveLog: () => PutSecretValueRequestFilterSensitiveLog,
      RemoveRegionsFromReplicationCommand: () => RemoveRegionsFromReplicationCommand,
      ReplicateSecretToRegionsCommand: () => ReplicateSecretToRegionsCommand,
      ResourceExistsException: () => ResourceExistsException,
      ResourceNotFoundException: () => ResourceNotFoundException,
      RestoreSecretCommand: () => RestoreSecretCommand,
      RotateSecretCommand: () => RotateSecretCommand,
      SecretValueEntryFilterSensitiveLog: () => SecretValueEntryFilterSensitiveLog,
      SecretsManager: () => SecretsManager,
      SecretsManagerClient: () => SecretsManagerClient2,
      SecretsManagerServiceException: () => SecretsManagerServiceException,
      SortOrderType: () => SortOrderType,
      StatusType: () => StatusType,
      StopReplicationToReplicaCommand: () => StopReplicationToReplicaCommand,
      TagResourceCommand: () => TagResourceCommand,
      UntagResourceCommand: () => UntagResourceCommand,
      UpdateSecretCommand: () => UpdateSecretCommand,
      UpdateSecretRequestFilterSensitiveLog: () => UpdateSecretRequestFilterSensitiveLog,
      UpdateSecretVersionStageCommand: () => UpdateSecretVersionStageCommand,
      ValidateResourcePolicyCommand: () => ValidateResourcePolicyCommand,
      __Client: () => import_smithy_client25.Client,
      paginateBatchGetSecretValue: () => paginateBatchGetSecretValue,
      paginateListSecretVersionIds: () => paginateListSecretVersionIds,
      paginateListSecrets: () => paginateListSecrets
    });
    module.exports = __toCommonJS2(index_exports);
    var import_middleware_host_header3 = require_dist_cjs3();
    var import_middleware_logger3 = require_dist_cjs4();
    var import_middleware_recursion_detection3 = require_dist_cjs5();
    var import_middleware_user_agent3 = require_dist_cjs24();
    var import_config_resolver5 = require_dist_cjs26();
    var import_core17 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var import_middleware_content_length3 = require_dist_cjs27();
    var import_middleware_endpoint6 = require_dist_cjs32();
    var import_middleware_retry5 = require_dist_cjs35();
    var import_httpAuthSchemeProvider5 = require_httpAuthSchemeProvider();
    var resolveClientEndpointParameters3 = /* @__PURE__ */ __name((options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "secretsmanager"
      };
    }, "resolveClientEndpointParameters");
    var commonParams3 = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
    var import_runtimeConfig5 = require_runtimeConfig2();
    var import_region_config_resolver3 = require_dist_cjs43();
    var import_protocol_http11 = require_dist_cjs2();
    var import_smithy_client25 = require_dist_cjs23();
    var getHttpAuthExtensionConfiguration3 = /* @__PURE__ */ __name((runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    }, "getHttpAuthExtensionConfiguration");
    var resolveHttpAuthRuntimeConfig3 = /* @__PURE__ */ __name((config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    }, "resolveHttpAuthRuntimeConfig");
    var asPartial3 = /* @__PURE__ */ __name((t3) => t3, "asPartial");
    var resolveRuntimeExtensions3 = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
      const extensionConfiguration = {
        ...asPartial3((0, import_region_config_resolver3.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial3((0, import_smithy_client25.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial3((0, import_protocol_http11.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
        ...asPartial3(getHttpAuthExtensionConfiguration3(runtimeConfig))
      };
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return {
        ...runtimeConfig,
        ...(0, import_region_config_resolver3.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, import_smithy_client25.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, import_protocol_http11.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig3(extensionConfiguration)
      };
    }, "resolveRuntimeExtensions");
    var SecretsManagerClient2 = class extends import_smithy_client25.Client {
      static {
        __name(this, "SecretsManagerClient");
      }
      /**
       * The resolved configuration of SecretsManagerClient class. This is resolved and normalized from the {@link SecretsManagerClientConfig | constructor configuration interface}.
       */
      config;
      constructor(...[configuration]) {
        const _config_0 = (0, import_runtimeConfig5.getRuntimeConfig)(configuration || {});
        const _config_1 = resolveClientEndpointParameters3(_config_0);
        const _config_2 = (0, import_middleware_user_agent3.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry5.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver5.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header3.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint6.resolveEndpointConfig)(_config_5);
        const _config_7 = (0, import_httpAuthSchemeProvider5.resolveHttpAuthSchemeConfig)(_config_6);
        const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, import_middleware_user_agent3.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry5.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length3.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header3.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger3.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection3.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(
          (0, import_core17.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: import_httpAuthSchemeProvider5.defaultSecretsManagerHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: /* @__PURE__ */ __name(async (config) => new import_core17.DefaultIdentityProviderConfig({
              "aws.auth#sigv4": config.credentials
            }), "identityProviderConfigProvider")
          })
        );
        this.middlewareStack.use((0, import_core17.getHttpSigningPlugin)(this.config));
      }
      /**
       * Destroy underlying resources, like sockets. It's usually not necessary to do this.
       * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
       * Otherwise, sockets might stay open for quite a long time before the server terminates them.
       */
      destroy() {
        super.destroy();
      }
    };
    var import_middleware_serde5 = require_dist_cjs7();
    var SecretsManagerServiceException = class _SecretsManagerServiceException extends import_smithy_client25.ServiceException {
      static {
        __name(this, "SecretsManagerServiceException");
      }
      /**
       * @internal
       */
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SecretsManagerServiceException.prototype);
      }
    };
    var FilterNameStringType = {
      all: "all",
      description: "description",
      name: "name",
      owning_service: "owning-service",
      primary_region: "primary-region",
      tag_key: "tag-key",
      tag_value: "tag-value"
    };
    var DecryptionFailure = class _DecryptionFailure extends SecretsManagerServiceException {
      static {
        __name(this, "DecryptionFailure");
      }
      name = "DecryptionFailure";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "DecryptionFailure",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _DecryptionFailure.prototype);
        this.Message = opts.Message;
      }
    };
    var InternalServiceError = class _InternalServiceError extends SecretsManagerServiceException {
      static {
        __name(this, "InternalServiceError");
      }
      name = "InternalServiceError";
      $fault = "server";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "InternalServiceError",
          $fault: "server",
          ...opts
        });
        Object.setPrototypeOf(this, _InternalServiceError.prototype);
        this.Message = opts.Message;
      }
    };
    var InvalidNextTokenException = class _InvalidNextTokenException extends SecretsManagerServiceException {
      static {
        __name(this, "InvalidNextTokenException");
      }
      name = "InvalidNextTokenException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "InvalidNextTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidNextTokenException.prototype);
        this.Message = opts.Message;
      }
    };
    var InvalidParameterException = class _InvalidParameterException extends SecretsManagerServiceException {
      static {
        __name(this, "InvalidParameterException");
      }
      name = "InvalidParameterException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "InvalidParameterException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidParameterException.prototype);
        this.Message = opts.Message;
      }
    };
    var InvalidRequestException2 = class _InvalidRequestException extends SecretsManagerServiceException {
      static {
        __name(this, "InvalidRequestException");
      }
      name = "InvalidRequestException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.Message = opts.Message;
      }
    };
    var ResourceNotFoundException = class _ResourceNotFoundException extends SecretsManagerServiceException {
      static {
        __name(this, "ResourceNotFoundException");
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
        this.Message = opts.Message;
      }
    };
    var StatusType = {
      Failed: "Failed",
      InProgress: "InProgress",
      InSync: "InSync"
    };
    var EncryptionFailure = class _EncryptionFailure extends SecretsManagerServiceException {
      static {
        __name(this, "EncryptionFailure");
      }
      name = "EncryptionFailure";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "EncryptionFailure",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _EncryptionFailure.prototype);
        this.Message = opts.Message;
      }
    };
    var LimitExceededException = class _LimitExceededException extends SecretsManagerServiceException {
      static {
        __name(this, "LimitExceededException");
      }
      name = "LimitExceededException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "LimitExceededException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _LimitExceededException.prototype);
        this.Message = opts.Message;
      }
    };
    var MalformedPolicyDocumentException2 = class _MalformedPolicyDocumentException extends SecretsManagerServiceException {
      static {
        __name(this, "MalformedPolicyDocumentException");
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
        this.Message = opts.Message;
      }
    };
    var PreconditionNotMetException = class _PreconditionNotMetException extends SecretsManagerServiceException {
      static {
        __name(this, "PreconditionNotMetException");
      }
      name = "PreconditionNotMetException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "PreconditionNotMetException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _PreconditionNotMetException.prototype);
        this.Message = opts.Message;
      }
    };
    var ResourceExistsException = class _ResourceExistsException extends SecretsManagerServiceException {
      static {
        __name(this, "ResourceExistsException");
      }
      name = "ResourceExistsException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "ResourceExistsException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ResourceExistsException.prototype);
        this.Message = opts.Message;
      }
    };
    var SortOrderType = {
      asc: "asc",
      desc: "desc"
    };
    var PublicPolicyException = class _PublicPolicyException extends SecretsManagerServiceException {
      static {
        __name(this, "PublicPolicyException");
      }
      name = "PublicPolicyException";
      $fault = "client";
      Message;
      /**
       * @internal
       */
      constructor(opts) {
        super({
          name: "PublicPolicyException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _PublicPolicyException.prototype);
        this.Message = opts.Message;
      }
    };
    var SecretValueEntryFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretBinary && { SecretBinary: import_smithy_client25.SENSITIVE_STRING },
      ...obj.SecretString && { SecretString: import_smithy_client25.SENSITIVE_STRING }
    }), "SecretValueEntryFilterSensitiveLog");
    var BatchGetSecretValueResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretValues && { SecretValues: obj.SecretValues.map((item) => SecretValueEntryFilterSensitiveLog(item)) }
    }), "BatchGetSecretValueResponseFilterSensitiveLog");
    var CreateSecretRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretBinary && { SecretBinary: import_smithy_client25.SENSITIVE_STRING },
      ...obj.SecretString && { SecretString: import_smithy_client25.SENSITIVE_STRING }
    }), "CreateSecretRequestFilterSensitiveLog");
    var GetRandomPasswordResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.RandomPassword && { RandomPassword: import_smithy_client25.SENSITIVE_STRING }
    }), "GetRandomPasswordResponseFilterSensitiveLog");
    var GetSecretValueResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretBinary && { SecretBinary: import_smithy_client25.SENSITIVE_STRING },
      ...obj.SecretString && { SecretString: import_smithy_client25.SENSITIVE_STRING }
    }), "GetSecretValueResponseFilterSensitiveLog");
    var PutSecretValueRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretBinary && { SecretBinary: import_smithy_client25.SENSITIVE_STRING },
      ...obj.SecretString && { SecretString: import_smithy_client25.SENSITIVE_STRING },
      ...obj.RotationToken && { RotationToken: import_smithy_client25.SENSITIVE_STRING }
    }), "PutSecretValueRequestFilterSensitiveLog");
    var UpdateSecretRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
      ...obj,
      ...obj.SecretBinary && { SecretBinary: import_smithy_client25.SENSITIVE_STRING },
      ...obj.SecretString && { SecretString: import_smithy_client25.SENSITIVE_STRING }
    }), "UpdateSecretRequestFilterSensitiveLog");
    var import_core22 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var import_uuid = (init_esm_node2(), __toCommonJS(esm_node_exports2));
    var se_BatchGetSecretValueCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("BatchGetSecretValue");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_BatchGetSecretValueCommand");
    var se_CancelRotateSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("CancelRotateSecret");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_CancelRotateSecretCommand");
    var se_CreateSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("CreateSecret");
      let body;
      body = JSON.stringify(se_CreateSecretRequest(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_CreateSecretCommand");
    var se_DeleteResourcePolicyCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("DeleteResourcePolicy");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_DeleteResourcePolicyCommand");
    var se_DeleteSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("DeleteSecret");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_DeleteSecretCommand");
    var se_DescribeSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("DescribeSecret");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_DescribeSecretCommand");
    var se_GetRandomPasswordCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("GetRandomPassword");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_GetRandomPasswordCommand");
    var se_GetResourcePolicyCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("GetResourcePolicy");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_GetResourcePolicyCommand");
    var se_GetSecretValueCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("GetSecretValue");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_GetSecretValueCommand");
    var se_ListSecretsCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("ListSecrets");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_ListSecretsCommand");
    var se_ListSecretVersionIdsCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("ListSecretVersionIds");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_ListSecretVersionIdsCommand");
    var se_PutResourcePolicyCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("PutResourcePolicy");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_PutResourcePolicyCommand");
    var se_PutSecretValueCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("PutSecretValue");
      let body;
      body = JSON.stringify(se_PutSecretValueRequest(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_PutSecretValueCommand");
    var se_RemoveRegionsFromReplicationCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("RemoveRegionsFromReplication");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_RemoveRegionsFromReplicationCommand");
    var se_ReplicateSecretToRegionsCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("ReplicateSecretToRegions");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_ReplicateSecretToRegionsCommand");
    var se_RestoreSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("RestoreSecret");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_RestoreSecretCommand");
    var se_RotateSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("RotateSecret");
      let body;
      body = JSON.stringify(se_RotateSecretRequest(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_RotateSecretCommand");
    var se_StopReplicationToReplicaCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("StopReplicationToReplica");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_StopReplicationToReplicaCommand");
    var se_TagResourceCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("TagResource");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_TagResourceCommand");
    var se_UntagResourceCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("UntagResource");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_UntagResourceCommand");
    var se_UpdateSecretCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("UpdateSecret");
      let body;
      body = JSON.stringify(se_UpdateSecretRequest(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_UpdateSecretCommand");
    var se_UpdateSecretVersionStageCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("UpdateSecretVersionStage");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_UpdateSecretVersionStageCommand");
    var se_ValidateResourcePolicyCommand = /* @__PURE__ */ __name(async (input, context) => {
      const headers = sharedHeaders("ValidateResourcePolicy");
      let body;
      body = JSON.stringify((0, import_smithy_client25._json)(input));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    }, "se_ValidateResourcePolicyCommand");
    var de_BatchGetSecretValueCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_BatchGetSecretValueResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_BatchGetSecretValueCommand");
    var de_CancelRotateSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_CancelRotateSecretCommand");
    var de_CreateSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_CreateSecretResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_CreateSecretCommand");
    var de_DeleteResourcePolicyCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_DeleteResourcePolicyCommand");
    var de_DeleteSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_DeleteSecretResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_DeleteSecretCommand");
    var de_DescribeSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_DescribeSecretResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_DescribeSecretCommand");
    var de_GetRandomPasswordCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_GetRandomPasswordCommand");
    var de_GetResourcePolicyCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_GetResourcePolicyCommand");
    var de_GetSecretValueCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_GetSecretValueResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_GetSecretValueCommand");
    var de_ListSecretsCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_ListSecretsResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_ListSecretsCommand");
    var de_ListSecretVersionIdsCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_ListSecretVersionIdsResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_ListSecretVersionIdsCommand");
    var de_PutResourcePolicyCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_PutResourcePolicyCommand");
    var de_PutSecretValueCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_PutSecretValueCommand");
    var de_RemoveRegionsFromReplicationCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_RemoveRegionsFromReplicationResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_RemoveRegionsFromReplicationCommand");
    var de_ReplicateSecretToRegionsCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = de_ReplicateSecretToRegionsResponse(data, context);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_ReplicateSecretToRegionsCommand");
    var de_RestoreSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_RestoreSecretCommand");
    var de_RotateSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_RotateSecretCommand");
    var de_StopReplicationToReplicaCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_StopReplicationToReplicaCommand");
    var de_TagResourceCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      await (0, import_smithy_client25.collectBody)(output.body, context);
      const response = {
        $metadata: deserializeMetadata3(output)
      };
      return response;
    }, "de_TagResourceCommand");
    var de_UntagResourceCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      await (0, import_smithy_client25.collectBody)(output.body, context);
      const response = {
        $metadata: deserializeMetadata3(output)
      };
      return response;
    }, "de_UntagResourceCommand");
    var de_UpdateSecretCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_UpdateSecretCommand");
    var de_UpdateSecretVersionStageCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_UpdateSecretVersionStageCommand");
    var de_ValidateResourcePolicyCommand = /* @__PURE__ */ __name(async (output, context) => {
      if (output.statusCode >= 300) {
        return de_CommandError3(output, context);
      }
      const data = await (0, import_core22.parseJsonBody)(output.body, context);
      let contents = {};
      contents = (0, import_smithy_client25._json)(data);
      const response = {
        $metadata: deserializeMetadata3(output),
        ...contents
      };
      return response;
    }, "de_ValidateResourcePolicyCommand");
    var de_CommandError3 = /* @__PURE__ */ __name(async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await (0, import_core22.parseJsonErrorBody)(output.body, context)
      };
      const errorCode = (0, import_core22.loadRestJsonErrorCode)(output, parsedOutput.body);
      switch (errorCode) {
        case "DecryptionFailure":
        case "com.amazonaws.secretsmanager#DecryptionFailure":
          throw await de_DecryptionFailureRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.secretsmanager#InternalServiceError":
          throw await de_InternalServiceErrorRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.secretsmanager#InvalidNextTokenException":
          throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.secretsmanager#InvalidParameterException":
          throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.secretsmanager#InvalidRequestException":
          throw await de_InvalidRequestExceptionRes2(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.secretsmanager#ResourceNotFoundException":
          throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionFailure":
        case "com.amazonaws.secretsmanager#EncryptionFailure":
          throw await de_EncryptionFailureRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.secretsmanager#LimitExceededException":
          throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.secretsmanager#MalformedPolicyDocumentException":
          throw await de_MalformedPolicyDocumentExceptionRes2(parsedOutput, context);
        case "PreconditionNotMetException":
        case "com.amazonaws.secretsmanager#PreconditionNotMetException":
          throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
        case "ResourceExistsException":
        case "com.amazonaws.secretsmanager#ResourceExistsException":
          throw await de_ResourceExistsExceptionRes(parsedOutput, context);
        case "PublicPolicyException":
        case "com.amazonaws.secretsmanager#PublicPolicyException":
          throw await de_PublicPolicyExceptionRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError3({
            output,
            parsedBody,
            errorCode
          });
      }
    }, "de_CommandError");
    var de_DecryptionFailureRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new DecryptionFailure({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_DecryptionFailureRes");
    var de_EncryptionFailureRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new EncryptionFailure({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_EncryptionFailureRes");
    var de_InternalServiceErrorRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new InternalServiceError({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_InternalServiceErrorRes");
    var de_InvalidNextTokenExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new InvalidNextTokenException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_InvalidNextTokenExceptionRes");
    var de_InvalidParameterExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new InvalidParameterException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_InvalidParameterExceptionRes");
    var de_InvalidRequestExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new InvalidRequestException2({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_InvalidRequestExceptionRes");
    var de_LimitExceededExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new LimitExceededException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_LimitExceededExceptionRes");
    var de_MalformedPolicyDocumentExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new MalformedPolicyDocumentException2({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_MalformedPolicyDocumentExceptionRes");
    var de_PreconditionNotMetExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new PreconditionNotMetException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_PreconditionNotMetExceptionRes");
    var de_PublicPolicyExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new PublicPolicyException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_PublicPolicyExceptionRes");
    var de_ResourceExistsExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new ResourceExistsException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_ResourceExistsExceptionRes");
    var de_ResourceNotFoundExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = (0, import_smithy_client25._json)(body);
      const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...deserialized
      });
      return (0, import_smithy_client25.decorateServiceException)(exception, body);
    }, "de_ResourceNotFoundExceptionRes");
    var se_CreateSecretRequest = /* @__PURE__ */ __name((input, context) => {
      return (0, import_smithy_client25.take)(input, {
        AddReplicaRegions: import_smithy_client25._json,
        ClientRequestToken: [true, (_2) => _2 ?? (0, import_uuid.v4)()],
        Description: [],
        ForceOverwriteReplicaSecret: [],
        KmsKeyId: [],
        Name: [],
        SecretBinary: context.base64Encoder,
        SecretString: [],
        Tags: import_smithy_client25._json
      });
    }, "se_CreateSecretRequest");
    var se_PutSecretValueRequest = /* @__PURE__ */ __name((input, context) => {
      return (0, import_smithy_client25.take)(input, {
        ClientRequestToken: [true, (_2) => _2 ?? (0, import_uuid.v4)()],
        RotationToken: [],
        SecretBinary: context.base64Encoder,
        SecretId: [],
        SecretString: [],
        VersionStages: import_smithy_client25._json
      });
    }, "se_PutSecretValueRequest");
    var se_RotateSecretRequest = /* @__PURE__ */ __name((input, context) => {
      return (0, import_smithy_client25.take)(input, {
        ClientRequestToken: [true, (_2) => _2 ?? (0, import_uuid.v4)()],
        RotateImmediately: [],
        RotationLambdaARN: [],
        RotationRules: import_smithy_client25._json,
        SecretId: []
      });
    }, "se_RotateSecretRequest");
    var se_UpdateSecretRequest = /* @__PURE__ */ __name((input, context) => {
      return (0, import_smithy_client25.take)(input, {
        ClientRequestToken: [true, (_2) => _2 ?? (0, import_uuid.v4)()],
        Description: [],
        KmsKeyId: [],
        SecretBinary: context.base64Encoder,
        SecretId: [],
        SecretString: []
      });
    }, "se_UpdateSecretRequest");
    var de_BatchGetSecretValueResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        Errors: import_smithy_client25._json,
        NextToken: import_smithy_client25.expectString,
        SecretValues: /* @__PURE__ */ __name((_2) => de_SecretValuesType(_2, context), "SecretValues")
      });
    }, "de_BatchGetSecretValueResponse");
    var de_CreateSecretResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        Name: import_smithy_client25.expectString,
        ReplicationStatus: /* @__PURE__ */ __name((_2) => de_ReplicationStatusListType(_2, context), "ReplicationStatus"),
        VersionId: import_smithy_client25.expectString
      });
    }, "de_CreateSecretResponse");
    var de_DeleteSecretResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        DeletionDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "DeletionDate"),
        Name: import_smithy_client25.expectString
      });
    }, "de_DeleteSecretResponse");
    var de_DescribeSecretResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        CreatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "CreatedDate"),
        DeletedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "DeletedDate"),
        Description: import_smithy_client25.expectString,
        KmsKeyId: import_smithy_client25.expectString,
        LastAccessedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastAccessedDate"),
        LastChangedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastChangedDate"),
        LastRotatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastRotatedDate"),
        Name: import_smithy_client25.expectString,
        NextRotationDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "NextRotationDate"),
        OwningService: import_smithy_client25.expectString,
        PrimaryRegion: import_smithy_client25.expectString,
        ReplicationStatus: /* @__PURE__ */ __name((_2) => de_ReplicationStatusListType(_2, context), "ReplicationStatus"),
        RotationEnabled: import_smithy_client25.expectBoolean,
        RotationLambdaARN: import_smithy_client25.expectString,
        RotationRules: import_smithy_client25._json,
        Tags: import_smithy_client25._json,
        VersionIdsToStages: import_smithy_client25._json
      });
    }, "de_DescribeSecretResponse");
    var de_GetSecretValueResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        CreatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "CreatedDate"),
        Name: import_smithy_client25.expectString,
        SecretBinary: context.base64Decoder,
        SecretString: import_smithy_client25.expectString,
        VersionId: import_smithy_client25.expectString,
        VersionStages: import_smithy_client25._json
      });
    }, "de_GetSecretValueResponse");
    var de_ListSecretsResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        NextToken: import_smithy_client25.expectString,
        SecretList: /* @__PURE__ */ __name((_2) => de_SecretListType(_2, context), "SecretList")
      });
    }, "de_ListSecretsResponse");
    var de_ListSecretVersionIdsResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        Name: import_smithy_client25.expectString,
        NextToken: import_smithy_client25.expectString,
        Versions: /* @__PURE__ */ __name((_2) => de_SecretVersionsListType(_2, context), "Versions")
      });
    }, "de_ListSecretVersionIdsResponse");
    var de_RemoveRegionsFromReplicationResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        ReplicationStatus: /* @__PURE__ */ __name((_2) => de_ReplicationStatusListType(_2, context), "ReplicationStatus")
      });
    }, "de_RemoveRegionsFromReplicationResponse");
    var de_ReplicateSecretToRegionsResponse = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        ReplicationStatus: /* @__PURE__ */ __name((_2) => de_ReplicationStatusListType(_2, context), "ReplicationStatus")
      });
    }, "de_ReplicateSecretToRegionsResponse");
    var de_ReplicationStatusListType = /* @__PURE__ */ __name((output, context) => {
      const retVal = (output || []).filter((e3) => e3 != null).map((entry) => {
        return de_ReplicationStatusType(entry, context);
      });
      return retVal;
    }, "de_ReplicationStatusListType");
    var de_ReplicationStatusType = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        KmsKeyId: import_smithy_client25.expectString,
        LastAccessedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastAccessedDate"),
        Region: import_smithy_client25.expectString,
        Status: import_smithy_client25.expectString,
        StatusMessage: import_smithy_client25.expectString
      });
    }, "de_ReplicationStatusType");
    var de_SecretListEntry = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        CreatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "CreatedDate"),
        DeletedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "DeletedDate"),
        Description: import_smithy_client25.expectString,
        KmsKeyId: import_smithy_client25.expectString,
        LastAccessedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastAccessedDate"),
        LastChangedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastChangedDate"),
        LastRotatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastRotatedDate"),
        Name: import_smithy_client25.expectString,
        NextRotationDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "NextRotationDate"),
        OwningService: import_smithy_client25.expectString,
        PrimaryRegion: import_smithy_client25.expectString,
        RotationEnabled: import_smithy_client25.expectBoolean,
        RotationLambdaARN: import_smithy_client25.expectString,
        RotationRules: import_smithy_client25._json,
        SecretVersionsToStages: import_smithy_client25._json,
        Tags: import_smithy_client25._json
      });
    }, "de_SecretListEntry");
    var de_SecretListType = /* @__PURE__ */ __name((output, context) => {
      const retVal = (output || []).filter((e3) => e3 != null).map((entry) => {
        return de_SecretListEntry(entry, context);
      });
      return retVal;
    }, "de_SecretListType");
    var de_SecretValueEntry = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        ARN: import_smithy_client25.expectString,
        CreatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "CreatedDate"),
        Name: import_smithy_client25.expectString,
        SecretBinary: context.base64Decoder,
        SecretString: import_smithy_client25.expectString,
        VersionId: import_smithy_client25.expectString,
        VersionStages: import_smithy_client25._json
      });
    }, "de_SecretValueEntry");
    var de_SecretValuesType = /* @__PURE__ */ __name((output, context) => {
      const retVal = (output || []).filter((e3) => e3 != null).map((entry) => {
        return de_SecretValueEntry(entry, context);
      });
      return retVal;
    }, "de_SecretValuesType");
    var de_SecretVersionsListEntry = /* @__PURE__ */ __name((output, context) => {
      return (0, import_smithy_client25.take)(output, {
        CreatedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "CreatedDate"),
        KmsKeyIds: import_smithy_client25._json,
        LastAccessedDate: /* @__PURE__ */ __name((_2) => (0, import_smithy_client25.expectNonNull)((0, import_smithy_client25.parseEpochTimestamp)((0, import_smithy_client25.expectNumber)(_2))), "LastAccessedDate"),
        VersionId: import_smithy_client25.expectString,
        VersionStages: import_smithy_client25._json
      });
    }, "de_SecretVersionsListEntry");
    var de_SecretVersionsListType = /* @__PURE__ */ __name((output, context) => {
      const retVal = (output || []).filter((e3) => e3 != null).map((entry) => {
        return de_SecretVersionsListEntry(entry, context);
      });
      return retVal;
    }, "de_SecretVersionsListType");
    var deserializeMetadata3 = /* @__PURE__ */ __name((output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    }), "deserializeMetadata");
    var throwDefaultError3 = (0, import_smithy_client25.withBaseException)(SecretsManagerServiceException);
    var buildHttpRpcRequest2 = /* @__PURE__ */ __name(async (context, headers, path, resolvedHostname, body) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
      };
      if (resolvedHostname !== void 0) {
        contents.hostname = resolvedHostname;
      }
      if (body !== void 0) {
        contents.body = body;
      }
      return new import_protocol_http11.HttpRequest(contents);
    }, "buildHttpRpcRequest");
    function sharedHeaders(operation) {
      return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `secretsmanager.${operation}`
      };
    }
    __name(sharedHeaders, "sharedHeaders");
    var BatchGetSecretValueCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "BatchGetSecretValue", {}).n("SecretsManagerClient", "BatchGetSecretValueCommand").f(void 0, BatchGetSecretValueResponseFilterSensitiveLog).ser(se_BatchGetSecretValueCommand).de(de_BatchGetSecretValueCommand).build() {
      static {
        __name(this, "BatchGetSecretValueCommand");
      }
    };
    var CancelRotateSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "CancelRotateSecret", {}).n("SecretsManagerClient", "CancelRotateSecretCommand").f(void 0, void 0).ser(se_CancelRotateSecretCommand).de(de_CancelRotateSecretCommand).build() {
      static {
        __name(this, "CancelRotateSecretCommand");
      }
    };
    var CreateSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "CreateSecret", {}).n("SecretsManagerClient", "CreateSecretCommand").f(CreateSecretRequestFilterSensitiveLog, void 0).ser(se_CreateSecretCommand).de(de_CreateSecretCommand).build() {
      static {
        __name(this, "CreateSecretCommand");
      }
    };
    var DeleteResourcePolicyCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "DeleteResourcePolicy", {}).n("SecretsManagerClient", "DeleteResourcePolicyCommand").f(void 0, void 0).ser(se_DeleteResourcePolicyCommand).de(de_DeleteResourcePolicyCommand).build() {
      static {
        __name(this, "DeleteResourcePolicyCommand");
      }
    };
    var DeleteSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "DeleteSecret", {}).n("SecretsManagerClient", "DeleteSecretCommand").f(void 0, void 0).ser(se_DeleteSecretCommand).de(de_DeleteSecretCommand).build() {
      static {
        __name(this, "DeleteSecretCommand");
      }
    };
    var DescribeSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "DescribeSecret", {}).n("SecretsManagerClient", "DescribeSecretCommand").f(void 0, void 0).ser(se_DescribeSecretCommand).de(de_DescribeSecretCommand).build() {
      static {
        __name(this, "DescribeSecretCommand");
      }
    };
    var GetRandomPasswordCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "GetRandomPassword", {}).n("SecretsManagerClient", "GetRandomPasswordCommand").f(void 0, GetRandomPasswordResponseFilterSensitiveLog).ser(se_GetRandomPasswordCommand).de(de_GetRandomPasswordCommand).build() {
      static {
        __name(this, "GetRandomPasswordCommand");
      }
    };
    var GetResourcePolicyCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "GetResourcePolicy", {}).n("SecretsManagerClient", "GetResourcePolicyCommand").f(void 0, void 0).ser(se_GetResourcePolicyCommand).de(de_GetResourcePolicyCommand).build() {
      static {
        __name(this, "GetResourcePolicyCommand");
      }
    };
    var GetSecretValueCommand2 = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "GetSecretValue", {}).n("SecretsManagerClient", "GetSecretValueCommand").f(void 0, GetSecretValueResponseFilterSensitiveLog).ser(se_GetSecretValueCommand).de(de_GetSecretValueCommand).build() {
      static {
        __name(this, "GetSecretValueCommand");
      }
    };
    var ListSecretsCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "ListSecrets", {}).n("SecretsManagerClient", "ListSecretsCommand").f(void 0, void 0).ser(se_ListSecretsCommand).de(de_ListSecretsCommand).build() {
      static {
        __name(this, "ListSecretsCommand");
      }
    };
    var ListSecretVersionIdsCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "ListSecretVersionIds", {}).n("SecretsManagerClient", "ListSecretVersionIdsCommand").f(void 0, void 0).ser(se_ListSecretVersionIdsCommand).de(de_ListSecretVersionIdsCommand).build() {
      static {
        __name(this, "ListSecretVersionIdsCommand");
      }
    };
    var PutResourcePolicyCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "PutResourcePolicy", {}).n("SecretsManagerClient", "PutResourcePolicyCommand").f(void 0, void 0).ser(se_PutResourcePolicyCommand).de(de_PutResourcePolicyCommand).build() {
      static {
        __name(this, "PutResourcePolicyCommand");
      }
    };
    var PutSecretValueCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "PutSecretValue", {}).n("SecretsManagerClient", "PutSecretValueCommand").f(PutSecretValueRequestFilterSensitiveLog, void 0).ser(se_PutSecretValueCommand).de(de_PutSecretValueCommand).build() {
      static {
        __name(this, "PutSecretValueCommand");
      }
    };
    var RemoveRegionsFromReplicationCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "RemoveRegionsFromReplication", {}).n("SecretsManagerClient", "RemoveRegionsFromReplicationCommand").f(void 0, void 0).ser(se_RemoveRegionsFromReplicationCommand).de(de_RemoveRegionsFromReplicationCommand).build() {
      static {
        __name(this, "RemoveRegionsFromReplicationCommand");
      }
    };
    var ReplicateSecretToRegionsCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "ReplicateSecretToRegions", {}).n("SecretsManagerClient", "ReplicateSecretToRegionsCommand").f(void 0, void 0).ser(se_ReplicateSecretToRegionsCommand).de(de_ReplicateSecretToRegionsCommand).build() {
      static {
        __name(this, "ReplicateSecretToRegionsCommand");
      }
    };
    var RestoreSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "RestoreSecret", {}).n("SecretsManagerClient", "RestoreSecretCommand").f(void 0, void 0).ser(se_RestoreSecretCommand).de(de_RestoreSecretCommand).build() {
      static {
        __name(this, "RestoreSecretCommand");
      }
    };
    var RotateSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "RotateSecret", {}).n("SecretsManagerClient", "RotateSecretCommand").f(void 0, void 0).ser(se_RotateSecretCommand).de(de_RotateSecretCommand).build() {
      static {
        __name(this, "RotateSecretCommand");
      }
    };
    var StopReplicationToReplicaCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "StopReplicationToReplica", {}).n("SecretsManagerClient", "StopReplicationToReplicaCommand").f(void 0, void 0).ser(se_StopReplicationToReplicaCommand).de(de_StopReplicationToReplicaCommand).build() {
      static {
        __name(this, "StopReplicationToReplicaCommand");
      }
    };
    var TagResourceCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "TagResource", {}).n("SecretsManagerClient", "TagResourceCommand").f(void 0, void 0).ser(se_TagResourceCommand).de(de_TagResourceCommand).build() {
      static {
        __name(this, "TagResourceCommand");
      }
    };
    var UntagResourceCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "UntagResource", {}).n("SecretsManagerClient", "UntagResourceCommand").f(void 0, void 0).ser(se_UntagResourceCommand).de(de_UntagResourceCommand).build() {
      static {
        __name(this, "UntagResourceCommand");
      }
    };
    var UpdateSecretCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "UpdateSecret", {}).n("SecretsManagerClient", "UpdateSecretCommand").f(UpdateSecretRequestFilterSensitiveLog, void 0).ser(se_UpdateSecretCommand).de(de_UpdateSecretCommand).build() {
      static {
        __name(this, "UpdateSecretCommand");
      }
    };
    var UpdateSecretVersionStageCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "UpdateSecretVersionStage", {}).n("SecretsManagerClient", "UpdateSecretVersionStageCommand").f(void 0, void 0).ser(se_UpdateSecretVersionStageCommand).de(de_UpdateSecretVersionStageCommand).build() {
      static {
        __name(this, "UpdateSecretVersionStageCommand");
      }
    };
    var ValidateResourcePolicyCommand = class extends import_smithy_client25.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o3) {
      return [
        (0, import_middleware_serde5.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())
      ];
    }).s("secretsmanager", "ValidateResourcePolicy", {}).n("SecretsManagerClient", "ValidateResourcePolicyCommand").f(void 0, void 0).ser(se_ValidateResourcePolicyCommand).de(de_ValidateResourcePolicyCommand).build() {
      static {
        __name(this, "ValidateResourcePolicyCommand");
      }
    };
    var commands3 = {
      BatchGetSecretValueCommand,
      CancelRotateSecretCommand,
      CreateSecretCommand,
      DeleteResourcePolicyCommand,
      DeleteSecretCommand,
      DescribeSecretCommand,
      GetRandomPasswordCommand,
      GetResourcePolicyCommand,
      GetSecretValueCommand: GetSecretValueCommand2,
      ListSecretsCommand,
      ListSecretVersionIdsCommand,
      PutResourcePolicyCommand,
      PutSecretValueCommand,
      RemoveRegionsFromReplicationCommand,
      ReplicateSecretToRegionsCommand,
      RestoreSecretCommand,
      RotateSecretCommand,
      StopReplicationToReplicaCommand,
      TagResourceCommand,
      UntagResourceCommand,
      UpdateSecretCommand,
      UpdateSecretVersionStageCommand,
      ValidateResourcePolicyCommand
    };
    var SecretsManager = class extends SecretsManagerClient2 {
      static {
        __name(this, "SecretsManager");
      }
    };
    (0, import_smithy_client25.createAggregatedClient)(commands3, SecretsManager);
    var paginateBatchGetSecretValue = (0, import_core17.createPaginator)(SecretsManagerClient2, BatchGetSecretValueCommand, "NextToken", "NextToken", "MaxResults");
    var paginateListSecretVersionIds = (0, import_core17.createPaginator)(SecretsManagerClient2, ListSecretVersionIdsCommand, "NextToken", "NextToken", "MaxResults");
    var paginateListSecrets = (0, import_core17.createPaginator)(SecretsManagerClient2, ListSecretsCommand, "NextToken", "NextToken", "MaxResults");
  }
});

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val2) => val2;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val2) => Number.isInteger(val2) : (val2) => typeof val2 === "number" && isFinite(val2) && Math.floor(val2) === val2;
  function joinValues(array, separator = " | ") {
    return array.map((val2) => typeof val2 === "string" ? `'${val2}'` : val2).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x3) => x3.status === "aborted";
var isDirty = (x3) => x3.status === "dirty";
var isValid = (x3) => x3.status === "valid";
var isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
function __classPrivateFieldGet(receiver, state2, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value, kind, f3) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state2.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a2, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a2, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a2 = err === null || err === void 0 ? void 0 : err.message) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val2) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val2);
      } else {
        return message;
      }
    };
    return this._refinement((val2, ctx) => {
      const result = check(val2);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val2)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val2, ctx) => {
      if (!check(val2)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val2, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a2) {
    return false;
  }
}
function isValidCidr(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val2, step) {
  const valDecCount = (val2.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val2.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a2) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a3, b3) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b3);
  if (a3 === b3) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a3).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a3, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a3[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a3.length; index++) {
      const itemA = a3[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b3) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e3) => {
          error.addIssue(makeArgsIssue(args, e3));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e3) => {
          error.addIssue(makeReturnsIssue(result, e3));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b3) {
    return new _ZodPipeline({
      in: a3,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p3 === "string" ? { message: p3 } : p3;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      const r3 = check(data);
      if (r3 instanceof Promise) {
        return r3.then((r4) => {
          var _a3, _b2;
          if (!r4) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a3 = params.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r3) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@hono/zod-openapi/dist/index.mjs
var import_zod_to_openapi = __toESM(require_dist(), 1);

// node_modules/hono/dist/router/reg-exp-router/node.js
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");

// node_modules/@hono/zod-openapi/dist/index.mjs
(0, import_zod_to_openapi.extendZodWithOpenApi)(z);

// libraries/errors/src/database-delete-error.ts
var DatabaseDeleteError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DatabaseDeleteError";
  }
};

// libraries/errors/src/database-insert-error.ts
var DatabaseInsertError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DatabaseInsertError";
  }
};

// libraries/errors/src/database-retrieve-error.ts
var DatabaseRetrieveError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DatabaseRetrieveError";
  }
};

// libraries/errors/src/database-update-error.ts
var DatabaseUpdateError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DatabaseUpdateError";
  }
};

// libraries/errors/src/not-found-error.ts
var DEFAULT_NOT_FOUND_MESSAGE = "Resource not found";
var NotFoundError = class extends Error {
  constructor(message) {
    super(message ?? DEFAULT_NOT_FOUND_MESSAGE);
    this.name = "NotFoundError";
  }
};

// libraries/errors/src/api-error.ts
var ApiErrorSchema = z.object({
  statusCode: z.number(),
  message: z.string(),
  key: z.string(),
  validationErrors: z.array(
    z.object({
      type: z.string(),
      message: z.string(),
      property: z.string()
    })
  ).optional()
}).openapi("ApiError");

// libraries/utils/src/logger/logger.ts
var import_pino = __toESM(require_pino(), 1);
var import_pino_pretty = __toESM(require_pino_pretty(), 1);
var stream = (0, import_pino_pretty.default)({
  colorize: true
});
var _rootLogger = (0, import_pino.pino)(
  {
    enabled: true,
    level: "trace"
  },
  stream
);
var PinoLogger = class _PinoLogger {
  /**
   * The root pino logger, don't use this directly, use a child logger instead
   */
  _rootLogger = _rootLogger;
  _childLogger;
  constructor(bindings, options) {
    this._childLogger = _rootLogger.child(bindings, options);
  }
  getChildLogger(bindings, options) {
    return new _PinoLogger(
      {
        ...this._childLogger.bindings(),
        ...bindings
      },
      options
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  trace(mustOneArg, ...args) {
    this._childLogger.trace(mustOneArg, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debug(mustOneArg, ...args) {
    this._childLogger.debug(mustOneArg, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  info(mustOneArg, ...args) {
    this._childLogger.info(mustOneArg, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  warn(mustOneArg, ...args) {
    this._childLogger.warn(mustOneArg, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  error(mustOneArg, ...args) {
    this._childLogger.error(mustOneArg, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fatal(mustOneArg, ...args) {
    this._childLogger.fatal(mustOneArg, ...args);
  }
};

// libraries/utils/src/array.utils.ts
var mapArrayOrSingleItem = (arrayOrSingleItem, mapFn) => {
  if (Array.isArray(arrayOrSingleItem)) {
    return arrayOrSingleItem.map(mapFn);
  }
  return mapFn(arrayOrSingleItem);
};

// api/functions/machine-sqs-lambda/src/logger.ts
var LOGGER = new PinoLogger(
  {
    name: "machine-sqs-lambda"
  },
  {}
);

// libraries/db/src/connection.ts
var import_knex = __toESM(require_knex(), 1);
var import_postgres = __toESM(require_postgres(), 1);

// libraries/utils/src/aws-secret-manager.ts
var import_client_secrets_manager = __toESM(require_dist_cjs51(), 1);
var AWS_REGION = process.env.AWS_REGION ?? "eu-west-1";
var AWS_PROFILE = process.env.AWS_PROFILE ?? "elaut";
var awsSecretClient;
var getAwsSecretClient = () => {
  if (!awsSecretClient) {
    awsSecretClient = new import_client_secrets_manager.SecretsManagerClient({
      region: AWS_REGION,
      profile: AWS_PROFILE
    });
  }
  return awsSecretClient;
};
var getAwsSecret = async (secretKey) => {
  const secretManagerResponse = await getAwsSecretClient().send(
    new import_client_secrets_manager.GetSecretValueCommand({ SecretId: secretKey })
  );
  return JSON.parse(secretManagerResponse.SecretString);
};

// libraries/db/src/connection.ts
var getAwsDatabaseCredentials = async () => {
  const secretName = process.env.AWS_DB_SECRET;
  if (!secretName) {
    throw new Error("No AWS_DB_SECRET environment variable set");
  }
  const creds = await getAwsSecret(secretName);
  return {
    host: creds.host,
    port: creds.port,
    user: creds.username,
    password: creds.password,
    database: creds.dbname
  };
};
var getPossiblyLocalDatabaseConfig = async () => {
  const POSTGRES_HOST = process.env.POSTGRES_HOST;
  const POSTGRES_PORT = process.env.POSTGRES_PORT;
  const POSTGRES_USER = process.env.POSTGRES_USER;
  const POSTGRES_PASSWORD = process.env.POSTGRES_PASSWORD;
  const POSTGRES_DB = process.env.POSTGRES_DB;
  const areAllEnvVarsSet = !!POSTGRES_HOST && !!POSTGRES_PORT && !!POSTGRES_USER && !!POSTGRES_PASSWORD && !!POSTGRES_DB;
  if (areAllEnvVarsSet) {
    return {
      host: POSTGRES_HOST,
      port: parseInt(POSTGRES_PORT),
      user: POSTGRES_USER,
      password: POSTGRES_PASSWORD,
      database: POSTGRES_DB
    };
  }
  return getAwsDatabaseCredentials();
};
var getNewKnexInstance = (config) => {
  return (0, import_knex.default)({
    dialect: "postgres",
    client: import_postgres.default,
    pool: {
      min: 5,
      max: 50
    },
    connection: config
  });
};
var getKnexInstance = async () => {
  if (global.postgresDatabase) {
    return global.postgresDatabase;
  }
  if (process.env.NODE_ENV !== "production") {
    global.postgresDatabase = getNewKnexInstance(
      await getPossiblyLocalDatabaseConfig()
    );
  } else {
    global.postgresDatabase = getNewKnexInstance(
      await getAwsDatabaseCredentials()
    );
  }
  return global.postgresDatabase;
};

// libraries/models/src/cabinet/cabinet.schema.ts
var CabinetDBSchema = z.object({
  serial_number: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  name: z.string(),
  created_at: z.date(),
  updated_at: z.date()
});
var CabinetWithPlayfieldsDBSchema = CabinetDBSchema.extend({
  playfields: z.string()
});
var CabinetDTOSchema = z.object({
  serialNumber: z.string(),
  tenantId: z.string(),
  locationId: z.string(),
  name: z.string(),
  playfields: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      status: z.string(),
      gametypeId: z.string()
    })
  ).min(1)
}).openapi("Cabinet");
var CabinetInsertDBSchema = z.object({
  serial_number: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  name: z.string()
});
var CabinetUpdateDBSchema = z.object({
  name: z.string().optional(),
  tenant_id: z.string().optional(),
  tenant_location_id: z.string().optional(),
  last_machine_message: z.date().optional()
});

// libraries/models/src/cabinet/cabinet.model.ts
var Cabinet = class _Cabinet {
  serialNumber;
  tenantId;
  locationId;
  name;
  playfields;
  static schemas = {
    DTOSchema: CabinetDTOSchema,
    DBSchema: CabinetDBSchema,
    InsertDBSchema: CabinetInsertDBSchema,
    UpdateDBSchema: CabinetUpdateDBSchema,
    WithPlayfieldsDBSchema: CabinetWithPlayfieldsDBSchema
  };
  constructor(serialNumber, tenantId, locationId, name, playfields) {
    this.serialNumber = serialNumber;
    this.tenantId = tenantId;
    this.locationId = locationId;
    this.name = name;
    this.playfields = playfields;
  }
  static fromJSON(dto) {
    return mapArrayOrSingleItem(dto, (item) => {
      return new _Cabinet(
        item.serialNumber,
        item.tenantId,
        item.locationId,
        item.name,
        item.playfields
      );
    });
  }
  static fromDBType(dbType) {
    return mapArrayOrSingleItem(dbType, (item) => {
      try {
        const playfields = typeof item.playfields === "string" ? JSON.parse(item.playfields) : item.playfields;
        const validatedPlayfields = z.array(
          z.object({
            id: z.string(),
            name: z.string(),
            status: z.string(),
            gametype_id: z.string()
          })
        ).min(1).parse(playfields);
        return new _Cabinet(
          item.serial_number,
          item.tenant_id,
          item.tenant_location_id,
          item.name,
          validatedPlayfields.map((playfield) => ({
            id: playfield.id,
            name: playfield.name,
            status: playfield.status,
            gametypeId: playfield.gametype_id
          }))
        );
      } catch (e3) {
        console.error(e3);
        throw new Error("Failed to parse playfields");
      }
    });
  }
  toJSON() {
    return {
      serialNumber: this.serialNumber,
      tenantId: this.tenantId,
      locationId: this.locationId,
      name: this.name,
      playfields: this.playfields
    };
  }
};

// libraries/utils/src/database/database.utils.ts
var parseStringWithWildcardsToLikeFilter = (value) => {
  const escapedValue = value.replace(/%/g, "\\%").replace(/_/g, "\\_");
  return escapedValue.replace(/\*/g, "%").replace(/\?/g, "_");
};

// libraries/utils/src/database/knex-database-filters-adapter.ts
var KnexWhereFilterAdapter = {
  eq: (query, columnName, value) => query.where(columnName, value),
  neq: (query, columnName, value) => query.whereNot(columnName, value),
  gt: (query, columnName, value) => query.where(columnName, ">", value),
  gte: (query, columnName, value) => query.where(columnName, ">=", value),
  lt: (query, columnName, value) => query.where(columnName, "<", value),
  lte: (query, columnName, value) => query.where(columnName, "<=", value),
  in: (query, columnName, value) => query.whereIn(columnName, value),
  notIn: (query, columnName, value) => query.whereNotIn(columnName, value),
  neqOrNull: (query, columnName, value) => query.where((qb) => qb.whereNot(columnName, value).orWhereNull(columnName)),
  contains: (query, columnName, value) => (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    query.whereJsonObject(columnName, JSON.stringify([value]))
  ),
  like: (query, columnName, value) => query.where(
    columnName,
    "ilike",
    `%${parseStringWithWildcardsToLikeFilter(value)}%`
  ),
  notLike: (query, columnName, value) => query.whereNot(
    columnName,
    "ilike",
    `%${parseStringWithWildcardsToLikeFilter(value)}%`
  )
};
var KnexFilterAdapter = {
  applyWhereFilters(query, filters) {
    filters.where?.forEach((filter) => {
      const { columnName, value, type } = filter;
      const whereFilterFuntion = KnexWhereFilterAdapter[type];
      if (whereFilterFuntion) {
        whereFilterFuntion(query, columnName, value);
      }
    });
    return query;
  },
  applyLimitFilters(query, filters) {
    if (filters.limit) {
      query.limit(filters.limit);
    }
    if (filters.offset) {
      query.offset(filters.offset);
    }
    return query;
  },
  applyOrderByFilters(query, filters) {
    if (filters.orderBy && filters.orderBy.length > 0) {
      query.orderBy(
        filters.orderBy.map((filter) => ({
          column: filter.columnName,
          order: filter.value
        }))
      );
    }
    return query;
  },
  applyFilters(query, filters) {
    if (!filters) {
      return query;
    }
    this.applyWhereFilters(query, filters);
    this.applyLimitFilters(query, filters);
    this.applyOrderByFilters(query, filters);
    return query;
  }
};

// libraries/repositories/src/knex-repository.ts
var KnexRepository = class {
  db;
  logger;
  constructor(name, db, context) {
    this.db = db;
    this.logger = context.logger.getChildLogger(
      {
        name
      },
      {}
    );
  }
  /**
   * This method should be overridden in the child class to return a new instance of the child class.
   * We could implement this method using this.constructor, but it would obfuscate the code
   * and not always work as expected, so it's better to just override it in the child class
   *
   * This method is used to create a cloned instance of the repository with the provided transaction object as the connection
   *
   * @param trx The transaction object
   */
  withTransaction(trx) {
    throw new Error("Method not implemented.");
  }
  /**
   * Expose the ability to run a transaction from a service. It is however recommended to keep transactions
   * within the repository layer. If for some reason you need to run a transaction from outside the repository,
   * consider creating a layer of abstraction between service and repositories that will handle the transaction logic.
   *
   * @param transactionScope The function that will be executed within the transaction
   * @param config The transaction configuration
   */
  async transaction(transactionScope, config) {
    return this.db.transaction(transactionScope, config);
  }
};

// libraries/repositories/src/cabinet/cabinet.repository.ts
var CabinetRepository = class _CabinetRepository extends KnexRepository {
  constructor(db, context) {
    super("cabinet-repository", db, context);
  }
  withTransaction(trx) {
    return new _CabinetRepository(trx, {
      logger: this.logger
    });
  }
  withPlayfields(query) {
    return query.select(
      "cabinet.*",
      this.db.raw(
        "coalesce(json_agg(row_to_json(playfield)) filter ( where playfield.serial_number is not null ), '[]') as playfields"
      )
    ).join("playfield", "cabinet.serial_number", "playfield.serial_number").groupBy("cabinet.serial_number");
  }
  selectCabinetWithPlayfields() {
    return this.withPlayfields(this.db("cabinet"));
  }
  applyTenantAndLocationFilters(query, tenantId, locationIds) {
    if (tenantId) {
      query.where("cabinet.tenant_id", tenantId);
    }
    if (locationIds) {
      query.whereIn("cabinet.tenant_location_id", locationIds);
    }
    return query;
  }
  async findCabinets(filters, tenantId, locationIds) {
    try {
      const query = KnexFilterAdapter.applyFilters(
        this.selectCabinetWithPlayfields(),
        filters
      );
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      return Cabinet.fromDBType(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve cabinets");
    }
  }
  async getCabinetById(id, tenantId, locationIds) {
    try {
      const query = this.selectCabinetWithPlayfields().where("cabinet.serial_number", id).first();
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (!result) {
        return void 0;
      }
      return Cabinet.fromDBType(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve cabinet");
    }
  }
  async createCabinet(cabinet) {
    try {
      await this.db("cabinet").insert(cabinet).returning("*").first();
      const created = await this.getCabinetById(cabinet.serial_number);
      if (!created) {
        throw new Error("Failed to create cabinet");
      }
      return created;
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseInsertError("Could not create cabinet");
    }
  }
  async updateCabinet(serialNumber, cabinet, tenantId, locationIds) {
    try {
      const query = this.db("cabinet").where("cabinet.serial_number", serialNumber).update(cabinet);
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (result === 0) {
        throw new Error("Could not find cabinet to update");
      }
      const updated = await this.getCabinetById(serialNumber);
      if (!updated) {
        throw new Error("Could not find updated cabinet");
      }
      return updated;
    } catch (error) {
      this.logger.error(
        `Error updating cabinet with serial number: ${serialNumber}, error: ${error?.message}`
      );
      throw new DatabaseUpdateError("Error updating cabinet");
    }
  }
  async getCabinetByPlayfieldId(playfieldId, tenantId, locationIds) {
    try {
      const query = this.selectCabinetWithPlayfields().where("playfield.id", playfieldId).first();
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (!result) {
        return void 0;
      }
      return Cabinet.fromDBType(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve cabinet");
    }
  }
};

// libraries/repositories/src/game-session/game-session.repository.ts
var import_knex2 = __toESM(require_knex(), 1);

// libraries/models/src/game-session/game-session.schema.ts
var GamePaymentMethod = /* @__PURE__ */ ((GamePaymentMethod2) => {
  GamePaymentMethod2["COIN"] = "COIN";
  GamePaymentMethod2["BILL"] = "BILL";
  GamePaymentMethod2["CARD"] = "CARD";
  GamePaymentMethod2["CASHLESS"] = "CASHLESS";
  GamePaymentMethod2["OTHER"] = "OTHER";
  return GamePaymentMethod2;
})(GamePaymentMethod || {});
var GameSessionDBSchema = z.object({
  id: z.string(),
  playfield_id: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  // Messages arrive in separate events, so we need to be able to insert gamesessions with mostly optional properties.
  started_at: z.date().optional(),
  payment_method: z.nativeEnum(GamePaymentMethod).optional(),
  amount_money_in: z.number().optional(),
  amount_money_out: z.number().optional(),
  amount_credits: z.number().optional(),
  ended_at: z.date().optional(),
  result: z.object({}).passthrough(),
  created_at: z.date(),
  updated_at: z.date()
});
var GameSessionDTOSchema = z.object({
  id: z.string(),
  playfieldId: z.string(),
  tenantId: z.string(),
  tenantLocationId: z.string(),
  startedAt: z.date().optional(),
  paymentMethod: z.nativeEnum(GamePaymentMethod).optional(),
  amountMoneyIn: z.number().optional(),
  amountMoneyOut: z.number().optional(),
  amountCredits: z.number().optional(),
  endedAt: z.date().optional(),
  result: z.object({}).passthrough(),
  createdAt: z.date(),
  updatedAt: z.date()
});
var GameSessionInsertDBSchema = z.object({
  id: z.string(),
  playfield_id: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  started_at: z.date().optional(),
  ended_at: z.date().optional(),
  payment_method: z.nativeEnum(GamePaymentMethod).optional(),
  amount_money_in: z.number().optional(),
  amount_money_out: z.number().optional(),
  amount_credits: z.number().optional(),
  result: z.object({}).passthrough().optional(),
  updated_at: z.date()
});

// libraries/models/src/game-session/game-session.model.ts
var GameSession = class _GameSession {
  id;
  playfieldId;
  tenantId;
  tenantLocationId;
  startedAt;
  endedAt;
  result;
  amountMoneyIn;
  amountCredits;
  amountMoneyOut;
  paymentMethod;
  createdAt;
  updatedAt;
  static schemas = {
    DTOSchema: GameSessionDTOSchema,
    CreateDTOSchema: GameSessionInsertDBSchema,
    DBSchema: GameSessionDBSchema
  };
  constructor(id, playfieldId, tenantId, tenantLocationId, startedAt, endedAt, result, amountMoneyIn, amountCredits, amountMoneyOut, paymentMethod, createdAt, updatedAt) {
    this.id = id;
    this.playfieldId = playfieldId;
    this.tenantId = tenantId;
    this.tenantLocationId = tenantLocationId;
    this.startedAt = startedAt;
    this.endedAt = endedAt;
    this.result = result;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.amountMoneyIn = amountMoneyIn;
    this.amountCredits = amountCredits;
    this.amountMoneyOut = amountMoneyOut;
    this.paymentMethod = paymentMethod;
  }
  static fromDBType(data) {
    return mapArrayOrSingleItem(data, (item) => {
      try {
        const parsedResult = typeof item.result === "string" ? JSON.parse(item.result) : item.result;
        return new _GameSession(
          item.id,
          item.playfield_id,
          item.tenant_id,
          item.tenant_location_id,
          item.started_at,
          item.ended_at,
          parsedResult,
          item.amount_money_in,
          item.amount_credits,
          item.amount_money_out,
          item.payment_method,
          item.created_at,
          item.updated_at
        );
      } catch (e3) {
        console.error(e3);
        throw new Error(
          `Failed to parse result for game session with id ${item.id}`
        );
      }
    });
  }
  static fromJSON(data) {
    return mapArrayOrSingleItem(data, (item) => {
      return new _GameSession(
        item.id,
        item.playfieldId,
        item.tenantId,
        item.tenantLocationId,
        item.startedAt,
        item.endedAt,
        item.result,
        item.amountMoneyIn,
        item.amountCredits,
        item.amountMoneyOut,
        item.paymentMethod,
        item.createdAt,
        item.updatedAt
      );
    });
  }
};

// libraries/repositories/src/game-session/game-session.repository.ts
var GameSessionRepository = class _GameSessionRepository extends KnexRepository {
  constructor(db, context) {
    super("game-session-repository", db, context);
  }
  withTransaction(trx) {
    return new _GameSessionRepository(trx, {
      logger: this.logger
    });
  }
  applyTenantAndLocationFilters(query, tenantId, locationIds) {
    if (tenantId) {
      query.where("tenant_id", tenantId);
    }
    if (locationIds && locationIds.length > 0) {
      query.whereIn("location_id", locationIds);
    }
    return query;
  }
  async findGameSessions(filters, tenantId, locationIds) {
    try {
      const query = KnexFilterAdapter.applyFilters(
        this.db("game_sessios"),
        filters
      );
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      return GameSession.fromDBType(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve game sessions");
    }
  }
  async getGameSessionById(id, tenantId, locationIds) {
    try {
      const query = this.db("game_session").where("game_session.id", id).first();
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (!result) {
        return void 0;
      }
      return GameSession.fromDBType(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve game session");
    }
  }
  async createOrUpdateGameSession(gameSession) {
    try {
      const result = await this.db("game_session").insert(gameSession).onConflict(["id"]).merge({
        updated_at: /* @__PURE__ */ new Date(),
        ended_at: this.db.raw("excluded.ended_at"),
        started_at: this.db.raw(
          "coalesce(game_session.started_at, excluded.started_at)"
        ),
        result: this.db.raw("excluded.result"),
        amount_money_out: this.db.raw(`excluded.amount_money_out`),
        amount_credits: this.db.raw(
          `game_session.amount_credits + excluded.amount_credits`
        ),
        amount_money_in: this.db.raw(
          `game_session.amount_money_in + excluded.amount_money_in`
        )
      });
      if (result.length === 0) {
        throw new Error("Could not update or create game session");
      }
      const updatedGameSession = await this.getGameSessionById(gameSession.id);
      if (!updatedGameSession) {
        throw new Error("Could not find updated game session");
      }
      return updatedGameSession;
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseInsertError("Could not update or create game session");
    }
  }
};

// libraries/models/src/machine-log/machine-log.schema.ts
var MachineLogDTOSchema = z.object({
  level: z.string(),
  timestamp: z.string(),
  serialNumber: z.string(),
  playfieldId: z.string().optional(),
  type: z.string(),
  data: z.object({}).passthrough().optional(),
  userId: z.string().optional()
});
var MachineLogDBSchema = z.object({
  id: z.string(),
  level: z.string(),
  serial_number: z.string(),
  playfield_id: z.string().optional(),
  type: z.string(),
  timestamp: z.date(),
  data: z.object({}).passthrough().optional(),
  app_user_id: z.string().optional()
});
var MachineLogInsertDBSchema = z.object({
  id: z.string(),
  level: z.string(),
  serial_number: z.string(),
  playfield_id: z.string().optional(),
  type: z.string(),
  timestamp: z.date(),
  data: z.object({}).passthrough().optional(),
  app_user_id: z.string().optional()
});

// libraries/models/src/machine-log/machine-log.model.ts
var MachineLog = class _MachineLog {
  id;
  level;
  serialNumber;
  playfieldId;
  type;
  timestamp;
  data;
  userId;
  constructor(id, level, serialNumber, playfieldId, type, timestamp, data, userId) {
    this.id = id;
    this.level = level;
    this.serialNumber = serialNumber;
    this.playfieldId = playfieldId;
    this.type = type;
    this.timestamp = timestamp;
    this.data = data;
    this.userId = userId;
  }
  static schemas = {
    InputSchema: MachineLogDTOSchema,
    DBSchema: MachineLogDBSchema,
    InsertDBSchema: MachineLogInsertDBSchema
  };
  static fromDBType(dbType) {
    return mapArrayOrSingleItem(dbType, (item) => {
      return new _MachineLog(
        item.id,
        item.level,
        item.serial_number,
        item.playfield_id,
        item.type,
        new Date(item.timestamp),
        item.data,
        item.app_user_id
      );
    });
  }
  toJSON() {
    return {
      level: this.level,
      timestamp: this.timestamp.toISOString(),
      serialNumber: this.serialNumber,
      playfieldId: this.playfieldId,
      type: this.type,
      data: this.data,
      userId: this.userId
    };
  }
};

// libraries/repositories/src/machine-log/machine-log.repository.ts
var MachineLogRepository = class _MachineLogRepository extends KnexRepository {
  constructor(db, context) {
    super("machine-log-repository", db, context);
  }
  withTransaction(trx) {
    return new _MachineLogRepository(trx, { logger: this.logger });
  }
  applyTenantAndLocationFilters(query, tenantId, locationIds) {
    const hasTenantId = tenantId !== void 0;
    const hasLocationIds = locationIds !== void 0 && locationIds.length > 0;
    if (hasTenantId || hasLocationIds) {
      query.select("machine_log.*").join("cabinet", "cabinet.serial_number", "machine_log.serial_number");
    }
    if (tenantId) {
      query.where("tenant_id", tenantId);
    }
    if (locationIds && locationIds.length > 0) {
      query.whereIn("location_id", locationIds);
    }
    return query;
  }
  async findMachineLogs(filters, tenantId, locationIds) {
    try {
      const query = KnexFilterAdapter.applyFilters(
        this.db("machine_log"),
        filters
      );
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      return MachineLog.fromDBType(result);
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseRetrieveError("Error retrieving machine logs");
    }
  }
  async findMachineLogsForCabinet(serialNumber, filters, tenantId, locationIds) {
    const _filters = filters ?? {};
    _filters.where = _filters.where ?? [];
    _filters.where.push({
      type: "eq",
      columnName: "machine_log.serial_number",
      value: serialNumber
    });
    return this.findMachineLogs(_filters, tenantId, locationIds);
  }
  async findMachineLogsForPlayfield(playfieldId, filters, tenantId, locationIds) {
    const _filters = filters ?? {};
    _filters.where = _filters.where ?? [];
    _filters.where.push({
      type: "eq",
      columnName: "machine_log.playfield_id",
      value: playfieldId
    });
    return this.findMachineLogs(_filters, tenantId, locationIds);
  }
  async getMachineLogById(id) {
    try {
      const result = await this.db.select("*").from("machine_log").where({ id }).first();
      return result ? MachineLog.fromDBType(result) : void 0;
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseRetrieveError(
        `Error retrieving machine log with id: ${id}`
      );
    }
  }
  async createMachineLog(machineLog) {
    try {
      await this.db("machine_log").insert(machineLog).returning("*");
      const result = await this.getMachineLogById(machineLog.id);
      if (!result) {
        throw new NotFoundError("Error creating machine log");
      }
      return result;
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseInsertError("Error creating machine log");
    }
  }
};

// libraries/models/src/machine-message/machine-message.schema.ts
var MachineMessageInputBaseSchema = z.object({
  u: z.string(),
  // messageId
  e: z.string(),
  // event type
  p: z.string().optional(),
  // playfieldId
  c: z.string(),
  // cabinetId
  t: z.coerce.number(),
  // timestamp
  d: z.unknown()
  // data
});
var HeartbeatInputDataSchema = z.object({
  c: z.number()
  // a counter
});
var LogInputDataSchema = z.object({
  l: z.string(),
  // log level
  c: z.number(),
  // event code
  e: z.string().optional(),
  // event data
  a: z.boolean().optional()
  // active
});
var MoneyInInputDataSchema = z.object({
  m: z.number(),
  // money in
  c: z.number(),
  // credits
  t: z.string(),
  // payment type
  i: z.string()
  // game session id
});
var SessionEndInputDataSchema = z.object({
  i: z.string(),
  // game session id
  m: z.number()
  // money out
});
var StatusInputDataSchema = z.object({
  s: z.string()
  // status
});
var HeartbeatMachineMessageInputSchema = MachineMessageInputBaseSchema.merge(
  z.object({
    e: z.literal("h" /* HEARTBEAT */),
    d: HeartbeatInputDataSchema
  })
);
var LogMachineMessageInputSchema = MachineMessageInputBaseSchema.merge(
  z.object({
    e: z.literal("l" /* LOG */),
    d: LogInputDataSchema
  })
);
var MoneyInMachineMessageInputSchema = MachineMessageInputBaseSchema.merge(
  z.object({
    e: z.literal("m" /* MONEY_IN */),
    d: MoneyInInputDataSchema
  })
);
var SessionEndMachineMessageInputSchema = MachineMessageInputBaseSchema.merge(
  z.object({
    e: z.literal("e" /* SESSION_END */),
    d: SessionEndInputDataSchema
  })
);
var StatusMachineMessageInputSchema = MachineMessageInputBaseSchema.merge(
  z.object({
    e: z.literal("s" /* STATUS */),
    d: StatusInputDataSchema
  })
);
var MachineMessageDBSchema = z.object({
  id: z.string(),
  serial_number: z.string(),
  playfield_id: z.string().optional(),
  timestamp: z.date(),
  type: z.string(),
  data: z.object({}).passthrough().optional(),
  status: z.number()
});
var MachineMessageInputSchema = z.union([
  MachineMessageInputBaseSchema,
  LogMachineMessageInputSchema,
  MoneyInMachineMessageInputSchema,
  SessionEndMachineMessageInputSchema,
  HeartbeatMachineMessageInputSchema,
  StatusMachineMessageInputSchema
]);

// libraries/models/src/machine-message/machine-message.model.ts
var MachineMessage = class _MachineMessage {
  messageId;
  eventType;
  serial_number;
  playfieldId;
  // Message can be for a cabinet or a playfield
  timestamp;
  data;
  tenantId;
  tenantLocationId;
  status;
  constructor(messageId, serial_number, playfieldId, timestamp, eventType, status, data) {
    this.messageId = messageId;
    this.serial_number = serial_number;
    this.timestamp = new Date(timestamp);
    this.eventType = eventType;
    this.data = data;
    this.playfieldId = playfieldId;
    this.status = status;
  }
  static schemas = {
    InputSchema: MachineMessageInputSchema,
    DBSchema: MachineMessageDBSchema,
    LogInputDataSchema,
    HeartbeatInputDataSchema,
    MoneyInInputDataSchema,
    SessionEndInputDataSchema,
    StatusInputDataSchema
  };
  static convertStatusToString(status) {
    switch (status) {
      case 1:
        return "processed";
      case 2:
        return "failed";
      default:
        return "pending";
    }
  }
  getStatusAsNumber() {
    switch (this.status) {
      case "processed":
        return 1;
      case "failed":
        return 2;
      default:
        return 0;
    }
  }
  toDBType() {
    return {
      id: this.messageId,
      serial_number: this.serial_number,
      playfield_id: this.playfieldId,
      timestamp: this.timestamp,
      type: this.eventType,
      data: this.data ?? {},
      status: this.getStatusAsNumber()
    };
  }
  toJSON() {
    return {
      u: this.messageId,
      c: this.serial_number,
      p: this.playfieldId,
      t: this.timestamp.getTime(),
      e: this.eventType,
      d: this.data
    };
  }
  updateFromCabinet(cabinet) {
    this.tenantId = cabinet.tenantId;
    this.tenantLocationId = cabinet.locationId;
    this.serial_number = cabinet.serialNumber;
  }
  static fromMachineInput(input) {
    const mapped = mapArrayOrSingleItem(input, (item) => {
      const validated = MachineMessageInputSchema.safeParse(item);
      if (!validated.success) {
        console.error(
          `Error validating machine message: ${JSON.stringify(validated.error)}`
        );
        return void 0;
      }
      let data = validated.data.d;
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch {
          data = {};
        }
      }
      return new _MachineMessage(
        validated.data.u,
        validated.data.c,
        validated.data.p,
        new Date(validated.data.t),
        validated.data.e,
        "pending",
        data
      );
    });
    if (Array.isArray(mapped)) {
      return mapped.filter((item) => item !== void 0);
    }
    return mapped;
  }
  static fromMachineMessageDBType(data) {
    return mapArrayOrSingleItem(data, (item) => {
      return new _MachineMessage(
        item.id,
        item.serial_number,
        item.playfield_id,
        item.timestamp,
        item.type,
        _MachineMessage.convertStatusToString(item.status),
        item.data
      );
    });
  }
};

// libraries/repositories/src/machine-message/machine-message.repository.ts
var MachineMessageRepository = class _MachineMessageRepository extends KnexRepository {
  constructor(db, context) {
    super("machine-message-repository", db, context);
  }
  withTransaction(trx) {
    return new _MachineMessageRepository(trx, { logger: this.logger });
  }
  async findMachineMessageById(id) {
    try {
      const result = await this.db.select("*").from("machine_message").where({ id }).first();
      return result ? MachineMessage.fromMachineMessageDBType(result) : void 0;
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseRetrieveError(
        `Error retrieving machine message with id: ${id}`
      );
    }
  }
  async createMachineMessage(message) {
    try {
      const result = await this.db("machine_message").insert(message.toDBType()).returning("*");
      return result?.[0] ? MachineMessage.fromMachineMessageDBType(result[0]) : void 0;
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseInsertError(
        `Error creating machine message for machine serial_number: ${message.serial_number}, playfield: ${message.playfieldId}, and message: ${message}`
      );
    }
  }
  async updateMachineMessage(id, status) {
    try {
      const result = await this.db.update({ status }).from("machine_message").where({ id }).returning("*");
      return result?.[0] ? MachineMessage.fromMachineMessageDBType(result[0]) : void 0;
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseUpdateError(
        `Error updating machine message with id: ${id}`
      );
    }
  }
  async clearMachineMessages(before, status = "done") {
    try {
      return this.db.delete().from("machine_message").where("created_at", "<", before).andWhere("status", status).then(() => {
      });
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseDeleteError(
        `Error clearing machine messages before: ${before}`
      );
    }
  }
  async clearMachineMessageById(id) {
    try {
      return this.db.delete().from("machine_message").where({ id }).then(() => {
      });
    } catch (e3) {
      this.logger.error(e3);
      throw new DatabaseDeleteError(
        `Error clearing machine message with id: ${id}`
      );
    }
  }
};

// libraries/models/src/playfield/playfield.schema.ts
var PlayfieldDTOSchema = z.object({
  id: z.string(),
  cabinet: z.object({
    serialNumber: z.string(),
    name: z.string(),
    tenantId: z.string(),
    tenantLocationId: z.string(),
    playfields: z.array(
      z.object({
        id: z.string(),
        name: z.string(),
        status: z.string()
      })
    ).min(1)
  }),
  name: z.string(),
  gametypeId: z.string(),
  status: z.string()
}).openapi("Playfield");
var PlayfieldDBSchema = z.object({
  id: z.string(),
  serial_number: z.string(),
  // cabinet serial number
  name: z.string(),
  game_type_id: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  status: z.string().optional()
});
var PlayfieldWithCabinetDBSchema = z.object({
  id: z.string(),
  serial_number: z.string(),
  // cabinet serial number
  name: z.string(),
  game_type_id: z.string(),
  tenant_id: z.string(),
  tenant_location_id: z.string(),
  status: z.string().optional(),
  cabinet: z.string()
});
var PlayfieldInsertDBSchema = z.object({
  id: z.string(),
  serial_number: z.string(),
  name: z.string(),
  game_type_id: z.string().optional(),
  tenant_id: z.string().optional(),
  tenant_location_id: z.string().optional()
});
var PlayfieldUpdateDBSchema = z.object({
  serial_number: z.string().optional(),
  name: z.string().optional(),
  tenant_id: z.string().optional(),
  tenant_location_id: z.string().optional(),
  last_machine_message: z.date().optional(),
  status: z.string().optional()
});

// libraries/models/src/playfield/playfield.model.ts
var Playfield = class _Playfield {
  id;
  cabinet;
  name;
  gametypeId;
  status;
  static schemas = {
    DTOSchema: PlayfieldDTOSchema,
    DBSchema: PlayfieldDBSchema,
    InsertDBSchema: PlayfieldInsertDBSchema,
    UpdateDBSchema: PlayfieldUpdateDBSchema,
    WithCabinetDBSchema: PlayfieldWithCabinetDBSchema
  };
  constructor(id, cabinet, name, gametypeId, status) {
    this.id = id;
    this.cabinet = cabinet;
    this.name = name;
    this.gametypeId = gametypeId;
    this.status = status;
  }
  static fromJSON(data) {
    return mapArrayOrSingleItem(data, (item) => {
      return new _Playfield(
        item.id,
        {
          serialNumber: item.cabinet.serialNumber,
          name: item.cabinet.name,
          tenantId: item.cabinet.tenantId,
          tenantLocationId: item.cabinet.tenantLocationId,
          playfields: item.cabinet.playfields
        },
        item.name,
        item.gametypeId,
        item.status
      );
    });
  }
  static fromDBType(data) {
    return mapArrayOrSingleItem(data, (item) => {
      return new _Playfield(
        item.id,
        {
          serialNumber: item.serial_number,
          name: item.name,
          tenantId: item.tenant_id,
          tenantLocationId: item.tenant_location_id,
          playfields: [
            {
              id: item.id,
              name: item.name,
              status: item.status ?? "UNKNOWN"
            }
          ]
        },
        item.name,
        item.game_type_id,
        item.status ?? "UNKNOWN"
      );
    });
  }
  static fromDBTypeWithCabinet(data) {
    return mapArrayOrSingleItem(data, (item) => {
      const cabinet = typeof item.cabinet === "string" ? JSON.parse(item.cabinet) : item.cabinet;
      const validatedCabinet = z.object({
        serial_number: z.string(),
        name: z.string(),
        tenant_id: z.string(),
        tenant_location_id: z.string(),
        playfields: z.array(
          z.object({
            id: z.string(),
            name: z.string(),
            status: z.string(),
            gametype_id: z.string()
          })
        ).min(1)
      }).parse(cabinet);
      return new _Playfield(
        item.id,
        {
          serialNumber: validatedCabinet.serial_number,
          name: validatedCabinet.name,
          tenantId: validatedCabinet.tenant_id,
          tenantLocationId: validatedCabinet.tenant_location_id,
          playfields: validatedCabinet.playfields.map((playfield) => ({
            id: playfield.id,
            name: playfield.name,
            status: playfield.status,
            gametypeId: playfield.gametype_id
          }))
        },
        item.name,
        item.game_type_id,
        item.status ?? "UNKNOWN"
      );
    });
  }
  toJSON() {
    return {
      id: this.id,
      cabinet: {
        serialNumber: this.cabinet.serialNumber,
        name: this.cabinet.name,
        tenantId: this.cabinet.tenantId,
        tenantLocationId: this.cabinet.tenantLocationId,
        playfields: this.cabinet.playfields
      },
      name: this.name,
      gametypeId: this.gametypeId,
      status: this.status
    };
  }
};

// libraries/repositories/src/playfield/playfield.repository.ts
var PlayfieldRepository = class _PlayfieldRepository extends KnexRepository {
  constructor(db, context) {
    super("playfield-repository", db, context);
  }
  withTransaction(trx) {
    return new _PlayfieldRepository(trx, {
      logger: this.logger
    });
  }
  withCabinet(query) {
    return query.select(
      "playfield.*",
      this.db.raw(`coalesce(row_to_json(cabinet),'{}') as cabinet`)
    ).join(
      this.db("cabinet").select(
        "cabinet.*",
        this.db.raw(
          "coalesce(json_agg(row_to_json(playfield)) filter ( where playfield.serial_number is not null ), '[]') as playfields"
        )
      ).join("playfield", "cabinet.serial_number", "playfield.serial_number").groupBy("cabinet.serial_number").as("cabinet"),
      "playfield.serial_number",
      "cabinet.serial_number"
    );
  }
  selectPlayfieldWithCabinet() {
    return this.withCabinet(this.db("playfield"));
  }
  applyTenantAndLocationFilters(query, tenantId, locationIds) {
    if (tenantId) {
      query.where("cabinet.tenant_id", tenantId);
    }
    if (locationIds && locationIds.length > 0) {
      query.whereIn("cabinet.tenant_location_id", locationIds);
    }
    return query;
  }
  async findPlayfields(filters) {
    try {
      const query = KnexFilterAdapter.applyFilters(
        this.selectPlayfieldWithCabinet(),
        filters
      );
      const result = await this.applyTenantAndLocationFilters(query);
      return Playfield.fromDBTypeWithCabinet(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve playfields");
    }
  }
  async findPlayfieldsByCabinetId(serialNumber, tenantId, locationIds) {
    try {
      const query = this.selectPlayfieldWithCabinet().where("cabinet.serial_number", serialNumber);
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      return Playfield.fromDBTypeWithCabinet(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve playfields");
    }
  }
  async getPlayfieldById(id, tenantId, locationIds) {
    try {
      const query = this.selectPlayfieldWithCabinet().where("playfield.id", id).first();
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (!result) {
        return void 0;
      }
      return Playfield.fromDBTypeWithCabinet(result);
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not retrieve playfield");
    }
  }
  async createPlayfield(playfield) {
    try {
      await this.db("playfield").insert(playfield).returning("*").first();
      const created = await this.getPlayfieldById(playfield.id);
      if (!created) {
        throw new Error("Failed to create playfield");
      }
      return created;
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseInsertError("Could not create playfield");
    }
  }
  async updatePlayfield(playfieldId, playfield, tenantId, locationIds) {
    try {
      const query = this.db("playfield").where("playfield.id", playfieldId).update(playfield);
      const result = await this.applyTenantAndLocationFilters(
        query,
        tenantId,
        locationIds
      );
      if (result === 0) {
        throw new Error("Could not find playfield to update");
      }
      const updated = await this.getPlayfieldById(
        playfieldId,
        tenantId,
        locationIds
      );
      if (!updated) {
        throw new Error("Failed to update playfield");
      }
      return updated;
    } catch (error) {
      this.logger.error(error);
      throw new DatabaseRetrieveError("Could not update playfield");
    }
  }
};

// libraries/services/src/machine-message-service/game-messages.service.ts
var GameMessagesService = class {
  constructor(gameSessionRepository, machineLogRepository, context) {
    this.gameSessionRepository = gameSessionRepository;
    this.machineLogRepository = machineLogRepository;
    this.logger = context.logger.getChildLogger(
      {
        service: "game-messages-service"
      },
      {}
    );
  }
  logger;
  getPaymentMethod(data) {
    const methods = {
      c: "COIN" /* COIN */,
      b: "BILL" /* BILL */,
      l: "CASHLESS" /* CASHLESS */,
      s: "CARD" /* CARD */
    };
    return methods[data] ?? "OTHER" /* OTHER */;
  }
  async handleMoneyInEventType(message) {
    const {
      data,
      messageId,
      timestamp,
      serial_number,
      playfieldId,
      tenantId,
      tenantLocationId
    } = message;
    const validated = MachineMessage.schemas.MoneyInInputDataSchema.safeParse(data);
    if (!validated.success) {
      this.logger.error(
        `Invalid event data for money in event: ${validated.error}`
      );
      return false;
    }
    const validatedData = validated.data;
    try {
      await this.gameSessionRepository.transaction(async (trx) => {
        const scopedGameSessionRepository = this.gameSessionRepository.withTransaction(trx);
        const scopedMachineLogRepository = this.machineLogRepository.withTransaction(trx);
        await scopedGameSessionRepository.createOrUpdateGameSession({
          id: validatedData.i,
          tenant_id: tenantId,
          tenant_location_id: tenantLocationId,
          started_at: new Date(timestamp),
          playfield_id: playfieldId,
          payment_method: this.getPaymentMethod(validatedData.t),
          amount_credits: validatedData.c,
          amount_money_in: validatedData.m,
          // Money in is always in cents so no need to adjust for float
          updated_at: /* @__PURE__ */ new Date()
        });
        await scopedMachineLogRepository.createMachineLog({
          id: messageId,
          level: "INFO",
          type: "MONEY_IN",
          serial_number,
          playfield_id: playfieldId,
          timestamp: new Date(timestamp),
          data: {
            credits: validatedData.c,
            money_in: validatedData.m,
            // Money in is always in cents so no need to adjust for float
            payment_method: this.getPaymentMethod(validatedData.t)
          }
        });
      });
    } catch (error) {
      this.logger.error("Error handling money in event", error);
      return false;
    }
    return true;
  }
  async handleSessionEndEventType(message) {
    const {
      data,
      messageId,
      timestamp,
      serial_number,
      playfieldId,
      tenantId,
      tenantLocationId
    } = message;
    const validated = MachineMessage.schemas.SessionEndInputDataSchema.safeParse(data);
    if (!validated.success) {
      this.logger.error(
        `Invalid event data for session end event: ${validated.error}`
      );
      return false;
    }
    const validatedData = validated.data;
    try {
      await this.gameSessionRepository.transaction(async (trx) => {
        const scopedGameSessionRepository = this.gameSessionRepository.withTransaction(trx);
        const scopedMachineLogRepository = this.machineLogRepository.withTransaction(trx);
        const { i: gameSessionId, ...result } = validatedData;
        await scopedGameSessionRepository.createOrUpdateGameSession({
          id: gameSessionId,
          tenant_id: tenantId,
          tenant_location_id: tenantLocationId,
          ended_at: new Date(timestamp),
          playfield_id: playfieldId,
          amount_money_out: validatedData.m,
          // Money out is always in cents so no need to adjust for float
          updated_at: /* @__PURE__ */ new Date(),
          result: {
            ...result
          }
        });
        await scopedMachineLogRepository.createMachineLog({
          id: messageId,
          level: "INFO",
          type: "SESSION_END",
          serial_number,
          playfield_id: playfieldId,
          timestamp: new Date(timestamp),
          data: {
            money_out: validatedData.m,
            // Money out is always in cents so no need to adjust for float
            ...result
          }
        });
      });
    } catch (error) {
      this.logger.error("Error handling session end event", error);
      return false;
    }
    return true;
  }
  async handleMessage(message) {
    const { data, eventType, playfieldId, tenantId, tenantLocationId } = message;
    if (!data) {
      this.logger.error("No data for money in event", message);
      return false;
    }
    if (!tenantId || !tenantLocationId) {
      this.logger.error("No tenant or location for money in event", message);
      return false;
    }
    if (!playfieldId) {
      this.logger.error("No playfield for money in event", message);
      return false;
    }
    const validatedMessage = message;
    switch (eventType) {
      case "m" /* MONEY_IN */:
        return this.handleMoneyInEventType(validatedMessage);
      case "e" /* SESSION_END */:
        return this.handleSessionEndEventType(validatedMessage);
      default:
        this.logger.warn("Unhandled game event type", message);
        return false;
    }
  }
};

// libraries/utils/src/string.utils.ts
var toScreamingSnakeCase = (str) => {
  return str.replace(/([a-z])([A-Z])/g, "$1_$2").replace(/-/g, "_").toUpperCase();
};

// libraries/services/src/machine-message-service/log-messages.service.ts
var LogMessagesService = class {
  constructor(machineLogRepository, cabinetRepository, playfieldRepository, context) {
    this.machineLogRepository = machineLogRepository;
    this.cabinetRepository = cabinetRepository;
    this.playfieldRepository = playfieldRepository;
    this.logger = context.logger.getChildLogger(
      {
        service: "log-messages-service"
      },
      {}
    );
  }
  logger;
  async handleMessage(message) {
    if (message.eventType !== "l" /* LOG */) {
      return false;
    }
    const { data, messageId, timestamp, serial_number, playfieldId } = message;
    const validated = MachineMessage.schemas.LogInputDataSchema.safeParse(data);
    if (!validated.success) {
      this.logger.warn(`Invalid event data for log event: ${validated.error}`);
      return false;
    }
    const logLevelMap = {
      e: "ERROR",
      w: "WARNING",
      i: "INFO",
      n: "NOTICE"
    };
    const logLevel = toScreamingSnakeCase(
      logLevelMap[validated.data.l] ?? validated.data.l
    );
    try {
      await this.machineLogRepository.createMachineLog({
        id: messageId,
        level: logLevel,
        type: "LOG",
        serial_number,
        playfield_id: playfieldId,
        timestamp: new Date(timestamp),
        data
      });
    } catch (error) {
      this.logger.error("Error handling log event", error);
      return false;
    }
    return true;
  }
};

// libraries/services/src/machine-message-service/status-messages.service.ts
var StatusMessagesService = class {
  constructor(cabinetRepository, playfieldRepository, context) {
    this.cabinetRepository = cabinetRepository;
    this.playfieldRepository = playfieldRepository;
    this.logger = context.logger.getChildLogger(
      {
        service: "status-messages-service"
      },
      {}
    );
  }
  logger;
  async handleMessage(message) {
    if (message.eventType !== "s" /* STATUS */) {
      return false;
    }
    const { data, serial_number, playfieldId } = message;
    const validated = MachineMessage.schemas.StatusInputDataSchema.safeParse(data);
    if (!playfieldId) {
      this.logger.warn(`Playfield ID not found in message`);
      return false;
    }
    if (!validated.success) {
      this.logger.warn(
        `Invalid event data for status event: ${validated.error}`
      );
      return false;
    }
    let newStatus = void 0;
    switch (validated.data.s) {
      case "a":
        newStatus = "ACTIVE";
        break;
      case "e":
        newStatus = "ERROR";
        break;
      default:
        newStatus = "UNKNOWN";
        break;
    }
    try {
      await this.playfieldRepository.updatePlayfield(playfieldId, {
        status: newStatus
      });
      return true;
    } catch (error) {
      this.logger.error(error);
      return false;
    }
  }
};

// libraries/services/src/machine-message-service/machine-message.service.ts
var MachineMessageService = class {
  constructor(machineMessageRepository, gameSessionRepository, machineLogRepository, cabinetRepository, playfieldRepository, context) {
    this.machineMessageRepository = machineMessageRepository;
    this.gameSessionRepository = gameSessionRepository;
    this.machineLogRepository = machineLogRepository;
    this.cabinetRepository = cabinetRepository;
    this.playfieldRepository = playfieldRepository;
    this.logger = context.logger.getChildLogger(
      {
        service: "machine-message-service"
      },
      {}
    );
    this.gameMessagesService = new GameMessagesService(
      this.gameSessionRepository,
      this.machineLogRepository,
      context
    );
    this.logMessagesService = new LogMessagesService(
      this.machineLogRepository,
      this.cabinetRepository,
      this.playfieldRepository,
      context
    );
    this.statusMessagesService = new StatusMessagesService(
      this.cabinetRepository,
      this.playfieldRepository,
      context
    );
  }
  logger;
  gameMessagesService;
  logMessagesService;
  statusMessagesService;
  /**
   * NOTE: performance optimisation possible here:
   * - We could cache the cabinet for a playfield in Redis to avoid the DB call
   * - or we could add the required data to the message topic (tenant_id, location_id, serial_number, playfield_id (optional))
   */
  async getCabinetForMessage(message) {
    return this.cabinetRepository.getCabinetByPlayfieldId(message.playfieldId);
  }
  async handleMessage(message) {
    const existingMessage = await this.machineMessageRepository.findMachineMessageById(
      message.messageId
    );
    if (existingMessage && existingMessage.status !== "failed") {
      return true;
    }
    if (!message.playfieldId) {
      this.logger.warn("We have not implemented cabinet only logs yet");
      return false;
    }
    const cabinet = await this.getCabinetForMessage(message);
    if (!cabinet) {
      this.logger.error("Could not find cabinet for message", message);
      return false;
    }
    message.updateFromCabinet(cabinet);
    await this.machineMessageRepository.createMachineMessage(message);
    switch (message.eventType) {
      case "i" /* INTERNET */:
        this.logger.info(
          `Internet message received from ${message.serial_number}:${message.playfieldId}`
        );
        break;
      case "u" /* PCB_CHANGE */:
        this.logger.info(
          `PCB change message received from ${message.serial_number}:${message.playfieldId}`
        );
        break;
      case "p" /* POWER */:
        this.logger.info(
          `Power message received from ${message.serial_number}:${message.playfieldId}`
        );
        break;
      case "h" /* HEARTBEAT */:
        this.logger.info(
          `Heartbeat message received from ${message.serial_number}:${message.playfieldId}`
        );
        break;
      case "m" /* MONEY_IN */:
      case "e" /* SESSION_END */:
        await this.gameMessagesService.handleMessage(message);
        break;
      case "l" /* LOG */:
        await this.logMessagesService.handleMessage(message);
        break;
      case "s" /* STATUS */:
        await this.statusMessagesService.handleMessage(message);
        break;
      default:
        this.logger.warn("Unknown machine message type", message);
        break;
    }
    await this.updateCabinetAndPlayfieldLastMessage(message);
    await this.machineMessageRepository.updateMachineMessage(
      message.messageId,
      1
    );
    return true;
  }
  async handleFailedMessage(message) {
    this.logger.error(`Failed message:  ${JSON.stringify(message)}`);
    try {
      await this.machineMessageRepository.updateMachineMessage(
        message.messageId,
        2
      );
    } catch {
      return;
    }
  }
  async updateCabinetAndPlayfieldLastMessage(message) {
    try {
      await this.cabinetRepository.transaction(async (trx) => {
        await this.cabinetRepository.withTransaction(trx).updateCabinet(message.serial_number, {
          last_machine_message: message.timestamp
        });
        if (message.playfieldId) {
          await this.playfieldRepository.withTransaction(trx).updatePlayfield(message.playfieldId, {
            last_machine_message: message.timestamp
          });
        }
      });
    } catch (error) {
      this.logger.error(
        "Error updating cabinet and playfield last message",
        error
      );
    }
  }
};

// api/functions/machine-sqs-lambda/src/services.ts
var createServices = async (logger) => {
  const db = await getKnexInstance();
  const contextForRepositories = {
    logger
  };
  const gameSessionRepository = new GameSessionRepository(
    db,
    contextForRepositories
  );
  const machineLogRepository = new MachineLogRepository(
    db,
    contextForRepositories
  );
  const machineMessagesRepository = new MachineMessageRepository(
    db,
    contextForRepositories
  );
  const cabinetRepository = new CabinetRepository(db, contextForRepositories);
  const playfieldRepository = new PlayfieldRepository(
    db,
    contextForRepositories
  );
  const machineMessagesService = new MachineMessageService(
    machineMessagesRepository,
    gameSessionRepository,
    machineLogRepository,
    cabinetRepository,
    playfieldRepository,
    contextForRepositories
  );
  return { machineMessagesService };
};

// api/functions/machine-sqs-lambda/src/sqs-message.ts
var getPropertiesFromMqttTopic = (topic) => {
  const topicDirectories = topic.split("/");
  const playfieldId = topicDirectories[1];
  const cabinetId = topicDirectories[0];
  return {
    playfieldId,
    cabinetId
  };
};
var getMachineMessagesFromSQSMessage = (message) => {
  if (!message.Body && !message.body) {
    return [];
  }
  try {
    const parsedBody = JSON.parse(
      message.Body || message.body
    );
    const props = getPropertiesFromMqttTopic(parsedBody.topic);
    const isNested = parsedBody.message.e !== void 0 && Array.isArray(parsedBody.message.e);
    const messagesFromBody = isNested ? parsedBody.message.e : parsedBody.message;
    const isArrayOfMessages = Array.isArray(messagesFromBody);
    const messages = isArrayOfMessages ? messagesFromBody : [messagesFromBody];
    const messagesWithProps = messages.map((m3) => ({
      ...m3,
      c: props.cabinetId,
      p: props.playfieldId
    }));
    return MachineMessage.fromMachineInput(messagesWithProps);
  } catch (e3) {
    LOGGER.error(`Error parsing message body: ${e3}`);
    return [];
  }
};

// api/functions/machine-sqs-lambda/src/handler.ts
var handler = async (event, context) => {
  const logger = LOGGER.getChildLogger(
    {
      requestId: context.awsRequestId
    },
    {}
  );
  const { machineMessagesService } = await createServices(logger);
  logger.debug(`Received event: ${JSON.stringify(event, null, 2)}`);
  const failedMessages = [];
  const addFailedMessage = (message) => {
    failedMessages.push({
      itemIdentifier: message.messageId
    });
  };
  await Promise.all(
    event.Records.map(async (message) => {
      const machineMessages = getMachineMessagesFromSQSMessage(message);
      let result = true;
      for await (const machineMessage of machineMessages) {
        try {
          logger.debug(
            `Processing message: ${JSON.stringify(machineMessage, null, 2)}`
          );
          if (!await machineMessagesService.handleMessage(machineMessage)) {
            result = false;
          }
        } catch (error) {
          logger.error(`Error processing message: ${error}`);
          result = false;
        }
      }
      if (!result) {
        addFailedMessage(message);
      }
    })
  );
  return {
    batchItemFailures: failedMessages
  };
};
export {
  handler
};
